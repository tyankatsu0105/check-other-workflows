import { graphql, ResponseResolver, GraphQLRequest, GraphQLContext } from 'msw'
type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A (potentially binary) string encoded using base64. */
  Base64String: { input: any; output: any; }
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: { input: any; output: any; }
  /** An ISO-8601 encoded date string. */
  Date: { input: any; output: any; }
  /** An ISO-8601 encoded UTC date string. */
  DateTime: { input: any; output: any; }
  /** A Git object ID. */
  GitObjectID: { input: any; output: any; }
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: { input: any; output: any; }
  /** Git SSH string */
  GitSSHRemote: { input: any; output: any; }
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: { input: any; output: any; }
  /** A string containing HTML code. */
  HTML: { input: any; output: any; }
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  PreciseDateTime: { input: any; output: any; }
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: { input: string; output: string; }
  /** A valid x509 certificate string */
  X509Certificate: { input: any; output: any; }
};

/** Autogenerated input type of AbortQueuedMigrations */
type AbortQueuedMigrationsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that is running the migrations. */
  readonly ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of AbortQueuedMigrations */
type AbortQueuedMigrationsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  readonly success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
type AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the invitation being accepted */
  readonly invitationId: Scalars['ID']['input'];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
type AcceptEnterpriseAdministratorInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The invitation that was accepted. */
  readonly invitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the suggested topic. */
  readonly name: Scalars['String']['input'];
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of AcceptTopicSuggestion */
type AcceptTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The accepted topic. */
  readonly topic?: Maybe<Topic>;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
type Actor = {
  /** A URL pointing to the actor's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** The username of the actor. */
  readonly login: Scalars['String']['output'];
  /** The HTTP path for this actor. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this actor. */
  readonly url: Scalars['URI']['output'];
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
type ActorAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Location information for an actor */
type ActorLocation = {
  /** City */
  readonly city?: Maybe<Scalars['String']['output']>;
  /** Country name */
  readonly country?: Maybe<Scalars['String']['output']>;
  /** Country code */
  readonly countryCode?: Maybe<Scalars['String']['output']>;
  /** Region name */
  readonly region?: Maybe<Scalars['String']['output']>;
  /** Region or state code */
  readonly regionCode?: Maybe<Scalars['String']['output']>;
};

/** The actor's type. */
enum ActorType {
  /** Indicates a team actor. */
  Team = 'TEAM',
  /** Indicates a user actor. */
  User = 'USER'
}

/** Autogenerated input type of AddAssigneesToAssignable */
type AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  readonly assignableId: Scalars['ID']['input'];
  /** The id of users to add as assignees. */
  readonly assigneeIds: ReadonlyArray<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of AddAssigneesToAssignable */
type AddAssigneesToAssignablePayload = {
  /** The item that was assigned. */
  readonly assignable?: Maybe<Assignable>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AddComment */
type AddCommentInput = {
  /** The contents of the comment. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddComment */
type AddCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The edge from the subject's comment connection. */
  readonly commentEdge?: Maybe<IssueCommentEdge>;
  /** The subject */
  readonly subject?: Maybe<Node>;
  /** The edge from the subject's timeline connection. */
  readonly timelineEdge?: Maybe<IssueTimelineItemEdge>;
};

/** Autogenerated input type of AddDiscussionComment */
type AddDiscussionCommentInput = {
  /** The contents of the comment. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to comment on. */
  readonly discussionId: Scalars['ID']['input'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  readonly replyToId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddDiscussionComment */
type AddDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created discussion comment. */
  readonly comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of AddDiscussionPollVote */
type AddDiscussionPollVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion poll option to vote for. */
  readonly pollOptionId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddDiscussionPollVote */
type AddDiscussionPollVotePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The poll option that a vote was added to. */
  readonly pollOption?: Maybe<DiscussionPollOption>;
};

/** Autogenerated input type of AddEnterpriseOrganizationMember */
type AddEnterpriseOrganizationMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise which owns the organization. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization the users will be added to. */
  readonly organizationId: Scalars['ID']['input'];
  /** The role to assign the users in the organization */
  readonly role?: InputMaybe<OrganizationMemberRole>;
  /** The IDs of the enterprise members to add. */
  readonly userIds: ReadonlyArray<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddEnterpriseOrganizationMember */
type AddEnterpriseOrganizationMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The users who were added to the organization. */
  readonly users?: Maybe<ReadonlyArray<User>>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
type AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will receive the support entitlement. */
  readonly login: Scalars['String']['input'];
};

/** Autogenerated return type of AddEnterpriseSupportEntitlement */
type AddEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of adding the support entitlement. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of AddLabelsToLabelable */
type AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of the labels to add. */
  readonly labelIds: ReadonlyArray<Scalars['ID']['input']>;
  /** The id of the labelable object to add labels to. */
  readonly labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddLabelsToLabelable */
type AddLabelsToLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was labeled. */
  readonly labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of AddProjectCard */
type AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  readonly contentId?: InputMaybe<Scalars['ID']['input']>;
  /** The note on the card. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the ProjectColumn. */
  readonly projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectCard */
type AddProjectCardPayload = {
  /** The edge from the ProjectColumn's card connection. */
  readonly cardEdge?: Maybe<ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ProjectColumn */
  readonly projectColumn?: Maybe<ProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the column. */
  readonly name: Scalars['String']['input'];
  /** The Node ID of the project. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectColumn */
type AddProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The edge from the project's column connection. */
  readonly columnEdge?: Maybe<ProjectColumnEdge>;
  /** The project */
  readonly project?: Maybe<Project>;
};

/** Autogenerated input type of AddProjectV2DraftIssue */
type AddProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  readonly assigneeIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to add the draft issue to. */
  readonly projectId: Scalars['ID']['input'];
  /**
   * The title of the draft issue. A project item can also be created by providing
   * the URL of an Issue or Pull Request if you have access.
   */
  readonly title: Scalars['String']['input'];
};

/** Autogenerated return type of AddProjectV2DraftIssue */
type AddProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The draft issue added to the project. */
  readonly projectItem?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of AddProjectV2ItemById */
type AddProjectV2ItemByIdInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the Issue or Pull Request to add. */
  readonly contentId: Scalars['ID']['input'];
  /** The ID of the Project to add the item to. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddProjectV2ItemById */
type AddProjectV2ItemByIdPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item added to the project. */
  readonly item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
type AddPullRequestReviewCommentInput = {
  /**
   * The text of the comment. This field is required
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The SHA of the commit to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;
  /**
   * The comment id to reply to.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly inReplyTo?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The relative path of the file to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly path?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line index in the diff to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly position?: InputMaybe<Scalars['Int']['input']>;
  /**
   * The node ID of the pull request reviewing
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The Node ID of the review to modify.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestReviewId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  readonly pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AddPullRequestReviewComment */
type AddPullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created comment. */
  readonly comment?: Maybe<PullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  readonly commentEdge?: Maybe<PullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
type AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The review line comments.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `comments` will be removed. use the `threads` argument instead
   * **Reason:** We are deprecating comment fields that use diff-relative positioning
   */
  readonly comments?: InputMaybe<ReadonlyArray<InputMaybe<DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  readonly commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The event to perform on the pull request review. */
  readonly event?: InputMaybe<PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  readonly pullRequestId: Scalars['ID']['input'];
  /** The review line comment threads. */
  readonly threads?: InputMaybe<ReadonlyArray<InputMaybe<DraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview */
type AddPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created pull request review. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
  /** The edge from the pull request's review connection. */
  readonly reviewEdge?: Maybe<PullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
type AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line of the blob to which the thread refers, required for line-level
   * threads. The end of the line range for multi-line comments.
   */
  readonly line?: InputMaybe<Scalars['Int']['input']>;
  /** Path to the file being commented on. */
  readonly path: Scalars['String']['input'];
  /** The node ID of the pull request reviewing */
  readonly pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the review to modify. */
  readonly pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  readonly side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  readonly startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  readonly startSide?: InputMaybe<DiffSide>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  readonly subjectType?: InputMaybe<PullRequestReviewThreadSubjectType>;
};

/** Autogenerated return type of AddPullRequestReviewThread */
type AddPullRequestReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created thread. */
  readonly thread?: Maybe<PullRequestReviewThread>;
};

/** Autogenerated input type of AddPullRequestReviewThreadReply */
type AddPullRequestReviewThreadReplyInput = {
  /** The text of the reply. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending review to which the reply will belong. */
  readonly pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the thread to which this reply is being written. */
  readonly pullRequestReviewThreadId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddPullRequestReviewThreadReply */
type AddPullRequestReviewThreadReplyPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created reply. */
  readonly comment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of AddReaction */
type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji to react with. */
  readonly content: ReactionContent;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddReaction */
type AddReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The reaction object. */
  readonly reaction?: Maybe<Reaction>;
  /** The reaction groups for the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** The reactable subject. */
  readonly subject?: Maybe<Reactable>;
};

/** Autogenerated input type of AddStar */
type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to star. */
  readonly starrableId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddStar */
type AddStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The starrable. */
  readonly starrable?: Maybe<Starrable>;
};

/** Autogenerated input type of AddUpvote */
type AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to upvote. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddUpvote */
type AddUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The votable subject. */
  readonly subject?: Maybe<Votable>;
};

/** Autogenerated input type of AddVerifiableDomain */
type AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the domain */
  readonly domain: Scalars['URI']['input'];
  /** The ID of the owner to add the domain to */
  readonly ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddVerifiableDomain */
type AddVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was added. */
  readonly domain?: Maybe<VerifiableDomain>;
};

/** Represents an 'added_to_merge_queue' event on a given pull request. */
type AddedToMergeQueueEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who added this Pull Request to the merge queue */
  readonly enqueuer?: Maybe<User>;
  readonly id: Scalars['ID']['output'];
  /** The merge queue where this pull request was added to. */
  readonly mergeQueue?: Maybe<MergeQueue>;
  /** PullRequest referenced by event. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
type AddedToProjectEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Project referenced by event. */
  readonly project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  readonly projectCard?: Maybe<ProjectCard>;
  /** Column name referenced by this project event. */
  readonly projectColumnName: Scalars['String']['output'];
};

/** Represents an announcement banner. */
type AnnouncementBanner = {
  /** The text of the announcement */
  readonly announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  readonly announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  readonly announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
};

/** A GitHub App. */
type App = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the app. */
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The IP addresses of the app. */
  readonly ipAllowListEntries: IpAllowListEntryConnection;
  /** The hex color code, without the leading '#', for the logo background. */
  readonly logoBackgroundColor: Scalars['String']['output'];
  /** A URL pointing to the app's logo. */
  readonly logoUrl: Scalars['URI']['output'];
  /** The name of the app. */
  readonly name: Scalars['String']['output'];
  /** A slug based on the name of the app for use in URLs. */
  readonly slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The URL to the app's homepage. */
  readonly url: Scalars['URI']['output'];
};


/** A GitHub App. */
type AppIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};


/** A GitHub App. */
type AppLogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ApproveDeployments */
type ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for approving deployments */
  readonly comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  readonly environmentIds: ReadonlyArray<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  readonly workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated return type of ApproveDeployments */
type ApproveDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The affected deployments. */
  readonly deployments?: Maybe<ReadonlyArray<Deployment>>;
};

/** Autogenerated input type of ApproveVerifiableDomain */
type ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to approve. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of ApproveVerifiableDomain */
type ApproveVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was approved. */
  readonly domain?: Maybe<VerifiableDomain>;
};

/** Autogenerated input type of ArchiveProjectV2Item */
type ArchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to archive. */
  readonly itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveProjectV2Item */
type ArchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item archived from the project. */
  readonly item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of ArchiveRepository */
type ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to mark as archived. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveRepository */
type ArchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was marked as archived. */
  readonly repository?: Maybe<Repository>;
};

/** An object that can have users assigned to it. */
type Assignable = {
  /** A list of Users assigned to this object. */
  readonly assignees: UserConnection;
};


/** An object that can have users assigned to it. */
type AssignableAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an 'assigned' event on any assignable object. */
type AssignedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the assignable associated with the event. */
  readonly assignable: Assignable;
  /** Identifies the user or mannequin that was assigned. */
  readonly assignee?: Maybe<Assignee>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  readonly user?: Maybe<User>;
};

/** Types that can be assigned to issues. */
type Assignee = Bot | Mannequin | Organization | User;

/** An entry in the audit log. */
type AuditEntry = {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Types that can initiate an audit log event. */
type AuditEntryActor = Bot | Organization | User;

/** Ordering options for Audit Log connections. */
type AuditLogOrder = {
  /** The ordering direction. */
  readonly direction?: InputMaybe<OrderDirection>;
  /** The field to order Audit Logs by. */
  readonly field?: InputMaybe<AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
enum AuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = 'CREATED_AT'
}

/** Represents a 'auto_merge_disabled' event on a given pull request. */
type AutoMergeDisabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who disabled auto-merge for this Pull Request */
  readonly disabler?: Maybe<User>;
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event */
  readonly pullRequest?: Maybe<PullRequest>;
  /** The reason auto-merge was disabled */
  readonly reason?: Maybe<Scalars['String']['output']>;
  /** The reason_code relating to why auto-merge was disabled */
  readonly reasonCode?: Maybe<Scalars['String']['output']>;
};

/** Represents a 'auto_merge_enabled' event on a given pull request. */
type AutoMergeEnabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge for this Pull Request */
  readonly enabler?: Maybe<User>;
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents an auto-merge request for a pull request */
type AutoMergeRequest = {
  /** The email address of the author of this auto-merge request. */
  readonly authorEmail?: Maybe<Scalars['String']['output']>;
  /**
   * The commit message of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  readonly commitBody?: Maybe<Scalars['String']['output']>;
  /**
   * The commit title of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging
   */
  readonly commitHeadline?: Maybe<Scalars['String']['output']>;
  /** When was this auto-merge request was enabled. */
  readonly enabledAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who created the auto-merge request. */
  readonly enabledBy?: Maybe<Actor>;
  /**
   * The merge method of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  readonly mergeMethod: PullRequestMergeMethod;
  /** The pull request that this auto-merge request is set against. */
  readonly pullRequest: PullRequest;
};

/** Represents a 'auto_rebase_enabled' event on a given pull request. */
type AutoRebaseEnabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge (rebase) for this Pull Request */
  readonly enabler?: Maybe<User>;
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'auto_squash_enabled' event on a given pull request. */
type AutoSquashEnabledEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who enabled auto-merge (squash) for this Pull Request */
  readonly enabler?: Maybe<User>;
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
type AutomaticBaseChangeFailedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The new base for this PR */
  readonly newBase: Scalars['String']['output'];
  /** The old base for this PR */
  readonly oldBase: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
type AutomaticBaseChangeSucceededEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The new base for this PR */
  readonly newBase: Scalars['String']['output'];
  /** The old base for this PR */
  readonly oldBase: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
type BaseRefChangedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the name of the base ref for the pull request after it was changed. */
  readonly currentRefName: Scalars['String']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the name of the base ref for the pull request before it was changed. */
  readonly previousRefName: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
};

/** Represents a 'base_ref_deleted' event on a given pull request. */
type BaseRefDeletedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */
  readonly baseRefName?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
type BaseRefForcePushedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  readonly afterCommit?: Maybe<Commit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  readonly beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  readonly ref?: Maybe<Ref>;
};

/** Represents a Git blame. */
type Blame = {
  /** The list of ranges from a Git blame. */
  readonly ranges: ReadonlyArray<BlameRange>;
};

/** Represents a range of information from a Git blame. */
type BlameRange = {
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  readonly age: Scalars['Int']['output'];
  /** Identifies the line author */
  readonly commit: Commit;
  /** The ending line for the range */
  readonly endingLine: Scalars['Int']['output'];
  /** The starting line for the range */
  readonly startingLine: Scalars['Int']['output'];
};

/** Represents a Git blob. */
type Blob = GitObject & Node & {
  /** An abbreviated version of the Git object ID */
  readonly abbreviatedOid: Scalars['String']['output'];
  /** Byte size of Blob object */
  readonly byteSize: Scalars['Int']['output'];
  /** The HTTP path for this Git object */
  readonly commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  readonly commitUrl: Scalars['URI']['output'];
  readonly id: Scalars['ID']['output'];
  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */
  readonly isBinary?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates whether the contents is truncated */
  readonly isTruncated: Scalars['Boolean']['output'];
  /** The Git object ID */
  readonly oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  readonly repository: Repository;
  /** UTF8 text data or null if the Blob is binary */
  readonly text?: Maybe<Scalars['String']['output']>;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
type Bot = Actor & Node & UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The username of the actor. */
  readonly login: Scalars['String']['output'];
  /** The HTTP path for this bot */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this bot */
  readonly url: Scalars['URI']['output'];
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
type BotAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Types which can be actors for `BranchActorAllowance` objects. */
type BranchActorAllowanceActor = App | Team | User;

/** Parameters to be used for the branch_name_pattern rule */
type BranchNamePatternParameters = {
  /** How this rule will appear to users. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['output'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['output'];
};

/** Parameters to be used for the branch_name_pattern rule */
type BranchNamePatternParametersInput = {
  /** How this rule will appear to users. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['input'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['input'];
};

/** A branch protection rule. */
type BranchProtectionRule = Node & {
  /** Can this branch be deleted. */
  readonly allowsDeletions: Scalars['Boolean']['output'];
  /** Are force pushes allowed on this branch. */
  readonly allowsForcePushes: Scalars['Boolean']['output'];
  /** Is branch creation a protected operation. */
  readonly blocksCreations: Scalars['Boolean']['output'];
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  readonly branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection;
  /** A list of actors able to force push for this branch protection rule. */
  readonly bypassForcePushAllowances: BypassForcePushAllowanceConnection;
  /** A list of actors able to bypass PRs for this branch protection rule. */
  readonly bypassPullRequestAllowances: BypassPullRequestAllowanceConnection;
  /** The actor who created this branch protection rule. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  readonly dismissesStaleReviews: Scalars['Boolean']['output'];
  readonly id: Scalars['ID']['output'];
  /** Can admins overwrite branch protection. */
  readonly isAdminEnforced: Scalars['Boolean']['output'];
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  readonly lockAllowsFetchAndMerge: Scalars['Boolean']['output'];
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  readonly lockBranch: Scalars['Boolean']['output'];
  /** Repository refs that are protected by this rule */
  readonly matchingRefs: RefConnection;
  /** Identifies the protection rule pattern. */
  readonly pattern: Scalars['String']['output'];
  /** A list push allowances for this branch protection rule. */
  readonly pushAllowances: PushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  readonly repository?: Maybe<Repository>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  readonly requireLastPushApproval: Scalars['Boolean']['output'];
  /** Number of approving reviews required to update matching branches. */
  readonly requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;
  /** List of required deployment environments that must be deployed successfully to update matching branches */
  readonly requiredDeploymentEnvironments?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusCheckContexts?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  /** List of required status checks that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusChecks?: Maybe<ReadonlyArray<RequiredStatusCheckDescription>>;
  /** Are approving reviews required to update matching branches. */
  readonly requiresApprovingReviews: Scalars['Boolean']['output'];
  /** Are reviews from code owners required to update matching branches. */
  readonly requiresCodeOwnerReviews: Scalars['Boolean']['output'];
  /** Are commits required to be signed. */
  readonly requiresCommitSignatures: Scalars['Boolean']['output'];
  /** Are conversations required to be resolved before merging. */
  readonly requiresConversationResolution: Scalars['Boolean']['output'];
  /** Does this branch require deployment to specific environments before merging */
  readonly requiresDeployments: Scalars['Boolean']['output'];
  /** Are merge commits prohibited from being pushed to this branch. */
  readonly requiresLinearHistory: Scalars['Boolean']['output'];
  /** Are status checks required to update matching branches. */
  readonly requiresStatusChecks: Scalars['Boolean']['output'];
  /** Are branches required to be up to date before merging. */
  readonly requiresStrictStatusChecks: Scalars['Boolean']['output'];
  /** Is pushing to matching branches restricted. */
  readonly restrictsPushes: Scalars['Boolean']['output'];
  /** Is dismissal of pull request reviews restricted. */
  readonly restrictsReviewDismissals: Scalars['Boolean']['output'];
  /** A list review dismissal allowances for this branch protection rule. */
  readonly reviewDismissalAllowances: ReviewDismissalAllowanceConnection;
};


/** A branch protection rule. */
type BranchProtectionRuleBranchProtectionRuleConflictsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
type BranchProtectionRuleBypassForcePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
type BranchProtectionRuleBypassPullRequestAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
type BranchProtectionRuleMatchingRefsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A branch protection rule. */
type BranchProtectionRulePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A branch protection rule. */
type BranchProtectionRuleReviewDismissalAllowancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A conflict between two branch protection rules. */
type BranchProtectionRuleConflict = {
  /** Identifies the branch protection rule. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  readonly conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  readonly ref?: Maybe<Ref>;
};

/** The connection type for BranchProtectionRuleConflict. */
type BranchProtectionRuleConflictConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<BranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<BranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type BranchProtectionRuleConflictEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<BranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
type BranchProtectionRuleConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<BranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<BranchProtectionRule>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type BranchProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<BranchProtectionRule>;
};

/**
 * Information about a sponsorship to make for a user or organization with a GitHub
 * Sponsors profile, as part of sponsoring many users or organizations at once.
 */
type BulkSponsorship = {
  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */
  readonly amount: Scalars['Int']['input'];
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Types that can represent a repository ruleset bypass actor. */
type BypassActor = App | Team;

/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */
type BypassForcePushAllowance = Node & {
  /** The actor that can force push. */
  readonly actor?: Maybe<BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  readonly id: Scalars['ID']['output'];
};

/** The connection type for BypassForcePushAllowance. */
type BypassForcePushAllowanceConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<BypassForcePushAllowanceEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<BypassForcePushAllowance>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type BypassForcePushAllowanceEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<BypassForcePushAllowance>;
};

/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */
type BypassPullRequestAllowance = Node & {
  /** The actor that can bypass. */
  readonly actor?: Maybe<BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  readonly id: Scalars['ID']['output'];
};

/** The connection type for BypassPullRequestAllowance. */
type BypassPullRequestAllowanceConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<BypassPullRequestAllowanceEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<BypassPullRequestAllowance>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type BypassPullRequestAllowanceEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<BypassPullRequestAllowance>;
};

/** The Common Vulnerability Scoring System */
type Cvss = {
  /** The CVSS score associated with this advisory */
  readonly score: Scalars['Float']['output'];
  /** The CVSS vector string associated with this advisory */
  readonly vectorString?: Maybe<Scalars['String']['output']>;
};

/** A common weakness enumeration */
type Cwe = Node & {
  /** The id of the CWE */
  readonly cweId: Scalars['String']['output'];
  /** A detailed description of this CWE */
  readonly description: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of this CWE */
  readonly name: Scalars['String']['output'];
};

/** The connection type for CWE. */
type CweConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CweEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Cwe>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CweEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Cwe>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
type CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  readonly invitationId: Scalars['ID']['input'];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
type CancelEnterpriseAdminInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The invitation that was canceled. */
  readonly invitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CancelSponsorship */
type CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  readonly sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  readonly sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CancelSponsorship */
type CancelSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was being used at the time of cancellation. */
  readonly sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of ChangeUserStatus */
type ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  readonly emoji?: InputMaybe<Scalars['String']['input']>;
  /** If set, the user status will not be shown after this date. */
  readonly expiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  readonly limitedAvailability?: InputMaybe<Scalars['Boolean']['input']>;
  /** A short description of your current status. */
  readonly message?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  readonly organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of ChangeUserStatus */
type ChangeUserStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Your updated status. */
  readonly status?: Maybe<UserStatus>;
};

/** A single check annotation. */
type CheckAnnotation = {
  /** The annotation's severity level. */
  readonly annotationLevel?: Maybe<CheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  readonly blobUrl: Scalars['URI']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The position of this annotation. */
  readonly location: CheckAnnotationSpan;
  /** The annotation's message. */
  readonly message: Scalars['String']['output'];
  /** The path that this annotation was made on. */
  readonly path: Scalars['String']['output'];
  /** Additional information about the annotation. */
  readonly rawDetails?: Maybe<Scalars['String']['output']>;
  /** The annotation's title */
  readonly title?: Maybe<Scalars['String']['output']>;
};

/** The connection type for CheckAnnotation. */
type CheckAnnotationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CheckAnnotationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CheckAnnotation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Information from a check run analysis to specific lines of code. */
type CheckAnnotationData = {
  /** Represents an annotation's information level */
  readonly annotationLevel: CheckAnnotationLevel;
  /** The location of the annotation */
  readonly location: CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  readonly message: Scalars['String']['input'];
  /** The path of the file to add an annotation to. */
  readonly path: Scalars['String']['input'];
  /** Details about this annotation. */
  readonly rawDetails?: InputMaybe<Scalars['String']['input']>;
  /** The title that represents the annotation. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** An edge in a connection. */
type CheckAnnotationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CheckAnnotation>;
};

/** Represents an annotation's information level. */
enum CheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = 'FAILURE',
  /** An annotation indicating some information. */
  Notice = 'NOTICE',
  /** An annotation indicating an ignorable error. */
  Warning = 'WARNING'
}

/** A character position in a check annotation. */
type CheckAnnotationPosition = {
  /** Column number (1 indexed). */
  readonly column?: Maybe<Scalars['Int']['output']>;
  /** Line number (1 indexed). */
  readonly line: Scalars['Int']['output'];
};

/** Information from a check run analysis to specific lines of code. */
type CheckAnnotationRange = {
  /** The ending column of the range. */
  readonly endColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The ending line of the range. */
  readonly endLine: Scalars['Int']['input'];
  /** The starting column of the range. */
  readonly startColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The starting line of the range. */
  readonly startLine: Scalars['Int']['input'];
};

/** An inclusive pair of positions for a check annotation. */
type CheckAnnotationSpan = {
  /** End position (inclusive). */
  readonly end: CheckAnnotationPosition;
  /** Start position (inclusive). */
  readonly start: CheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
enum CheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check suite or run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check suite or run has failed. */
  Failure = 'FAILURE',
  /** The check suite or run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check suite or run was skipped. */
  Skipped = 'SKIPPED',
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check suite or run has failed at startup. */
  StartupFailure = 'STARTUP_FAILURE',
  /** The check suite or run has succeeded. */
  Success = 'SUCCESS',
  /** The check suite or run has timed out. */
  TimedOut = 'TIMED_OUT'
}

/** A check run. */
type CheckRun = Node & RequirableByPullRequest & UniformResourceLocatable & {
  /** The check run's annotations */
  readonly annotations?: Maybe<CheckAnnotationConnection>;
  /** The check suite that this run is a part of. */
  readonly checkSuite: CheckSuite;
  /** Identifies the date and time when the check run was completed. */
  readonly completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The conclusion of the check run. */
  readonly conclusion?: Maybe<CheckConclusionState>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The corresponding deployment for this job, if any */
  readonly deployment?: Maybe<Deployment>;
  /** The URL from which to find full details of the check run on the integrator's site. */
  readonly detailsUrl?: Maybe<Scalars['URI']['output']>;
  /** A reference for the check run on the integrator's system. */
  readonly externalId?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Whether this is required to pass before merging for a specific pull request. */
  readonly isRequired: Scalars['Boolean']['output'];
  /** The name of the check for this check run. */
  readonly name: Scalars['String']['output'];
  /** Information about a pending deployment, if any, in this check run */
  readonly pendingDeploymentRequest?: Maybe<DeploymentRequest>;
  /** The permalink to the check run summary. */
  readonly permalink: Scalars['URI']['output'];
  /** The repository associated with this check run. */
  readonly repository: Repository;
  /** The HTTP path for this check run. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the check run was started. */
  readonly startedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current status of the check run. */
  readonly status: CheckStatusState;
  /** The check run's steps */
  readonly steps?: Maybe<CheckStepConnection>;
  /** A string representing the check run's summary */
  readonly summary?: Maybe<Scalars['String']['output']>;
  /** A string representing the check run's text */
  readonly text?: Maybe<Scalars['String']['output']>;
  /** A string representing the check run */
  readonly title?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this check run. */
  readonly url: Scalars['URI']['output'];
};


/** A check run. */
type CheckRunAnnotationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A check run. */
type CheckRunIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};


/** A check run. */
type CheckRunStepsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
};

/** Possible further actions the integrator can perform. */
type CheckRunAction = {
  /** A short explanation of what this action would do. */
  readonly description: Scalars['String']['input'];
  /** A reference for the action on the integrator's system. */
  readonly identifier: Scalars['String']['input'];
  /** The text to be displayed on a button in the web UI. */
  readonly label: Scalars['String']['input'];
};

/** The connection type for CheckRun. */
type CheckRunConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CheckRunEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CheckRun>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CheckRunEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CheckRun>;
};

/** The filters that are available when fetching check runs. */
type CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  readonly appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check runs by this name. */
  readonly checkName?: InputMaybe<Scalars['String']['input']>;
  /** Filters the check runs by this type. */
  readonly checkType?: InputMaybe<CheckRunType>;
  /** Filters the check runs by these conclusions. */
  readonly conclusions?: InputMaybe<ReadonlyArray<CheckConclusionState>>;
  /** Filters the check runs by this status. Superceded by statuses. */
  readonly status?: InputMaybe<CheckStatusState>;
  /** Filters the check runs by this status. Overrides status. */
  readonly statuses?: InputMaybe<ReadonlyArray<CheckStatusState>>;
};

/** Descriptive details about the check run. */
type CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  readonly annotations?: InputMaybe<ReadonlyArray<CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  readonly images?: InputMaybe<ReadonlyArray<CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  readonly summary: Scalars['String']['input'];
  /** The details of the check run (supports Commonmark). */
  readonly text?: InputMaybe<Scalars['String']['input']>;
  /** A title to provide for this check run. */
  readonly title: Scalars['String']['input'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
type CheckRunOutputImage = {
  /** The alternative text for the image. */
  readonly alt: Scalars['String']['input'];
  /** A short image description. */
  readonly caption?: InputMaybe<Scalars['String']['input']>;
  /** The full URL of the image. */
  readonly imageUrl: Scalars['URI']['input'];
};

/** The possible states of a check run in a status rollup. */
enum CheckRunState {
  /** The check run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check run has been completed. */
  Completed = 'COMPLETED',
  /** The check run has failed. */
  Failure = 'FAILURE',
  /** The check run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check run is in pending state. */
  Pending = 'PENDING',
  /** The check run has been queued. */
  Queued = 'QUEUED',
  /** The check run was skipped. */
  Skipped = 'SKIPPED',
  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check run has failed at startup. */
  StartupFailure = 'STARTUP_FAILURE',
  /** The check run has succeeded. */
  Success = 'SUCCESS',
  /** The check run has timed out. */
  TimedOut = 'TIMED_OUT',
  /** The check run is in waiting state. */
  Waiting = 'WAITING'
}

/** Represents a count of the state of a check run. */
type CheckRunStateCount = {
  /** The number of check runs with this state. */
  readonly count: Scalars['Int']['output'];
  /** The state of a check run. */
  readonly state: CheckRunState;
};

/** The possible types of check runs. */
enum CheckRunType {
  /** Every check run available. */
  All = 'ALL',
  /** The latest check run. */
  Latest = 'LATEST'
}

/** The possible states for a check suite or run status. */
enum CheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run has been requested. */
  Requested = 'REQUESTED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING'
}

/** A single check step. */
type CheckStep = {
  /** Identifies the date and time when the check step was completed. */
  readonly completedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The conclusion of the check step. */
  readonly conclusion?: Maybe<CheckConclusionState>;
  /** A reference for the check step on the integrator's system. */
  readonly externalId?: Maybe<Scalars['String']['output']>;
  /** The step's name. */
  readonly name: Scalars['String']['output'];
  /** The index of the step in the list of steps of the parent check run. */
  readonly number: Scalars['Int']['output'];
  /** Number of seconds to completion. */
  readonly secondsToCompletion?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the check step was started. */
  readonly startedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current status of the check step. */
  readonly status: CheckStatusState;
};

/** The connection type for CheckStep. */
type CheckStepConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CheckStepEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CheckStep>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CheckStepEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CheckStep>;
};

/** A check suite. */
type CheckSuite = Node & {
  /** The GitHub App which created this check suite. */
  readonly app?: Maybe<App>;
  /** The name of the branch for this check suite. */
  readonly branch?: Maybe<Ref>;
  /** The check runs associated with a check suite. */
  readonly checkRuns?: Maybe<CheckRunConnection>;
  /** The commit for this check suite */
  readonly commit: Commit;
  /** The conclusion of this check suite. */
  readonly conclusion?: Maybe<CheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who triggered the check suite. */
  readonly creator?: Maybe<User>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** A list of open pull requests matching the check suite. */
  readonly matchingPullRequests?: Maybe<PullRequestConnection>;
  /** The push that triggered this check suite. */
  readonly push?: Maybe<Push>;
  /** The repository associated with this check suite. */
  readonly repository: Repository;
  /** The HTTP path for this check suite */
  readonly resourcePath: Scalars['URI']['output'];
  /** The status of this check suite. */
  readonly status: CheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this check suite */
  readonly url: Scalars['URI']['output'];
  /** The workflow run associated with this check suite. */
  readonly workflowRun?: Maybe<WorkflowRun>;
};


/** A check suite. */
type CheckSuiteCheckRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<CheckRunFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A check suite. */
type CheckSuiteMatchingPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<PullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
type CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  readonly appId: Scalars['ID']['input'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  readonly setting: Scalars['Boolean']['input'];
};

/** The connection type for CheckSuite. */
type CheckSuiteConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CheckSuiteEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CheckSuite>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CheckSuiteEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CheckSuite>;
};

/** The filters that are available when fetching check suites. */
type CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  readonly appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check suites by this name. */
  readonly checkName?: InputMaybe<Scalars['String']['input']>;
};

/** An object which can have its data claimed or claim data from another. */
type Claimable = Mannequin | User;

/** Autogenerated input type of ClearLabelsFromLabelable */
type ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the labelable object to clear the labels from. */
  readonly labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClearLabelsFromLabelable */
type ClearLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was unlabeled. */
  readonly labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of ClearProjectV2ItemFieldValue */
type ClearProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be cleared. */
  readonly fieldId: Scalars['ID']['input'];
  /** The ID of the item to be cleared. */
  readonly itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClearProjectV2ItemFieldValue */
type ClearProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item. */
  readonly projectV2Item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of CloneProject */
type CloneProjectInput = {
  /** The description of the project. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not to clone the source project's workflows. */
  readonly includeWorkflows: Scalars['Boolean']['input'];
  /** The name of the project. */
  readonly name: Scalars['String']['input'];
  /** The visibility of the project, defaults to false (private). */
  readonly public?: InputMaybe<Scalars['Boolean']['input']>;
  /** The source project to clone. */
  readonly sourceId: Scalars['ID']['input'];
  /** The owner ID to create the project under. */
  readonly targetOwnerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CloneProject */
type CloneProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The id of the JobStatus for populating cloned fields. */
  readonly jobStatusId?: Maybe<Scalars['String']['output']>;
  /** The new cloned project. */
  readonly project?: Maybe<Project>;
};

/** Autogenerated input type of CloneTemplateRepository */
type CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  readonly includeAllBranches?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new repository. */
  readonly name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  readonly ownerId: Scalars['ID']['input'];
  /** The Node ID of the template repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /** Indicates the repository's visibility level. */
  readonly visibility: RepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository */
type CloneTemplateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository. */
  readonly repository?: Maybe<Repository>;
};

/** An object that can be closed */
type Closable = {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CloseDiscussion */
type CloseDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be closed. */
  readonly discussionId: Scalars['ID']['input'];
  /** The reason why the discussion is being closed. */
  readonly reason?: InputMaybe<DiscussionCloseReason>;
};

/** Autogenerated return type of CloseDiscussion */
type CloseDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was closed. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of CloseIssue */
type CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be closed. */
  readonly issueId: Scalars['ID']['input'];
  /** The reason the issue is to be closed. */
  readonly stateReason?: InputMaybe<IssueClosedStateReason>;
};

/** Autogenerated return type of CloseIssue */
type CloseIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was closed. */
  readonly issue?: Maybe<Issue>;
};

/** Autogenerated input type of ClosePullRequest */
type ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be closed. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClosePullRequest */
type ClosePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was closed. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
type ClosedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Object that was closed. */
  readonly closable: Closable;
  /** Object which triggered the creation of this event. */
  readonly closer?: Maybe<Closer>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The HTTP path for this closed event. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The reason the issue state was changed to closed. */
  readonly stateReason?: Maybe<IssueStateReason>;
  /** The HTTP URL for this closed event. */
  readonly url: Scalars['URI']['output'];
};

/** The object which triggered a `ClosedEvent`. */
type Closer = Commit | PullRequest;

/** The Code of Conduct for a repository */
type CodeOfConduct = Node & {
  /** The body of the Code of Conduct */
  readonly body?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The key for the Code of Conduct */
  readonly key: Scalars['String']['output'];
  /** The formal name of the Code of Conduct */
  readonly name: Scalars['String']['output'];
  /** The HTTP path for this Code of Conduct */
  readonly resourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this Code of Conduct */
  readonly url?: Maybe<Scalars['URI']['output']>;
};

/** Collaborators affiliation level with a subject. */
enum CollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = 'ALL',
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = 'DIRECT',
  /** All outside collaborators of an organization-owned subject. */
  Outside = 'OUTSIDE'
}

/** Represents a comment. */
type Comment = {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment. */
type CommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment author association with repository. */
enum CommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = 'COLLABORATOR',
  /** Author has previously committed to the repository. */
  Contributor = 'CONTRIBUTOR',
  /** Author has not previously committed to GitHub. */
  FirstTimer = 'FIRST_TIMER',
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',
  /** Author is a placeholder for an unclaimed user. */
  Mannequin = 'MANNEQUIN',
  /** Author is a member of the organization that owns the repository. */
  Member = 'MEMBER',
  /** Author has no association with the repository. */
  None = 'NONE',
  /** Author is the owner of the repository. */
  Owner = 'OWNER'
}

/** The possible errors that will prevent a user from updating a comment. */
enum CommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = 'ARCHIVED',
  /** You cannot update this comment */
  Denied = 'DENIED',
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = 'INSUFFICIENT_ACCESS',
  /** Unable to create comment because issue is locked. */
  Locked = 'LOCKED',
  /** You must be logged in to update this comment. */
  LoginRequired = 'LOGIN_REQUIRED',
  /** Repository is under maintenance. */
  Maintenance = 'MAINTENANCE',
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'
}

/** Represents a 'comment_deleted' event on a given issue or pull request. */
type CommentDeletedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The user who authored the deleted comment. */
  readonly deletedCommentAuthor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
};

/** Represents a Git commit. */
type Commit = GitObject & Node & Subscribable & UniformResourceLocatable & {
  /** An abbreviated version of the Git object ID */
  readonly abbreviatedOid: Scalars['String']['output'];
  /** The number of additions in this commit. */
  readonly additions: Scalars['Int']['output'];
  /**
   * The merged Pull Request that introduced the commit to the repository. If the
   * commit is not present in the default branch, additionally returns open Pull
   * Requests associated with the commit
   */
  readonly associatedPullRequests?: Maybe<PullRequestConnection>;
  /** Authorship details of the commit. */
  readonly author?: Maybe<GitActor>;
  /** Check if the committer and the author match. */
  readonly authoredByCommitter: Scalars['Boolean']['output'];
  /** The datetime when this commit was authored. */
  readonly authoredDate: Scalars['DateTime']['output'];
  /**
   * The list of authors for this commit based on the git author and the Co-authored-by
   * message trailer. The git author will always be first.
   */
  readonly authors: GitActorConnection;
  /** Fetches `git blame` information. */
  readonly blame: Blame;
  /**
   * We recommend using the `changedFilesIfAvailable` field instead of
   * `changedFiles`, as `changedFiles` will cause your request to return an error
   * if GitHub is unable to calculate the number of changed files.
   * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.
   */
  readonly changedFiles: Scalars['Int']['output'];
  /**
   * The number of changed files in this commit. If GitHub is unable to calculate
   * the number of changed files (for example due to a timeout), this will return
   * `null`. We recommend using this field instead of `changedFiles`.
   */
  readonly changedFilesIfAvailable?: Maybe<Scalars['Int']['output']>;
  /** The check suites associated with a commit. */
  readonly checkSuites?: Maybe<CheckSuiteConnection>;
  /** Comments made on the commit. */
  readonly comments: CommitCommentConnection;
  /** The HTTP path for this Git object */
  readonly commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  readonly commitUrl: Scalars['URI']['output'];
  /** The datetime when this commit was committed. */
  readonly committedDate: Scalars['DateTime']['output'];
  /** Check if committed via GitHub web UI. */
  readonly committedViaWeb: Scalars['Boolean']['output'];
  /** Committer details of the commit. */
  readonly committer?: Maybe<GitActor>;
  /** The number of deletions in this commit. */
  readonly deletions: Scalars['Int']['output'];
  /** The deployments associated with a commit. */
  readonly deployments?: Maybe<DeploymentConnection>;
  /** The tree entry representing the file located at the given path. */
  readonly file?: Maybe<TreeEntry>;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  readonly history: CommitHistoryConnection;
  readonly id: Scalars['ID']['output'];
  /** The Git commit message */
  readonly message: Scalars['String']['output'];
  /** The Git commit message body */
  readonly messageBody: Scalars['String']['output'];
  /** The commit message body rendered to HTML. */
  readonly messageBodyHTML: Scalars['HTML']['output'];
  /** The Git commit message headline */
  readonly messageHeadline: Scalars['String']['output'];
  /** The commit message headline rendered to HTML. */
  readonly messageHeadlineHTML: Scalars['HTML']['output'];
  /** The Git object ID */
  readonly oid: Scalars['GitObjectID']['output'];
  /** The organization this commit was made on behalf of. */
  readonly onBehalfOf?: Maybe<Organization>;
  /** The parents of a commit. */
  readonly parents: CommitConnection;
  /**
   * The datetime when this commit was pushed.
   * @deprecated `pushedDate` is no longer supported. Removal on 2023-07-01 UTC.
   */
  readonly pushedDate?: Maybe<Scalars['DateTime']['output']>;
  /** The Repository this commit belongs to */
  readonly repository: Repository;
  /** The HTTP path for this commit */
  readonly resourcePath: Scalars['URI']['output'];
  /** Commit signing information, if present. */
  readonly signature?: Maybe<GitSignature>;
  /** Status information for this commit */
  readonly status?: Maybe<Status>;
  /** Check and Status rollup information for this commit. */
  readonly statusCheckRollup?: Maybe<StatusCheckRollup>;
  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
  readonly submodules: SubmoduleConnection;
  /**
   * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  readonly tarballUrl: Scalars['URI']['output'];
  /** Commit's root Tree */
  readonly tree: Tree;
  /** The HTTP path for the tree of this commit */
  readonly treeResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the tree of this commit */
  readonly treeUrl: Scalars['URI']['output'];
  /** The HTTP URL for this commit */
  readonly url: Scalars['URI']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
  /**
   * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  readonly zipballUrl: Scalars['URI']['output'];
};


/** Represents a Git commit. */
type CommitAssociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PullRequestOrder>;
};


/** Represents a Git commit. */
type CommitAuthorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
type CommitBlameArgs = {
  path: Scalars['String']['input'];
};


/** Represents a Git commit. */
type CommitCheckSuitesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<CheckSuiteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
type CommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
type CommitDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environments?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DeploymentOrder>;
};


/** Represents a Git commit. */
type CommitFileArgs = {
  path: Scalars['String']['input'];
};


/** Represents a Git commit. */
type CommitHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<CommitAuthor>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  since?: InputMaybe<Scalars['GitTimestamp']['input']>;
  until?: InputMaybe<Scalars['GitTimestamp']['input']>;
};


/** Represents a Git commit. */
type CommitParentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a Git commit. */
type CommitSubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Specifies an author for filtering Git commits. */
type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  readonly emails?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
};

/** Parameters to be used for the commit_author_email_pattern rule */
type CommitAuthorEmailPatternParameters = {
  /** How this rule will appear to users. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['output'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['output'];
};

/** Parameters to be used for the commit_author_email_pattern rule */
type CommitAuthorEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['input'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['input'];
};

/** Represents a comment on a given Commit. */
type CommitComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** Identifies the comment body. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the commit associated with the comment, if the commit exists. */
  readonly commit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  readonly isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  readonly minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies the file path associated with the comment. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** Identifies the line position associated with the comment. */
  readonly position?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The HTTP path permalink for this commit comment. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this commit comment. */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  readonly viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on a given Commit. */
type CommitCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** Represents a comment on a given Commit. */
type CommitCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CommitComment. */
type CommitCommentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CommitCommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CommitComment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CommitCommentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CommitComment>;
};

/** A thread of comments on a commit. */
type CommitCommentThread = Node & RepositoryNode & {
  /** The comments that exist in this thread. */
  readonly comments: CommitCommentConnection;
  /** The commit the comments were made on. */
  readonly commit?: Maybe<Commit>;
  readonly id: Scalars['ID']['output'];
  /** The file the comments were made on. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** The position in the diff for the commit that the comment was made on. */
  readonly position?: Maybe<Scalars['Int']['output']>;
  /** The repository associated with this node. */
  readonly repository: Repository;
};


/** A thread of comments on a commit. */
type CommitCommentThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Commit. */
type CommitConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Ordering options for commit contribution connections. */
type CommitContributionOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field by which to order commit contributions. */
  readonly field: CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
enum CommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = 'COMMIT_COUNT',
  /** Order commit contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT'
}

/** This aggregates commits made by a user within one repository. */
type CommitContributionsByRepository = {
  /** The commit contributions, each representing a day. */
  readonly contributions: CreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  readonly repository: Repository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  readonly url: Scalars['URI']['output'];
};


/** This aggregates commits made by a user within one repository. */
type CommitContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CommitContributionOrder>;
};

/** An edge in a connection. */
type CommitEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Commit>;
};

/** The connection type for Commit. */
type CommitHistoryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** A message to include with a new commit */
type CommitMessage = {
  /** The body of the message. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** The headline of the message. */
  readonly headline: Scalars['String']['input'];
};

/** Parameters to be used for the commit_message_pattern rule */
type CommitMessagePatternParameters = {
  /** How this rule will appear to users. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['output'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['output'];
};

/** Parameters to be used for the commit_message_pattern rule */
type CommitMessagePatternParametersInput = {
  /** How this rule will appear to users. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['input'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['input'];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * `repositoryNameWithOwner` and `branchName`.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using `repositoryNameWithOwner` and `branchName`:
 *
 *     {
 *       "repositoryNameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
type CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  readonly branchName?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be updated. */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** The nameWithOwner of the repository to commit to. */
  readonly repositoryNameWithOwner?: InputMaybe<Scalars['String']['input']>;
};

/** Parameters to be used for the committer_email_pattern rule */
type CommitterEmailPatternParameters = {
  /** How this rule will appear to users. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['output'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['output'];
};

/** Parameters to be used for the committer_email_pattern rule */
type CommitterEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['input'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['input'];
};

/** Represents a comparison between two commit revisions. */
type Comparison = Node & {
  /** The number of commits ahead of the base branch. */
  readonly aheadBy: Scalars['Int']['output'];
  /** The base revision of this comparison. */
  readonly baseTarget: GitObject;
  /** The number of commits behind the base branch. */
  readonly behindBy: Scalars['Int']['output'];
  /** The commits which compose this comparison. */
  readonly commits: ComparisonCommitConnection;
  /** The head revision of this comparison. */
  readonly headTarget: GitObject;
  readonly id: Scalars['ID']['output'];
  /** The status of this comparison. */
  readonly status: ComparisonStatus;
};


/** Represents a comparison between two commit revisions. */
type ComparisonCommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Commit. */
type ComparisonCommitConnection = {
  /** The total count of authors and co-authors across all commits. */
  readonly authorCount: Scalars['Int']['output'];
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** The status of a git comparison between two refs. */
enum ComparisonStatus {
  /** The head ref is ahead of the base ref. */
  Ahead = 'AHEAD',
  /** The head ref is behind the base ref. */
  Behind = 'BEHIND',
  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */
  Diverged = 'DIVERGED',
  /** The head ref and base ref are identical. */
  Identical = 'IDENTICAL'
}

/** Represents a 'connected' event on a given issue or pull request. */
type ConnectedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
  /** Issue or pull request that made the reference. */
  readonly source: ReferencedSubject;
  /** Issue or pull request which was connected. */
  readonly subject: ReferencedSubject;
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
type Contribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** A calendar of contributions made on GitHub by a user. */
type ContributionCalendar = {
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  readonly colors: ReadonlyArray<Scalars['String']['output']>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  readonly isHalloween: Scalars['Boolean']['output'];
  /** A list of the months of contributions in this calendar. */
  readonly months: ReadonlyArray<ContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  readonly totalContributions: Scalars['Int']['output'];
  /** A list of the weeks of contributions in this calendar. */
  readonly weeks: ReadonlyArray<ContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
type ContributionCalendarDay = {
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  readonly color: Scalars['String']['output'];
  /** How many contributions were made by the user on this day. */
  readonly contributionCount: Scalars['Int']['output'];
  /**
   * Indication of contributions, relative to other days. Can be used to indicate
   * which color to represent this day on a calendar.
   */
  readonly contributionLevel: ContributionLevel;
  /** The day this square represents. */
  readonly date: Scalars['Date']['output'];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  readonly weekday: Scalars['Int']['output'];
};

/** A month of contributions in a user's contribution graph. */
type ContributionCalendarMonth = {
  /** The date of the first day of this month. */
  readonly firstDay: Scalars['Date']['output'];
  /** The name of the month. */
  readonly name: Scalars['String']['output'];
  /** How many weeks started in this month. */
  readonly totalWeeks: Scalars['Int']['output'];
  /** The year the month occurred in. */
  readonly year: Scalars['Int']['output'];
};

/** A week of contributions in a user's contribution graph. */
type ContributionCalendarWeek = {
  /** The days of contributions in this week. */
  readonly contributionDays: ReadonlyArray<ContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  readonly firstDay: Scalars['Date']['output'];
};

/** Varying levels of contributions from none to many. */
enum ContributionLevel {
  /** Lowest 25% of days of contributions. */
  FirstQuartile = 'FIRST_QUARTILE',
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  FourthQuartile = 'FOURTH_QUARTILE',
  /** No contributions occurred. */
  None = 'NONE',
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  SecondQuartile = 'SECOND_QUARTILE',
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  ThirdQuartile = 'THIRD_QUARTILE'
}

/** Ordering options for contribution connections. */
type ContributionOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollection = {
  /** Commit contributions made by the user, grouped by repository. */
  readonly commitContributionsByRepository: ReadonlyArray<CommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  readonly contributionCalendar: ContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  readonly contributionYears: ReadonlyArray<Scalars['Int']['output']>;
  /** Determine if this collection's time span ends in the current month. */
  readonly doesEndInCurrentMonth: Scalars['Boolean']['output'];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  readonly earliestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;
  /** The ending date and time of this collection. */
  readonly endedAt: Scalars['DateTime']['output'];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  readonly firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  readonly firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  readonly firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  readonly hasActivityInThePast: Scalars['Boolean']['output'];
  /** Determine if there are any contributions in this collection. */
  readonly hasAnyContributions: Scalars['Boolean']['output'];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  readonly hasAnyRestrictedContributions: Scalars['Boolean']['output'];
  /** Whether or not the collector's time span is all within the same day. */
  readonly isSingleDay: Scalars['Boolean']['output'];
  /** A list of issues the user opened. */
  readonly issueContributions: CreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  readonly issueContributionsByRepository: ReadonlyArray<IssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  readonly joinedGitHubContribution?: Maybe<JoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  readonly latestRestrictedContributionDate?: Maybe<Scalars['Date']['output']>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  readonly mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  readonly mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  readonly popularIssueContribution?: Maybe<CreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  readonly popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  readonly pullRequestContributions: CreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  readonly pullRequestContributionsByRepository: ReadonlyArray<PullRequestContributionsByRepository>;
  /**
   * Pull request review contributions made by the user. Returns the most recently
   * submitted review for each PR reviewed by the user.
   */
  readonly pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  readonly pullRequestReviewContributionsByRepository: ReadonlyArray<PullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  readonly repositoryContributions: CreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  readonly restrictedContributionsCount: Scalars['Int']['output'];
  /** The beginning date and time of this collection. */
  readonly startedAt: Scalars['DateTime']['output'];
  /** How many commits were made by the user in this time span. */
  readonly totalCommitContributions: Scalars['Int']['output'];
  /** How many issues the user opened. */
  readonly totalIssueContributions: Scalars['Int']['output'];
  /** How many pull requests the user opened. */
  readonly totalPullRequestContributions: Scalars['Int']['output'];
  /** How many pull request reviews the user left. */
  readonly totalPullRequestReviewContributions: Scalars['Int']['output'];
  /** How many different repositories the user committed to. */
  readonly totalRepositoriesWithContributedCommits: Scalars['Int']['output'];
  /** How many different repositories the user opened issues in. */
  readonly totalRepositoriesWithContributedIssues: Scalars['Int']['output'];
  /** How many different repositories the user left pull request reviews in. */
  readonly totalRepositoriesWithContributedPullRequestReviews: Scalars['Int']['output'];
  /** How many different repositories the user opened pull requests in. */
  readonly totalRepositoriesWithContributedPullRequests: Scalars['Int']['output'];
  /** How many repositories the user created. */
  readonly totalRepositoryContributions: Scalars['Int']['output'];
  /** The user who made the contributions in this collection. */
  readonly user: User;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionCommitContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionIssueContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionIssueContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionPullRequestContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionPullRequestContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionPullRequestReviewContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionTotalIssueContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionTotalPullRequestContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
  excludePopular?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
type ContributionsCollectionTotalRepositoryContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
type ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to convert. */
  readonly projectCardId: Scalars['ID']['input'];
  /** The ID of the repository to create the issue in. */
  readonly repositoryId: Scalars['ID']['input'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
type ConvertProjectCardNoteToIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated ProjectCard. */
  readonly projectCard?: Maybe<ProjectCard>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
type ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to convert to draft */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ConvertPullRequestToDraft */
type ConvertPullRequestToDraftPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is now a draft. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
type ConvertToDraftEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** The HTTP path for this convert to draft event. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this convert to draft event. */
  readonly url: Scalars['URI']['output'];
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
type ConvertedNoteToIssueEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Project referenced by event. */
  readonly project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  readonly projectCard?: Maybe<ProjectCard>;
  /** Column name referenced by this project event. */
  readonly projectColumnName: Scalars['String']['output'];
};

/** Represents a 'converted_to_discussion' event on a given issue. */
type ConvertedToDiscussionEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The discussion that the issue was converted into. */
  readonly discussion?: Maybe<Discussion>;
  readonly id: Scalars['ID']['output'];
};

/** Autogenerated input type of CopyProjectV2 */
type CopyProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Include draft issues in the new project */
  readonly includeDraftIssues?: InputMaybe<Scalars['Boolean']['input']>;
  /** The owner ID of the new project. */
  readonly ownerId: Scalars['ID']['input'];
  /** The ID of the source Project to copy. */
  readonly projectId: Scalars['ID']['input'];
  /** The title of the project. */
  readonly title: Scalars['String']['input'];
};

/** Autogenerated return type of CopyProjectV2 */
type CopyProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The copied project. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of CreateAttributionInvitation */
type CreateAttributionInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the owner scoping the reattributable data. */
  readonly ownerId: Scalars['ID']['input'];
  /** The Node ID of the account owning the data to reattribute. */
  readonly sourceId: Scalars['ID']['input'];
  /** The Node ID of the account which may claim the data. */
  readonly targetId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateAttributionInvitation */
type CreateAttributionInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner scoping the reattributable data. */
  readonly owner?: Maybe<Organization>;
  /** The account owning the data to reattribute. */
  readonly source?: Maybe<Claimable>;
  /** The account which may claim the data. */
  readonly target?: Maybe<Claimable>;
};

/** Autogenerated input type of CreateBranchProtectionRule */
type CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  readonly allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  readonly allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  readonly blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  readonly bypassForcePushActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  readonly bypassPullRequestActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  readonly dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins overwrite branch protection. */
  readonly isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  readonly lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  readonly lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  readonly pattern: Scalars['String']['input'];
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  readonly pushActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  readonly repositoryId: Scalars['ID']['input'];
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  readonly requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  readonly requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  readonly requiredDeploymentEnvironments?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusCheckContexts?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** The list of required status checks */
  readonly requiredStatusChecks?: InputMaybe<ReadonlyArray<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  readonly requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  readonly requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  readonly requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  readonly requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  readonly requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  readonly requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  readonly requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  readonly requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  readonly restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  readonly restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  readonly reviewDismissalActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Autogenerated return type of CreateBranchProtectionRule */
type CreateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckRun */
type CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  readonly actions?: InputMaybe<ReadonlyArray<CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  readonly completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  readonly conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  readonly detailsUrl?: InputMaybe<Scalars['URI']['input']>;
  /** A reference for the run on the integrator's system. */
  readonly externalId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  readonly headSha: Scalars['GitObjectID']['input'];
  /** The name of the check. */
  readonly name: Scalars['String']['input'];
  /** Descriptive details about the run. */
  readonly output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  readonly startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  readonly status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun */
type CreateCheckRunPayload = {
  /** The newly created check run. */
  readonly checkRun?: Maybe<CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCheckSuite */
type CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  readonly headSha: Scalars['GitObjectID']['input'];
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateCheckSuite */
type CreateCheckSuitePayload = {
  /** The newly created check suite. */
  readonly checkSuite?: Maybe<CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateCommitOnBranch */
type CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  readonly branch: CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  readonly expectedHeadOid: Scalars['GitObjectID']['input'];
  /** A description of changes to files in this commit. */
  readonly fileChanges?: InputMaybe<FileChanges>;
  /** The commit message the be included with the commit. */
  readonly message: CommitMessage;
};

/** Autogenerated return type of CreateCommitOnBranch */
type CreateCommitOnBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new commit. */
  readonly commit?: Maybe<Commit>;
  /** The ref which has been updated to point to the new commit. */
  readonly ref?: Maybe<Ref>;
};

/** Autogenerated input type of CreateDeployment */
type CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  readonly autoMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Short description of the deployment. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the target deployment environment. */
  readonly environment?: InputMaybe<Scalars['String']['input']>;
  /** JSON payload with extra information about the deployment. */
  readonly payload?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the ref to be deployed. */
  readonly refId: Scalars['ID']['input'];
  /** The node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  readonly requiredContexts?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Specifies a task to execute. */
  readonly task?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateDeployment */
type CreateDeploymentPayload = {
  /** True if the default branch has been auto-merged into the deployment ref. */
  readonly autoMerged?: Maybe<Scalars['Boolean']['output']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new deployment. */
  readonly deployment?: Maybe<Deployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
type CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  readonly autoInactive?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the deployment. */
  readonly deploymentId: Scalars['ID']['input'];
  /** A short description of the status. Maximum length of 140 characters. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  readonly environment?: InputMaybe<Scalars['String']['input']>;
  /** Sets the URL for accessing your environment. */
  readonly environmentUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  readonly logUrl?: InputMaybe<Scalars['String']['input']>;
  /** The state of the deployment. */
  readonly state: DeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus */
type CreateDeploymentStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new deployment status. */
  readonly deploymentStatus?: Maybe<DeploymentStatus>;
};

/** Autogenerated input type of CreateDiscussion */
type CreateDiscussionInput = {
  /** The body of the discussion. */
  readonly body: Scalars['String']['input'];
  /** The id of the discussion category to associate with this discussion. */
  readonly categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the repository on which to create the discussion. */
  readonly repositoryId: Scalars['ID']['input'];
  /** The title of the discussion. */
  readonly title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateDiscussion */
type CreateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was just created. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
type CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  readonly adminLogins: ReadonlyArray<Scalars['String']['input']>;
  /** The email used for sending billing receipts. */
  readonly billingEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise owning the new organization. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of the new organization. */
  readonly login: Scalars['String']['input'];
  /** The profile name of the new organization. */
  readonly profileName: Scalars['String']['input'];
};

/** Autogenerated return type of CreateEnterpriseOrganization */
type CreateEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise that owns the created organization. */
  readonly enterprise?: Maybe<Enterprise>;
  /** The organization that was created. */
  readonly organization?: Maybe<Organization>;
};

/** Autogenerated input type of CreateEnvironment */
type CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the environment. */
  readonly name: Scalars['String']['input'];
  /** The node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateEnvironment */
type CreateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new or existing environment. */
  readonly environment?: Maybe<Environment>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
type CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  readonly allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  readonly isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  readonly ownerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateIpAllowListEntry */
type CreateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was created. */
  readonly ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
type CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  readonly assigneeIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  readonly issueTemplate?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this issue. */
  readonly labelIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  readonly milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  readonly projectIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /** The title for the issue. */
  readonly title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateIssue */
type CreateIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new issue. */
  readonly issue?: Maybe<Issue>;
};

/** Autogenerated input type of CreateLabel */
type CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  readonly color: Scalars['String']['input'];
  /** A brief description of the label, such as its purpose. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the label. */
  readonly name: Scalars['String']['input'];
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateLabel */
type CreateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new label. */
  readonly label?: Maybe<Label>;
};

/** Autogenerated input type of CreateLinkedBranch */
type CreateLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to link to. */
  readonly issueId: Scalars['ID']['input'];
  /** The name of the new branch. Defaults to issue number and title. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The commit SHA to base the new branch on. */
  readonly oid: Scalars['GitObjectID']['input'];
  /** ID of the repository to create the branch in. Defaults to the issue repository. */
  readonly repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateLinkedBranch */
type CreateLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new branch issue reference. */
  readonly linkedBranch?: Maybe<LinkedBranch>;
};

/** Autogenerated input type of CreateMigrationSource */
type CreateMigrationSourceInput = {
  /** The migration source access token. */
  readonly accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  readonly githubPat?: InputMaybe<Scalars['String']['input']>;
  /** The migration source name. */
  readonly name: Scalars['String']['input'];
  /** The ID of the organization that will own the migration source. */
  readonly ownerId: Scalars['ID']['input'];
  /** The migration source type. */
  readonly type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateMigrationSource */
type CreateMigrationSourcePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The created migration source. */
  readonly migrationSource?: Maybe<MigrationSource>;
};

/** Autogenerated input type of CreateProject */
type CreateProjectInput = {
  /** The description of project. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  readonly name: Scalars['String']['input'];
  /** The owner ID to create the project under. */
  readonly ownerId: Scalars['ID']['input'];
  /** A list of repository IDs to create as linked repositories for the project */
  readonly repositoryIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The name of the GitHub-provided template. */
  readonly template?: InputMaybe<ProjectTemplate>;
};

/** Autogenerated return type of CreateProject */
type CreateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new project. */
  readonly project?: Maybe<Project>;
};

/** Autogenerated input type of CreateProjectV2Field */
type CreateProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The data type of the field. */
  readonly dataType: ProjectV2CustomFieldType;
  /** The name of the field. */
  readonly name: Scalars['String']['input'];
  /** The ID of the Project to create the field in. */
  readonly projectId: Scalars['ID']['input'];
  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */
  readonly singleSelectOptions?: InputMaybe<ReadonlyArray<ProjectV2SingleSelectFieldOptionInput>>;
};

/** Autogenerated return type of CreateProjectV2Field */
type CreateProjectV2FieldPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new field. */
  readonly projectV2Field?: Maybe<ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of CreateProjectV2 */
type CreateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The owner ID to create the project under. */
  readonly ownerId: Scalars['ID']['input'];
  /** The repository to link the project to. */
  readonly repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** The team to link the project to. The team will be granted read permissions. */
  readonly teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The title of the project. */
  readonly title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateProjectV2 */
type CreateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new project. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of CreatePullRequest */
type CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  readonly baseRefName: Scalars['String']['input'];
  /** The contents of the pull request. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether this pull request should be a draft. */
  readonly draft?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  readonly headRefName: Scalars['String']['input'];
  /** The Node ID of the head repository. */
  readonly headRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** Indicates whether maintainers can modify the pull request. */
  readonly maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /** The title of the pull request. */
  readonly title: Scalars['String']['input'];
};

/** Autogenerated return type of CreatePullRequest */
type CreatePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new pull request. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of CreateRef */
type CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  readonly name: Scalars['String']['input'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  readonly oid: Scalars['GitObjectID']['input'];
  /** The Node ID of the Repository to create the Ref in. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateRef */
type CreateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created ref. */
  readonly ref?: Maybe<Ref>;
};

/** Autogenerated input type of CreateRepository */
type CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  readonly hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  readonly hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. */
  readonly homepageUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The name of the new repository. */
  readonly name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  readonly ownerId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  readonly teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  readonly template?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the repository's visibility level. */
  readonly visibility: RepositoryVisibility;
};

/** Autogenerated return type of CreateRepository */
type CreateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of CreateRepositoryRuleset */
type CreateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  readonly bypassActors?: InputMaybe<ReadonlyArray<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The set of conditions for this ruleset */
  readonly conditions: RepositoryRuleConditionsInput;
  /** The enforcement level for this ruleset */
  readonly enforcement: RuleEnforcement;
  /** The name of the ruleset. */
  readonly name: Scalars['String']['input'];
  /** The list of rules for this ruleset */
  readonly rules?: InputMaybe<ReadonlyArray<RepositoryRuleInput>>;
  /** The global relay id of the source in which a new ruleset should be created in. */
  readonly sourceId: Scalars['ID']['input'];
  /** The target of the ruleset. */
  readonly target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated return type of CreateRepositoryRuleset */
type CreateRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created Ruleset. */
  readonly ruleset?: Maybe<RepositoryRuleset>;
};

/** Autogenerated input type of CreateSponsorsListing */
type CreateSponsorsListingInput = {
  /**
   * The country or region where the sponsorable's bank account is located.
   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
   */
  readonly billingCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The email address we should use to contact you about the GitHub Sponsors
   * profile being created. This will not be shared publicly. Must be a verified
   * email address already on your GitHub account. Only relevant when the
   * sponsorable is yourself. Defaults to your primary email address on file if omitted.
   */
  readonly contactEmail?: InputMaybe<Scalars['String']['input']>;
  /**
   * The username of the supported fiscal host's GitHub organization, if you want
   * to receive sponsorship payouts through a fiscal host rather than directly to a
   * bank account. For example, 'Open-Source-Collective' for Open Source Collective
   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
   * for more information.
   */
  readonly fiscalHostLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The URL for your profile page on the fiscal host's website, e.g.,
   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.
   * Required if fiscalHostLogin is specified.
   */
  readonly fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * Provide an introduction to serve as the main focus that appears on your GitHub
   * Sponsors profile. It's a great opportunity to help potential sponsors learn
   * more about you, your work, and why their sponsorship is important to you.
   * GitHub-flavored Markdown is supported.
   */
  readonly fullDescription?: InputMaybe<Scalars['String']['input']>;
  /**
   * The country or region where the sponsorable resides. This is for tax purposes.
   * Required if the sponsorable is yourself, ignored when sponsorableLogin
   * specifies an organization.
   */
  readonly residenceCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /**
   * The username of the organization to create a GitHub Sponsors profile for, if
   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated
   * user if omitted.
   */
  readonly sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSponsorsListing */
type CreateSponsorsListingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new GitHub Sponsors profile. */
  readonly sponsorsListing?: Maybe<SponsorsListing>;
};

/** Autogenerated input type of CreateSponsorsTier */
type CreateSponsorsTierInput = {
  /** The value of the new tier in US dollars. Valid values: 1-12000. */
  readonly amount: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */
  readonly description: Scalars['String']['input'];
  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */
  readonly isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether to make the tier available immediately for sponsors to choose.
   * Defaults to creating a draft tier that will not be publicly visible.
   */
  readonly publish?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Optional ID of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization.
   */
  readonly repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Optional name of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization. Necessary if
   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
   */
  readonly repositoryName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Optional login of the organization owner of the private repository that
   * sponsors at this tier should gain read-only access to. Necessary if
   * repositoryName is given. Will be ignored if repositoryId is given.
   */
  readonly repositoryOwnerLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableLogin is not given.
   */
  readonly sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableId is not given.
   */
  readonly sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** Optional message new sponsors at this tier will receive. */
  readonly welcomeMessage?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSponsorsTier */
type CreateSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new tier. */
  readonly sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of CreateSponsorship */
type CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  readonly amount?: InputMaybe<Scalars['Int']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  readonly isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  readonly privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  readonly receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  readonly sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  readonly sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  readonly tierId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateSponsorship */
type CreateSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The sponsorship that was started. */
  readonly sponsorship?: Maybe<Sponsorship>;
};

/** Autogenerated input type of CreateSponsorships */
type CreateSponsorshipsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorables. Public visibility still does not reveal the dollar value of
   * the sponsorship.
   */
  readonly privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorables. */
  readonly receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */
  readonly sponsorLogin: Scalars['String']['input'];
  /** The list of maintainers to sponsor and for how much apiece. */
  readonly sponsorships: ReadonlyArray<BulkSponsorship>;
};

/** Autogenerated return type of CreateSponsorships */
type CreateSponsorshipsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The users and organizations who received a sponsorship. */
  readonly sponsorables?: Maybe<ReadonlyArray<Sponsorable>>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
type CreateTeamDiscussionCommentInput = {
  /**
   * The content of the comment. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the discussion to which the comment belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `discussionId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  readonly discussionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of CreateTeamDiscussionComment */
type CreateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The new comment.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly teamDiscussionComment?: Maybe<TeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
type CreateTeamDiscussionInput = {
  /**
   * The content of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `private` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  readonly private?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the team to which the discussion belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `teamId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  readonly teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The title of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `title` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateTeamDiscussion */
type CreateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * The new discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly teamDiscussion?: Maybe<TeamDiscussion>;
};

/** Represents the contribution a user made by committing to a repository. */
type CreatedCommitContribution = Contribution & {
  /** How many commits were made on this day to this repository by the user. */
  readonly commitCount: Scalars['Int']['output'];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The repository the user made a commit in. */
  readonly repository: Repository;
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** The connection type for CreatedCommitContribution. */
type CreatedCommitContributionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CreatedCommitContributionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
type CreatedIssueContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** The issue that was opened. */
  readonly issue: Issue;
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** The connection type for CreatedIssueContribution. */
type CreatedIssueContributionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CreatedIssueContributionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
type CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
type CreatedPullRequestContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The pull request that was opened. */
  readonly pullRequest: PullRequest;
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** The connection type for CreatedPullRequestContribution. */
type CreatedPullRequestContributionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CreatedPullRequestContributionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
type CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
type CreatedPullRequestReviewContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The pull request the user reviewed. */
  readonly pullRequest: PullRequest;
  /** The review the user left on the pull request. */
  readonly pullRequestReview: PullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  readonly repository: Repository;
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** The connection type for CreatedPullRequestReviewContribution. */
type CreatedPullRequestReviewContributionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CreatedPullRequestReviewContributionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
type CreatedRepositoryContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The repository that was created. */
  readonly repository: Repository;
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** The connection type for CreatedRepositoryContribution. */
type CreatedRepositoryContributionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type CreatedRepositoryContributionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
type CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
type CrossReferencedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
  /** Identifies when the reference was made. */
  readonly referencedAt: Scalars['DateTime']['output'];
  /** The HTTP path for this pull request. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Issue or pull request that made the reference. */
  readonly source: ReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  readonly target: ReferencedSubject;
  /** The HTTP URL for this pull request. */
  readonly url: Scalars['URI']['output'];
  /** Checks if the target will be closed when the source is merged. */
  readonly willCloseTarget: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeclineTopicSuggestion */
type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the suggested topic. */
  readonly name: Scalars['String']['input'];
  /** The reason why the suggested topic is declined. */
  readonly reason: TopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeclineTopicSuggestion */
type DeclineTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The declined topic. */
  readonly topic?: Maybe<Topic>;
};

/** The possible base permissions for repositories. */
enum DefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = 'ADMIN',
  /** No access */
  None = 'NONE',
  /** Can read repos by default */
  Read = 'READ',
  /** Can read and write repos by default */
  Write = 'WRITE'
}

/** Entities that can be deleted. */
type Deletable = {
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
type DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  readonly branchProtectionRuleId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteBranchProtectionRule */
type DeleteBranchProtectionRulePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteDeployment */
type DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the deployment to be deleted. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDeployment */
type DeleteDeploymentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteDiscussionComment */
type DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node id of the discussion comment to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDiscussionComment */
type DeleteDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion comment that was just deleted. */
  readonly comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of DeleteDiscussion */
type DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the discussion to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteDiscussion */
type DeleteDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was just deleted. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of DeleteEnvironment */
type DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the environment to be deleted. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteEnvironment */
type DeleteEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
type DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to delete. */
  readonly ipAllowListEntryId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIpAllowListEntry */
type DeleteIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was deleted. */
  readonly ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
type DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIssueComment */
type DeleteIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteIssue */
type DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to delete. */
  readonly issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteIssue */
type DeleteIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the issue belonged to */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of DeleteLabel */
type DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be deleted. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteLabel */
type DeleteLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteLinkedBranch */
type DeleteLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the linked branch */
  readonly linkedBranchId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteLinkedBranch */
type DeleteLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue the linked branch was unlinked from. */
  readonly issue?: Maybe<Issue>;
};

/** Autogenerated input type of DeletePackageVersion */
type DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the package version to be deleted. */
  readonly packageVersionId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePackageVersion */
type DeletePackageVersionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Whether or not the operation succeeded. */
  readonly success?: Maybe<Scalars['Boolean']['output']>;
};

/** Autogenerated input type of DeleteProjectCard */
type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  readonly cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteProjectCard */
type DeleteProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The column the deleted card was in. */
  readonly column?: Maybe<ProjectColumn>;
  /** The deleted card ID. */
  readonly deletedCardId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of DeleteProjectColumn */
type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to delete. */
  readonly columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectColumn */
type DeleteProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted column ID. */
  readonly deletedColumnId?: Maybe<Scalars['ID']['output']>;
  /** The project the deleted column was in. */
  readonly project?: Maybe<Project>;
};

/** Autogenerated input type of DeleteProject */
type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProject */
type DeleteProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository or organization the project was removed from. */
  readonly owner?: Maybe<ProjectOwner>;
};

/** Autogenerated input type of DeleteProjectV2Field */
type DeleteProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to delete. */
  readonly fieldId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Field */
type DeleteProjectV2FieldPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted field. */
  readonly projectV2Field?: Maybe<ProjectV2FieldConfiguration>;
};

/** Autogenerated input type of DeleteProjectV2 */
type DeleteProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to delete. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2Item */
type DeleteProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be removed. */
  readonly itemId: Scalars['ID']['input'];
  /** The ID of the Project from which the item should be removed. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Item */
type DeleteProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ID of the deleted item. */
  readonly deletedItemId?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated return type of DeleteProjectV2 */
type DeleteProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted Project. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeleteProjectV2Workflow */
type DeleteProjectV2WorkflowInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the workflow to be removed. */
  readonly workflowId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteProjectV2Workflow */
type DeleteProjectV2WorkflowPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The ID of the deleted workflow. */
  readonly deletedWorkflowId?: Maybe<Scalars['ID']['output']>;
  /** The project the deleted workflow was in. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
type DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePullRequestReviewComment */
type DeletePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request review the deleted comment belonged to. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
  /** The deleted pull request review comment. */
  readonly pullRequestReviewComment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of DeletePullRequestReview */
type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to delete. */
  readonly pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePullRequestReview */
type DeletePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The deleted pull request review. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
type DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be deleted. */
  readonly refId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRef */
type DeleteRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteRepositoryRuleset */
type DeleteRepositoryRulesetInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be deleted. */
  readonly repositoryRulesetId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteRepositoryRuleset */
type DeleteRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
type DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
type DeleteTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
type DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The discussion ID to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTeamDiscussion */
type DeleteTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteVerifiableDomain */
type DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to delete. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteVerifiableDomain */
type DeleteVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owning account from which the domain was deleted. */
  readonly owner?: Maybe<VerifiableDomainOwner>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
type DemilestonedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  readonly milestoneTitle: Scalars['String']['output'];
  /** Object referenced by event. */
  readonly subject: MilestoneItem;
};

/** A Dependabot Update for a dependency in a repository */
type DependabotUpdate = RepositoryNode & {
  /** The error from a dependency update */
  readonly error?: Maybe<DependabotUpdateError>;
  /** The associated pull request */
  readonly pullRequest?: Maybe<PullRequest>;
  /** The repository associated with this node. */
  readonly repository: Repository;
};

/** An error produced from a Dependabot Update */
type DependabotUpdateError = {
  /** The body of the error */
  readonly body: Scalars['String']['output'];
  /** The error code */
  readonly errorType: Scalars['String']['output'];
  /** The title of the error */
  readonly title: Scalars['String']['output'];
};

/** A dependency manifest entry */
type DependencyGraphDependency = {
  /** Does the dependency itself have dependencies? */
  readonly hasDependencies: Scalars['Boolean']['output'];
  /**
   * The original name of the package, as it appears in the manifest.
   * @deprecated `packageLabel` will be removed. Use normalized `packageName` field instead. Removal on 2022-10-01 UTC.
   */
  readonly packageLabel: Scalars['String']['output'];
  /** The dependency package manager */
  readonly packageManager?: Maybe<Scalars['String']['output']>;
  /** The name of the package in the canonical form used by the package manager. */
  readonly packageName: Scalars['String']['output'];
  /** The repository containing the package */
  readonly repository?: Maybe<Repository>;
  /** The dependency version requirements */
  readonly requirements: Scalars['String']['output'];
};

/** The connection type for DependencyGraphDependency. */
type DependencyGraphDependencyConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DependencyGraphDependencyEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DependencyGraphDependency>;
};

/** The possible ecosystems of a dependency graph package. */
enum DependencyGraphEcosystem {
  /** GitHub Actions */
  Actions = 'ACTIONS',
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Go modules */
  Go = 'GO',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Dart packages hosted at pub.dev */
  Pub = 'PUB',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS',
  /** Rust crates */
  Rust = 'RUST',
  /** Swift packages */
  Swift = 'SWIFT'
}

/** Dependency manifest for a repository */
type DependencyGraphManifest = Node & {
  /** Path to view the manifest file blob */
  readonly blobPath: Scalars['String']['output'];
  /** A list of manifest dependencies */
  readonly dependencies?: Maybe<DependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  readonly dependenciesCount?: Maybe<Scalars['Int']['output']>;
  /** Is the manifest too big to parse? */
  readonly exceedsMaxSize: Scalars['Boolean']['output'];
  /** Fully qualified manifest filename */
  readonly filename: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** Were we able to parse the manifest? */
  readonly parseable: Scalars['Boolean']['output'];
  /** The repository containing the manifest */
  readonly repository: Repository;
};


/** Dependency manifest for a repository */
type DependencyGraphManifestDependenciesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DependencyGraphManifest. */
type DependencyGraphManifestConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DependencyGraphManifestEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DependencyGraphManifest>;
};

/** A repository deploy key. */
type DeployKey = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The deploy key. */
  readonly key: Scalars['String']['output'];
  /** Whether or not the deploy key is read only. */
  readonly readOnly: Scalars['Boolean']['output'];
  /** The deploy key title. */
  readonly title: Scalars['String']['output'];
  /** Whether or not the deploy key has been verified. */
  readonly verified: Scalars['Boolean']['output'];
};

/** The connection type for DeployKey. */
type DeployKeyConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeployKeyEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DeployKey>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeployKeyEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
type DeployedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The deployment associated with the 'deployed' event. */
  readonly deployment: Deployment;
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** The ref associated with the 'deployed' event. */
  readonly ref?: Maybe<Ref>;
};

/** Represents triggered deployment instance. */
type Deployment = Node & {
  /** Identifies the commit sha of the deployment. */
  readonly commit?: Maybe<Commit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  readonly commitOid: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who triggered the deployment. */
  readonly creator: Actor;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The deployment description. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The latest environment to which this deployment was made. */
  readonly environment?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The latest environment to which this deployment was made. */
  readonly latestEnvironment?: Maybe<Scalars['String']['output']>;
  /** The latest status of this deployment. */
  readonly latestStatus?: Maybe<DeploymentStatus>;
  /** The original environment to which this deployment was made. */
  readonly originalEnvironment?: Maybe<Scalars['String']['output']>;
  /** Extra information that a deployment system might need. */
  readonly payload?: Maybe<Scalars['String']['output']>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  readonly ref?: Maybe<Ref>;
  /** Identifies the repository associated with the deployment. */
  readonly repository: Repository;
  /** The current state of the deployment. */
  readonly state?: Maybe<DeploymentState>;
  /** A list of statuses associated with the deployment. */
  readonly statuses?: Maybe<DeploymentStatusConnection>;
  /** The deployment task. */
  readonly task?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** Represents triggered deployment instance. */
type DeploymentStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Deployment. */
type DeploymentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeploymentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Deployment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeploymentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Deployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
type DeploymentEnvironmentChangedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The deployment status that updated the deployment environment. */
  readonly deploymentStatus: DeploymentStatus;
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
};

/** Ordering options for deployment connections */
type DeploymentOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order deployments by. */
  readonly field: DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
enum DeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = 'CREATED_AT'
}

/** A protection rule. */
type DeploymentProtectionRule = {
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The teams or users that can review the deployment */
  readonly reviewers: DeploymentReviewerConnection;
  /** The timeout in minutes for this protection rule. */
  readonly timeout: Scalars['Int']['output'];
  /** The type of protection rule. */
  readonly type: DeploymentProtectionRuleType;
};


/** A protection rule. */
type DeploymentProtectionRuleReviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentProtectionRule. */
type DeploymentProtectionRuleConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeploymentProtectionRuleEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DeploymentProtectionRule>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeploymentProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DeploymentProtectionRule>;
};

/** The possible protection rule types. */
enum DeploymentProtectionRuleType {
  /** Required reviewers */
  RequiredReviewers = 'REQUIRED_REVIEWERS',
  /** Wait timer */
  WaitTimer = 'WAIT_TIMER'
}

/** A request to deploy a workflow run to an environment. */
type DeploymentRequest = {
  /** Whether or not the current user can approve the deployment */
  readonly currentUserCanApprove: Scalars['Boolean']['output'];
  /** The target environment of the deployment */
  readonly environment: Environment;
  /** The teams or users that can review the deployment */
  readonly reviewers: DeploymentReviewerConnection;
  /** The wait timer in minutes configured in the environment */
  readonly waitTimer: Scalars['Int']['output'];
  /** The wait timer in minutes configured in the environment */
  readonly waitTimerStartedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A request to deploy a workflow run to an environment. */
type DeploymentRequestReviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentRequest. */
type DeploymentRequestConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeploymentRequestEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DeploymentRequest>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeploymentRequestEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DeploymentRequest>;
};

/** A deployment review. */
type DeploymentReview = Node & {
  /** The comment the user left. */
  readonly comment: Scalars['String']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The environments approved or rejected */
  readonly environments: EnvironmentConnection;
  readonly id: Scalars['ID']['output'];
  /** The decision of the user. */
  readonly state: DeploymentReviewState;
  /** The user that reviewed the deployment. */
  readonly user: User;
};


/** A deployment review. */
type DeploymentReviewEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DeploymentReview. */
type DeploymentReviewConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeploymentReviewEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DeploymentReview>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeploymentReviewEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DeploymentReview>;
};

/** The possible states for a deployment review. */
enum DeploymentReviewState {
  /** The deployment was approved. */
  Approved = 'APPROVED',
  /** The deployment was rejected. */
  Rejected = 'REJECTED'
}

/** Users and teams. */
type DeploymentReviewer = Team | User;

/** The connection type for DeploymentReviewer. */
type DeploymentReviewerConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeploymentReviewerEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DeploymentReviewer>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeploymentReviewerEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DeploymentReviewer>;
};

/** The possible states in which a deployment can be. */
enum DeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = 'ABANDONED',
  /** The deployment is currently active. */
  Active = 'ACTIVE',
  /** An inactive transient deployment. */
  Destroyed = 'DESTROYED',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment has queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment is waiting. */
  Waiting = 'WAITING'
}

/** Describes the status of a given deployment attempt. */
type DeploymentStatus = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who triggered the deployment. */
  readonly creator: Actor;
  /** Identifies the deployment associated with status. */
  readonly deployment: Deployment;
  /** Identifies the description of the deployment. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  readonly environment?: Maybe<Scalars['String']['output']>;
  /** Identifies the environment URL of the deployment. */
  readonly environmentUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the log URL of the deployment. */
  readonly logUrl?: Maybe<Scalars['URI']['output']>;
  /** Identifies the current state of the deployment. */
  readonly state: DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for DeploymentStatus. */
type DeploymentStatusConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DeploymentStatusEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DeploymentStatus>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DeploymentStatusEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DeploymentStatus>;
};

/** The possible states for a deployment status. */
enum DeploymentStatusState {
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment is queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment is waiting. */
  Waiting = 'WAITING'
}

/** Autogenerated input type of DequeuePullRequest */
type DequeuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the pull request to be dequeued. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of DequeuePullRequest */
type DequeuePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The merge queue entry of the dequeued pull request. */
  readonly mergeQueueEntry?: Maybe<MergeQueueEntry>;
};

/** The possible sides of a diff. */
enum DiffSide {
  /** The left side of the diff. */
  Left = 'LEFT',
  /** The right side of the diff. */
  Right = 'RIGHT'
}

/** Autogenerated input type of DisablePullRequestAutoMerge */
type DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to disable auto merge on. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of DisablePullRequestAutoMerge */
type DisablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request auto merge was disabled on. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'disconnected' event on a given issue or pull request. */
type DisconnectedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
  /** Issue or pull request from which the issue was disconnected. */
  readonly source: ReferencedSubject;
  /** Issue or pull request which was disconnected. */
  readonly subject: ReferencedSubject;
};

/** A discussion in a repository. */
type Discussion = Closable & Comment & Deletable & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & Updatable & Votable & {
  /** Reason that the conversation was locked. */
  readonly activeLockReason?: Maybe<LockReason>;
  /** The comment chosen as this discussion's answer, if any. */
  readonly answer?: Maybe<DiscussionComment>;
  /** The time when a user chose this discussion's answer, if answered. */
  readonly answerChosenAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who chose this discussion's answer, if answered. */
  readonly answerChosenBy?: Maybe<Actor>;
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The main text of the discussion post. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** The category for this discussion. */
  readonly category: DiscussionCategory;
  /** Indicates if the object is closed (definition of closed may depend on type) */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The replies to the discussion. */
  readonly comments: DiscussionCommentConnection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** A list of labels associated with the object. */
  readonly labels?: Maybe<LabelConnection>;
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** `true` if the object is locked */
  readonly locked: Scalars['Boolean']['output'];
  /** The number identifying this discussion within the repository. */
  readonly number: Scalars['Int']['output'];
  /** The poll associated with this discussion, if one exists. */
  readonly poll?: Maybe<DiscussionPoll>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The path for this discussion. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the reason for the discussion's state. */
  readonly stateReason?: Maybe<DiscussionStateReason>;
  /** The title of this discussion. */
  readonly title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** Number of upvotes that this subject has received. */
  readonly upvoteCount: Scalars['Int']['output'];
  /** The URL for this discussion. */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  readonly viewerCanUpvote: Scalars['Boolean']['output'];
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  readonly viewerHasUpvoted: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
};


/** A discussion in a repository. */
type DiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A discussion in a repository. */
type DiscussionLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};


/** A discussion in a repository. */
type DiscussionReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A discussion in a repository. */
type DiscussionUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A category for discussions in a repository. */
type DiscussionCategory = Node & RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** A description of this category. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** An emoji representing this category. */
  readonly emoji: Scalars['String']['output'];
  /** This category's emoji rendered as HTML. */
  readonly emojiHTML: Scalars['HTML']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */
  readonly isAnswerable: Scalars['Boolean']['output'];
  /** The name of this category. */
  readonly name: Scalars['String']['output'];
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The slug of this category. */
  readonly slug: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for DiscussionCategory. */
type DiscussionCategoryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DiscussionCategoryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DiscussionCategory>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DiscussionCategoryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DiscussionCategory>;
};

/** The possible reasons for closing a discussion. */
enum DiscussionCloseReason {
  /** The discussion is a duplicate of another */
  Duplicate = 'DUPLICATE',
  /** The discussion is no longer relevant */
  Outdated = 'OUTDATED',
  /** The discussion has been resolved */
  Resolved = 'RESOLVED'
}

/** A comment on a discussion. */
type DiscussionComment = Comment & Deletable & Minimizable & Node & Reactable & Updatable & UpdatableComment & Votable & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The time when this replied-to comment was deleted */
  readonly deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The discussion this comment was created in */
  readonly discussion?: Maybe<Discussion>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** Has this comment been chosen as the answer of its discussion? */
  readonly isAnswer: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  readonly isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  readonly minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The threaded replies to this comment. */
  readonly replies: DiscussionCommentConnection;
  /** The discussion comment this comment is a reply to */
  readonly replyTo?: Maybe<DiscussionComment>;
  /** The path for this discussion comment. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** Number of upvotes that this subject has received. */
  readonly upvoteCount: Scalars['Int']['output'];
  /** The URL for this discussion comment. */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Can the current user mark this comment as an answer? */
  readonly viewerCanMarkAsAnswer: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  readonly viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Can the current user unmark this comment as an answer? */
  readonly viewerCanUnmarkAsAnswer: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  readonly viewerCanUpvote: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  readonly viewerHasUpvoted: Scalars['Boolean']['output'];
};


/** A comment on a discussion. */
type DiscussionCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A comment on a discussion. */
type DiscussionCommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A comment on a discussion. */
type DiscussionCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for DiscussionComment. */
type DiscussionCommentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DiscussionCommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DiscussionComment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DiscussionComment>;
};

/** The connection type for Discussion. */
type DiscussionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DiscussionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Discussion>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DiscussionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Discussion>;
};

/** Ways in which lists of discussions can be ordered upon return. */
type DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  readonly direction: OrderDirection;
  /** The field by which to order discussions. */
  readonly field: DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
enum DiscussionOrderField {
  /** Order discussions by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order discussions by most recent modification time. */
  UpdatedAt = 'UPDATED_AT'
}

/** A poll for a discussion. */
type DiscussionPoll = Node & {
  /** The discussion that this poll belongs to. */
  readonly discussion?: Maybe<Discussion>;
  readonly id: Scalars['ID']['output'];
  /** The options for this poll. */
  readonly options?: Maybe<DiscussionPollOptionConnection>;
  /** The question that is being asked by this poll. */
  readonly question: Scalars['String']['output'];
  /** The total number of votes that have been cast for this poll. */
  readonly totalVoteCount: Scalars['Int']['output'];
  /** Indicates if the viewer has permission to vote in this poll. */
  readonly viewerCanVote: Scalars['Boolean']['output'];
  /** Indicates if the viewer has voted for any option in this poll. */
  readonly viewerHasVoted: Scalars['Boolean']['output'];
};


/** A poll for a discussion. */
type DiscussionPollOptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionPollOptionOrder>;
};

/** An option for a discussion poll. */
type DiscussionPollOption = Node & {
  readonly id: Scalars['ID']['output'];
  /** The text for this option. */
  readonly option: Scalars['String']['output'];
  /** The discussion poll that this option belongs to. */
  readonly poll?: Maybe<DiscussionPoll>;
  /** The total number of votes that have been cast for this option. */
  readonly totalVoteCount: Scalars['Int']['output'];
  /** Indicates if the viewer has voted for this option in the poll. */
  readonly viewerHasVoted: Scalars['Boolean']['output'];
};

/** The connection type for DiscussionPollOption. */
type DiscussionPollOptionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<DiscussionPollOptionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<DiscussionPollOption>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type DiscussionPollOptionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<DiscussionPollOption>;
};

/** Ordering options for discussion poll option connections. */
type DiscussionPollOptionOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order poll options by. */
  readonly field: DiscussionPollOptionOrderField;
};

/** Properties by which discussion poll option connections can be ordered. */
enum DiscussionPollOptionOrderField {
  /** Order poll options by the order that the poll author specified when creating the poll. */
  AuthoredOrder = 'AUTHORED_ORDER',
  /** Order poll options by the number of votes it has. */
  VoteCount = 'VOTE_COUNT'
}

/** The possible states of a discussion. */
enum DiscussionState {
  /** A discussion that has been closed */
  Closed = 'CLOSED',
  /** A discussion that is open */
  Open = 'OPEN'
}

/** The possible state reasons of a discussion. */
enum DiscussionStateReason {
  /** The discussion is a duplicate of another */
  Duplicate = 'DUPLICATE',
  /** The discussion is no longer relevant */
  Outdated = 'OUTDATED',
  /** The discussion was reopened */
  Reopened = 'REOPENED',
  /** The discussion has been resolved */
  Resolved = 'RESOLVED'
}

/** Autogenerated input type of DismissPullRequestReview */
type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request review dismissal message. */
  readonly message: Scalars['String']['input'];
  /** The Node ID of the pull request review to modify. */
  readonly pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of DismissPullRequestReview */
type DismissPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The dismissed pull request review. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
};

/** The possible reasons that a Dependabot alert was dismissed. */
enum DismissReason {
  /** A fix has already been started */
  FixStarted = 'FIX_STARTED',
  /** This alert is inaccurate or incorrect */
  Inaccurate = 'INACCURATE',
  /** Vulnerable code is not actually used */
  NotUsed = 'NOT_USED',
  /** No bandwidth to fix this */
  NoBandwidth = 'NO_BANDWIDTH',
  /** Risk is tolerable to this project */
  TolerableRisk = 'TOLERABLE_RISK'
}

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
type DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The reason the Dependabot alert is being dismissed. */
  readonly dismissReason: DismissReason;
  /** The Dependabot alert ID to dismiss. */
  readonly repositoryVulnerabilityAlertId: Scalars['ID']['input'];
};

/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */
type DismissRepositoryVulnerabilityAlertPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Dependabot alert that was dismissed */
  readonly repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;
};

/** A draft issue within a project. */
type DraftIssue = Node & {
  /** A list of users to assigned to this draft issue. */
  readonly assignees: UserConnection;
  /** The body of the draft issue. */
  readonly body: Scalars['String']['output'];
  /** The body of the draft issue rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body of the draft issue rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created this draft issue. */
  readonly creator?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */
  readonly projectV2Items: ProjectV2ItemConnection;
  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */
  readonly projectsV2: ProjectV2Connection;
  /** The title of the draft issue */
  readonly title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** A draft issue within a project. */
type DraftIssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A draft issue within a project. */
type DraftIssueProjectV2ItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A draft issue within a project. */
type DraftIssueProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
type DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  readonly body: Scalars['String']['input'];
  /** Path to the file being commented on. */
  readonly path: Scalars['String']['input'];
  /** Position in the file to leave a comment on. */
  readonly position: Scalars['Int']['input'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
type DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  readonly body: Scalars['String']['input'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  readonly line: Scalars['Int']['input'];
  /** Path to the file being commented on. */
  readonly path: Scalars['String']['input'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  readonly side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  readonly startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  readonly startSide?: InputMaybe<DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
type EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  readonly authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit body to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit message is ignored.
   */
  readonly commitBody?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit headline to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit headline is ignored.
   */
  readonly commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  readonly expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /**
   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
   * with a merge queue any input value for merge method is ignored.
   */
  readonly mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnablePullRequestAutoMerge */
type EnablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request auto-merge was enabled on. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of EnqueuePullRequest */
type EnqueuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  readonly expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** Add the pull request to the front of the queue. */
  readonly jump?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to enqueue. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnqueuePullRequest */
type EnqueuePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The merge queue entry for the enqueued pull request. */
  readonly mergeQueueEntry?: Maybe<MergeQueueEntry>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
type Enterprise = AnnouncementBanner & Node & {
  /** The text of the announcement */
  readonly announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  readonly announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  readonly announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
  /** A URL pointing to the enterprise's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** Enterprise billing information visible to enterprise billing managers. */
  readonly billingInfo?: Maybe<EnterpriseBillingInfo>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the enterprise. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The description of the enterprise as HTML. */
  readonly descriptionHTML: Scalars['HTML']['output'];
  readonly id: Scalars['ID']['output'];
  /** The location of the enterprise. */
  readonly location?: Maybe<Scalars['String']['output']>;
  /** A list of users who are members of this enterprise. */
  readonly members: EnterpriseMemberConnection;
  /** The name of the enterprise. */
  readonly name: Scalars['String']['output'];
  /** A list of organizations that belong to this enterprise. */
  readonly organizations: OrganizationConnection;
  /**
   * Enterprise information visible to enterprise owners or enterprise owners'
   * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
   */
  readonly ownerInfo?: Maybe<EnterpriseOwnerInfo>;
  /** The HTTP path for this enterprise. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The URL-friendly identifier for the enterprise. */
  readonly slug: Scalars['String']['output'];
  /** The HTTP URL for this enterprise. */
  readonly url: Scalars['URI']['output'];
  /** Is the current viewer an admin of this enterprise? */
  readonly viewerIsAdmin: Scalars['Boolean']['output'];
  /** The URL of the enterprise website. */
  readonly websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
type EnterpriseAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
type EnterpriseMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deployment?: InputMaybe<EnterpriseUserDeployment>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
type EnterpriseOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  viewerOrganizationRole?: InputMaybe<RoleInOrganization>;
};

/** The connection type for User. */
type EnterpriseAdministratorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** A User who is an administrator of an enterprise. */
type EnterpriseAdministratorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<User>;
  /** The role of the administrator. */
  readonly role: EnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
type EnterpriseAdministratorInvitation = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The email of the person who was invited to the enterprise. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** The enterprise the invitation is for. */
  readonly enterprise: Enterprise;
  readonly id: Scalars['ID']['output'];
  /** The user who was invited to the enterprise. */
  readonly invitee?: Maybe<User>;
  /** The user who created the invitation. */
  readonly inviter?: Maybe<User>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  readonly role: EnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
type EnterpriseAdministratorInvitationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnterpriseAdministratorInvitationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
type EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  readonly field: EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
enum EnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = 'CREATED_AT'
}

/** The possible administrator roles in an enterprise account. */
enum EnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = 'BILLING_MANAGER',
  /** Represents an owner of the enterprise account. */
  Owner = 'OWNER'
}

/** The possible values for the enterprise allow private repository forking policy value. */
enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  /** Members can fork a repository to an organization within this enterprise. */
  EnterpriseOrganizations = 'ENTERPRISE_ORGANIZATIONS',
  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */
  EnterpriseOrganizationsUserAccounts = 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS',
  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */
  Everywhere = 'EVERYWHERE',
  /** Members can fork a repository only within the same organization (intra-org). */
  SameOrganization = 'SAME_ORGANIZATION',
  /** Members can fork a repository to their user account or within the same organization. */
  SameOrganizationUserAccounts = 'SAME_ORGANIZATION_USER_ACCOUNTS',
  /** Members can fork a repository to their user account. */
  UserAccounts = 'USER_ACCOUNTS'
}

/** Metadata for an audit entry containing enterprise account information. */
type EnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
type EnterpriseBillingInfo = {
  /** The number of licenseable users/emails across the enterprise. */
  readonly allLicensableUsersCount: Scalars['Int']['output'];
  /** The number of data packs used by all organizations owned by the enterprise. */
  readonly assetPacks: Scalars['Int']['output'];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  readonly bandwidthQuota: Scalars['Float']['output'];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  readonly bandwidthUsage: Scalars['Float']['output'];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  readonly bandwidthUsagePercentage: Scalars['Int']['output'];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  readonly storageQuota: Scalars['Float']['output'];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  readonly storageUsage: Scalars['Float']['output'];
  /** The storage usage as a percentage of the storage quota. */
  readonly storageUsagePercentage: Scalars['Int']['output'];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  readonly totalAvailableLicenses: Scalars['Int']['output'];
  /** The total number of licenses allocated. */
  readonly totalLicenses: Scalars['Int']['output'];
};

/** The possible values for the enterprise base repository permission setting. */
enum EnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = 'ADMIN',
  /** Organization members will only be able to clone and pull public repositories. */
  None = 'NONE',
  /** Organizations in the enterprise choose base repository permissions for their members. */
  NoPolicy = 'NO_POLICY',
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = 'READ',
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = 'WRITE'
}

/** The possible values for an enabled/disabled enterprise setting. */
enum EnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** The possible values for an enabled/no policy enterprise setting. */
enum EnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** The connection type for OrganizationInvitation. */
type EnterpriseFailedInvitationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseFailedInvitationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** Identifies the total count of unique users in the connection. */
  readonly totalUniqueUserCount: Scalars['Int']['output'];
};

/** A failed invitation to be a member in an enterprise organization. */
type EnterpriseFailedInvitationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<OrganizationInvitation>;
};

/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseIdentityProvider = Node & {
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  readonly digestMethod?: Maybe<SamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  readonly enterprise?: Maybe<Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  readonly externalIdentities: ExternalIdentityConnection;
  readonly id: Scalars['ID']['output'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  readonly idpCertificate?: Maybe<Scalars['X509Certificate']['output']>;
  /** The Issuer Entity ID for the SAML identity provider. */
  readonly issuer?: Maybe<Scalars['String']['output']>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  readonly recoveryCodes?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  readonly signatureMethod?: Maybe<SamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  readonly ssoUrl?: Maybe<Scalars['URI']['output']>;
};


/**
 * An identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseIdentityProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** An object that is a member of an enterprise. */
type EnterpriseMember = EnterpriseUserAccount | User;

/** The connection type for EnterpriseMember. */
type EnterpriseMemberConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseMemberEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseMember>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** A User who is a member of an enterprise through one or more organizations. */
type EnterpriseMemberEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseMember>;
};

/** Ordering options for enterprise member connections. */
type EnterpriseMemberOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order enterprise members by. */
  readonly field: EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
enum EnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order enterprise members by login */
  Login = 'LOGIN'
}

/** The possible values for the enterprise members can create repositories setting. */
enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Organization administrators choose whether to allow members to create repositories. */
  NoPolicy = 'NO_POLICY',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will be able to create only public repositories. */
  Public = 'PUBLIC'
}

/** The possible values for the members can make purchases setting. */
enum EnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED'
}

/** The connection type for Organization. */
type EnterpriseOrganizationMembershipConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An enterprise organization that a user is a member of. */
type EnterpriseOrganizationMembershipEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Organization>;
  /** The role of the user in the enterprise membership. */
  readonly role: EnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
type EnterpriseOutsideCollaboratorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
type EnterpriseOutsideCollaboratorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<User>;
  /** The enterprise organization repositories this user is a member of. */
  readonly repositories: EnterpriseRepositoryInfoConnection;
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
type EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
};

/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfo = {
  /** A list of all of the administrators for this enterprise. */
  readonly admins: EnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  readonly affiliatedUsersWithTwoFactorDisabled: UserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  readonly affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean']['output'];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  readonly allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  readonly allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection;
  /** The value for the allow private repository forking policy on the enterprise. */
  readonly allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  readonly defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided base repository permission. */
  readonly defaultRepositoryPermissionSettingOrganizations: OrganizationConnection;
  /**
   * A list of domains owned by the enterprise. Visible to enterprise owners or
   * enterprise owners' personal access tokens (classic) with admin:enterprise scope.
   */
  readonly domains: VerifiableDomainConnection;
  /** Enterprise Server installations owned by the enterprise. */
  readonly enterpriseServerInstallations: EnterpriseServerInstallationConnection;
  /** A list of failed invitations in the enterprise. */
  readonly failedInvitations: EnterpriseFailedInvitationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  readonly ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  /**
   * The IP addresses that are allowed to access resources owned by the enterprise.
   * Visible to enterprise owners or enterprise owners' personal access tokens
   * (classic) with admin:enterprise scope.
   */
  readonly ipAllowListEntries: IpAllowListEntryConnection;
  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */
  readonly ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether or not the base repository permission is currently being updated. */
  readonly isUpdatingDefaultRepositoryPermission: Scalars['Boolean']['output'];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  readonly isUpdatingTwoFactorRequirement: Scalars['Boolean']['output'];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  readonly membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  readonly membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  readonly membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  readonly membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  readonly membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']['output']>;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  readonly membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  readonly membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  readonly membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  readonly membersCanDeleteIssuesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  readonly membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  readonly membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  readonly membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  readonly membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  readonly membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  readonly membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  readonly membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  readonly membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  readonly membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection;
  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */
  readonly notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;
  /** The OIDC Identity Provider for the enterprise. */
  readonly oidcProvider?: Maybe<OidcProvider>;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  readonly organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  readonly organizationProjectsSettingOrganizations: OrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  readonly outsideCollaborators: EnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  readonly pendingAdminInvitations: EnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  readonly pendingCollaboratorInvitations: RepositoryInvitationConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  readonly pendingMemberInvitations: EnterprisePendingMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  readonly repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  readonly repositoryProjectsSettingOrganizations: OrganizationConnection;
  /** The SAML Identity Provider for the enterprise. */
  readonly samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  readonly samlIdentityProviderSettingOrganizations: OrganizationConnection;
  /** A list of members with a support entitlement. */
  readonly supportEntitlements: EnterpriseMemberConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  readonly teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  readonly teamDiscussionsSettingOrganizations: OrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  readonly twoFactorRequiredSetting: EnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  readonly twoFactorRequiredSettingOrganizations: OrganizationConnection;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoAdminsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseAdministratorRole>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: DefaultRepositoryPermissionField;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoDomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VerifiableDomainOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  connectedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoFailedInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: OrganizationMembersCanCreateRepositoriesSettingValue;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoOutsideCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<RepositoryVisibility>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoPendingAdminInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseAdministratorInvitationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseAdministratorRole>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoPendingMemberInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  invitationSource?: InputMaybe<OrganizationInvitationSource>;
  last?: InputMaybe<Scalars['Int']['input']>;
  organizationLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: IdentityProviderConfigurationState;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoSupportEntitlementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseMemberOrder>;
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};


/**
 * Enterprise information visible to enterprise owners or enterprise owners'
 * personal access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  value: Scalars['Boolean']['input'];
};

/** The connection type for OrganizationInvitation. */
type EnterprisePendingMemberInvitationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** Identifies the total count of unique users in the connection. */
  readonly totalUniqueUserCount: Scalars['Int']['output'];
};

/** An invitation to be a member in an enterprise organization. */
type EnterprisePendingMemberInvitationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<OrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
type EnterpriseRepositoryInfo = Node & {
  readonly id: Scalars['ID']['output'];
  /** Identifies if the repository is private or internal. */
  readonly isPrivate: Scalars['Boolean']['output'];
  /** The repository's name. */
  readonly name: Scalars['String']['output'];
  /** The repository's name with owner. */
  readonly nameWithOwner: Scalars['String']['output'];
};

/** The connection type for EnterpriseRepositoryInfo. */
type EnterpriseRepositoryInfoConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnterpriseRepositoryInfoEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
type EnterpriseServerInstallation = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The customer name to which the Enterprise Server installation belongs. */
  readonly customerName: Scalars['String']['output'];
  /** The host name of the Enterprise Server installation. */
  readonly hostName: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  readonly isConnected: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** User accounts on this Enterprise Server installation. */
  readonly userAccounts: EnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  readonly userAccountsUploads: EnterpriseServerUserAccountsUploadConnection;
};


/** An Enterprise Server installation. */
type EnterpriseServerInstallationUserAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountOrder>;
};


/** An Enterprise Server installation. */
type EnterpriseServerInstallationUserAccountsUploadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
type EnterpriseServerInstallationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnterpriseServerInstallationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseServerInstallation>;
};

/** The connection type for EnterpriseServerInstallation. */
type EnterpriseServerInstallationMembershipConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseServerInstallationMembershipEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An Enterprise Server installation that a user is a member of. */
type EnterpriseServerInstallationMembershipEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseServerInstallation>;
  /** The role of the user in the enterprise membership. */
  readonly role: EnterpriseUserAccountMembershipRole;
};

/** Ordering options for Enterprise Server installation connections. */
type EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order Enterprise Server installations by. */
  readonly field: EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
enum EnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order Enterprise Server installations by customer name */
  CustomerName = 'CUSTOMER_NAME',
  /** Order Enterprise Server installations by host name */
  HostName = 'HOST_NAME'
}

/** A user account on an Enterprise Server installation. */
type EnterpriseServerUserAccount = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** User emails belonging to this user account. */
  readonly emails: EnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  readonly enterpriseServerInstallation: EnterpriseServerInstallation;
  readonly id: Scalars['ID']['output'];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  readonly isSiteAdmin: Scalars['Boolean']['output'];
  /** The login of the user account on the Enterprise Server installation. */
  readonly login: Scalars['String']['output'];
  /** The profile name of the user account on the Enterprise Server installation. */
  readonly profileName?: Maybe<Scalars['String']['output']>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  readonly remoteCreatedAt: Scalars['DateTime']['output'];
  /** The ID of the user account on the Enterprise Server installation. */
  readonly remoteUserId: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** A user account on an Enterprise Server installation. */
type EnterpriseServerUserAccountEmailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
type EnterpriseServerUserAccountConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnterpriseServerUserAccountEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
type EnterpriseServerUserAccountEmail = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The email address. */
  readonly email: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** Indicates whether this is the primary email of the associated user account. */
  readonly isPrimary: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The user account to which the email belongs. */
  readonly userAccount: EnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
type EnterpriseServerUserAccountEmailConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnterpriseServerUserAccountEmailEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
type EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order emails by. */
  readonly field: EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
enum EnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = 'EMAIL'
}

/** Ordering options for Enterprise Server user account connections. */
type EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order user accounts by. */
  readonly field: EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
enum EnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = 'LOGIN',
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = 'REMOTE_CREATED_AT'
}

/** A user accounts upload from an Enterprise Server installation. */
type EnterpriseServerUserAccountsUpload = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The enterprise to which this upload belongs. */
  readonly enterprise: Enterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  readonly enterpriseServerInstallation: EnterpriseServerInstallation;
  readonly id: Scalars['ID']['output'];
  /** The name of the file uploaded. */
  readonly name: Scalars['String']['output'];
  /** The synchronization state of the upload */
  readonly syncState: EnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
type EnterpriseServerUserAccountsUploadConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<EnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnterpriseServerUserAccountsUploadEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<EnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
type EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order user accounts uploads by. */
  readonly field: EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
enum EnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Synchronization state of the Enterprise Server user accounts upload */
enum EnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = 'FAILURE',
  /** The synchronization of the upload is pending. */
  Pending = 'PENDING',
  /** The synchronization of the upload succeeded. */
  Success = 'SUCCESS'
}

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
type EnterpriseUserAccount = Actor & Node & {
  /** A URL pointing to the enterprise user account's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The enterprise in which this user account exists. */
  readonly enterprise: Enterprise;
  /** A list of Enterprise Server installations this user is a member of. */
  readonly enterpriseInstallations: EnterpriseServerInstallationMembershipConnection;
  readonly id: Scalars['ID']['output'];
  /** An identifier for the enterprise user account, a login or email address */
  readonly login: Scalars['String']['output'];
  /** The name of the enterprise user account */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** A list of enterprise organizations this user is a member of. */
  readonly organizations: EnterpriseOrganizationMembershipConnection;
  /** The HTTP path for this user. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this user. */
  readonly url: Scalars['URI']['output'];
  /** The user within the enterprise. */
  readonly user?: Maybe<User>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
type EnterpriseUserAccountAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
type EnterpriseUserAccountEnterpriseInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
type EnterpriseUserAccountOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;
};

/** The possible roles for enterprise membership. */
enum EnterpriseUserAccountMembershipRole {
  /** The user is a member of an organization in the enterprise. */
  Member = 'MEMBER',
  /** The user is an owner of an organization in the enterprise. */
  Owner = 'OWNER',
  /**
   * The user is not an owner of the enterprise, and not a member or owner of any
   * organizations in the enterprise; only for EMU-enabled enterprises.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The possible GitHub Enterprise deployments where this user can exist. */
enum EnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = 'CLOUD',
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = 'SERVER'
}

/** An environment. */
type Environment = Node & {
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The name of the environment */
  readonly name: Scalars['String']['output'];
  /** The protection rules defined for this environment */
  readonly protectionRules: DeploymentProtectionRuleConnection;
};


/** An environment. */
type EnvironmentProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Environment. */
type EnvironmentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EnvironmentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Environment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type EnvironmentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Environment>;
};

/** Properties by which environments connections can be ordered */
enum EnvironmentOrderField {
  /** Order environments by name. */
  Name = 'NAME'
}

/** Ordering options for environments */
type Environments = {
  /** The direction in which to order environments by the specified field. */
  readonly direction: OrderDirection;
  /** The field to order environments by. */
  readonly field: EnvironmentOrderField;
};

/**
 * An external identity provisioned by SAML SSO or SCIM. If SAML is configured on
 * the organization, the external identity is visible to (1) organization owners,
 * (2) organization owners' personal access tokens (classic) with read:org or
 * admin:org scope, (3) GitHub App with an installation token with read or write
 * access to members. If SAML is configured on the enterprise, the external
 * identity is visible to (1) enterprise owners, (2) enterprise owners' personal
 * access tokens (classic) with read:enterprise or admin:enterprise scope.
 */
type ExternalIdentity = Node & {
  /** The GUID for this identity */
  readonly guid: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** Organization invitation for this SCIM-provisioned external identity */
  readonly organizationInvitation?: Maybe<OrganizationInvitation>;
  /** SAML Identity attributes */
  readonly samlIdentity?: Maybe<ExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  readonly scimIdentity?: Maybe<ExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  readonly user?: Maybe<User>;
};

/** An attribute for the External Identity attributes collection */
type ExternalIdentityAttribute = {
  /** The attribute metadata as JSON */
  readonly metadata?: Maybe<Scalars['String']['output']>;
  /** The attribute name */
  readonly name: Scalars['String']['output'];
  /** The attribute value */
  readonly value: Scalars['String']['output'];
};

/** The connection type for ExternalIdentity. */
type ExternalIdentityConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ExternalIdentityEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ExternalIdentity>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ExternalIdentityEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ExternalIdentity>;
};

/** SAML attributes for the External Identity */
type ExternalIdentitySamlAttributes = {
  /** SAML Identity attributes */
  readonly attributes: ReadonlyArray<ExternalIdentityAttribute>;
  /** The emails associated with the SAML identity */
  readonly emails?: Maybe<ReadonlyArray<UserEmailMetadata>>;
  /** Family name of the SAML identity */
  readonly familyName?: Maybe<Scalars['String']['output']>;
  /** Given name of the SAML identity */
  readonly givenName?: Maybe<Scalars['String']['output']>;
  /** The groups linked to this identity in IDP */
  readonly groups?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** The NameID of the SAML identity */
  readonly nameId?: Maybe<Scalars['String']['output']>;
  /** The userName of the SAML identity */
  readonly username?: Maybe<Scalars['String']['output']>;
};

/** SCIM attributes for the External Identity */
type ExternalIdentityScimAttributes = {
  /** The emails associated with the SCIM identity */
  readonly emails?: Maybe<ReadonlyArray<UserEmailMetadata>>;
  /** Family name of the SCIM identity */
  readonly familyName?: Maybe<Scalars['String']['output']>;
  /** Given name of the SCIM identity */
  readonly givenName?: Maybe<Scalars['String']['output']>;
  /** The groups linked to this identity in IDP */
  readonly groups?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** The userName of the SCIM identity */
  readonly username?: Maybe<Scalars['String']['output']>;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
type FileAddition = {
  /** The base64 encoded contents of the file */
  readonly contents: Scalars['Base64String']['input'];
  /** The path in the repository where the file will be located */
  readonly path: Scalars['String']['input'];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
type FileChanges = {
  /** File to add or change. */
  readonly additions?: InputMaybe<ReadonlyArray<FileAddition>>;
  /** Files to delete. */
  readonly deletions?: InputMaybe<ReadonlyArray<FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
type FileDeletion = {
  /** The path to delete */
  readonly path: Scalars['String']['input'];
};

/** The possible viewed states of a file . */
enum FileViewedState {
  /** The file has new changes since last viewed. */
  Dismissed = 'DISMISSED',
  /** The file has not been marked as viewed. */
  Unviewed = 'UNVIEWED',
  /** The file has been marked as viewed. */
  Viewed = 'VIEWED'
}

/** Autogenerated input type of FollowOrganization */
type FollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to follow. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowOrganization */
type FollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that was followed. */
  readonly organization?: Maybe<Organization>;
};

/** Autogenerated input type of FollowUser */
type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to follow. */
  readonly userId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowUser */
type FollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was followed. */
  readonly user?: Maybe<User>;
};

/** The connection type for User. */
type FollowerConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<UserEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** The connection type for User. */
type FollowingConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<UserEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** A funding platform link for a repository. */
type FundingLink = {
  /** The funding platform this link is for. */
  readonly platform: FundingPlatform;
  /** The configured URL for this funding link. */
  readonly url: Scalars['URI']['output'];
};

/** The possible funding platforms for repository funding links. */
enum FundingPlatform {
  /** Community Bridge funding platform. */
  CommunityBridge = 'COMMUNITY_BRIDGE',
  /** Custom funding platform. */
  Custom = 'CUSTOM',
  /** GitHub funding platform. */
  Github = 'GITHUB',
  /** IssueHunt funding platform. */
  Issuehunt = 'ISSUEHUNT',
  /** Ko-fi funding platform. */
  KoFi = 'KO_FI',
  /** LFX Crowdfunding funding platform. */
  LfxCrowdfunding = 'LFX_CROWDFUNDING',
  /** Liberapay funding platform. */
  Liberapay = 'LIBERAPAY',
  /** Open Collective funding platform. */
  OpenCollective = 'OPEN_COLLECTIVE',
  /** Otechie funding platform. */
  Otechie = 'OTECHIE',
  /** Patreon funding platform. */
  Patreon = 'PATREON',
  /** Tidelift funding platform. */
  Tidelift = 'TIDELIFT'
}

/** A generic hovercard context with a message and icon */
type GenericHovercardContext = HovercardContext & {
  /** A string describing this context */
  readonly message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  readonly octicon: Scalars['String']['output'];
};

/** A Gist. */
type Gist = Node & Starrable & UniformResourceLocatable & {
  /** A list of comments associated with the gist */
  readonly comments: GistCommentConnection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The gist description. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The files in this gist. */
  readonly files?: Maybe<ReadonlyArray<Maybe<GistFile>>>;
  /** A list of forks associated with the gist */
  readonly forks: GistConnection;
  readonly id: Scalars['ID']['output'];
  /** Identifies if the gist is a fork. */
  readonly isFork: Scalars['Boolean']['output'];
  /** Whether the gist is public or not. */
  readonly isPublic: Scalars['Boolean']['output'];
  /** The gist name. */
  readonly name: Scalars['String']['output'];
  /** The gist owner. */
  readonly owner?: Maybe<RepositoryOwner>;
  /** Identifies when the gist was last pushed to. */
  readonly pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTML path to this resource. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Returns a count of how many stargazers there are on this object */
  readonly stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  readonly stargazers: StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this Gist. */
  readonly url: Scalars['URI']['output'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  readonly viewerHasStarred: Scalars['Boolean']['output'];
};


/** A Gist. */
type GistCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A Gist. */
type GistFilesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  oid?: InputMaybe<Scalars['GitObjectID']['input']>;
};


/** A Gist. */
type GistForksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<GistOrder>;
};


/** A Gist. */
type GistStargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};

/** Represents a comment on an Gist. */
type GistComment = Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the gist. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** Identifies the comment body. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  /** The associated gist. */
  readonly gist: Gist;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  readonly isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  readonly minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  readonly viewerCanMinimize: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on an Gist. */
type GistCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GistComment. */
type GistCommentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<GistCommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<GistComment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type GistCommentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<GistComment>;
};

/** The connection type for Gist. */
type GistConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<GistEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Gist>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type GistEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Gist>;
};

/** A file in a gist. */
type GistFile = {
  /** The file name encoded to remove characters that are invalid in URL paths. */
  readonly encodedName?: Maybe<Scalars['String']['output']>;
  /** The gist file encoding. */
  readonly encoding?: Maybe<Scalars['String']['output']>;
  /** The file extension from the file name. */
  readonly extension?: Maybe<Scalars['String']['output']>;
  /** Indicates if this file is an image. */
  readonly isImage: Scalars['Boolean']['output'];
  /** Whether the file's contents were truncated. */
  readonly isTruncated: Scalars['Boolean']['output'];
  /** The programming language this file is written in. */
  readonly language?: Maybe<Language>;
  /** The gist file name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** The gist file size in bytes. */
  readonly size?: Maybe<Scalars['Int']['output']>;
  /** UTF8 text data or null if the file is binary */
  readonly text?: Maybe<Scalars['String']['output']>;
};


/** A file in a gist. */
type GistFileTextArgs = {
  truncate?: InputMaybe<Scalars['Int']['input']>;
};

/** Ordering options for gist connections */
type GistOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repositories by. */
  readonly field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
enum GistOrderField {
  /** Order gists by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order gists by push time */
  PushedAt = 'PUSHED_AT',
  /** Order gists by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The privacy of a Gist */
enum GistPrivacy {
  /** Gists that are public and secret */
  All = 'ALL',
  /** Public */
  Public = 'PUBLIC',
  /** Secret */
  Secret = 'SECRET'
}

/** Represents an actor in a Git commit (ie. an author or committer). */
type GitActor = {
  /** A URL pointing to the author's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** The timestamp of the Git action (authoring or committing). */
  readonly date?: Maybe<Scalars['GitTimestamp']['output']>;
  /** The email in the Git commit. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** The name in the Git commit. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  readonly user?: Maybe<User>;
};


/** Represents an actor in a Git commit (ie. an author or committer). */
type GitActorAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for GitActor. */
type GitActorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<GitActorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<GitActor>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type GitActorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<GitActor>;
};

/** Represents information about the GitHub instance. */
type GitHubMetadata = {
  /** Returns a String that's a SHA of `github-services` */
  readonly gitHubServicesSha: Scalars['GitObjectID']['output'];
  /** IP addresses that users connect to for git operations */
  readonly gitIpAddresses?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** IP addresses that GitHub Enterprise Importer uses for outbound connections */
  readonly githubEnterpriseImporterIpAddresses?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** IP addresses that service hooks are sent from */
  readonly hookIpAddresses?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** IP addresses that the importer connects from */
  readonly importerIpAddresses?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** Whether or not users are verified */
  readonly isPasswordAuthenticationVerifiable: Scalars['Boolean']['output'];
  /** IP addresses for GitHub Pages' A records */
  readonly pagesIpAddresses?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
};

/** Represents a Git object. */
type GitObject = {
  /** An abbreviated version of the Git object ID */
  readonly abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  readonly commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  readonly commitUrl: Scalars['URI']['output'];
  readonly id: Scalars['ID']['output'];
  /** The Git object ID */
  readonly oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  readonly repository: Repository;
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
type GitSignature = {
  /** Email used to sign this object. */
  readonly email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  readonly isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  readonly payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  readonly signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  readonly signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  readonly state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  readonly wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** The state of a Git signature. */
enum GitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = 'BAD_CERT',
  /** Invalid email used for signing */
  BadEmail = 'BAD_EMAIL',
  /** Signing key expired */
  ExpiredKey = 'EXPIRED_KEY',
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = 'GPGVERIFY_ERROR',
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',
  /** Invalid signature */
  Invalid = 'INVALID',
  /** Malformed signature */
  MalformedSig = 'MALFORMED_SIG',
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = 'NOT_SIGNING_KEY',
  /** Email used for signing not known to GitHub */
  NoUser = 'NO_USER',
  /** Valid signature, though certificate revocation check failed */
  OcspError = 'OCSP_ERROR',
  /** Valid signature, pending certificate revocation checking */
  OcspPending = 'OCSP_PENDING',
  /** One or more certificates in chain has been revoked */
  OcspRevoked = 'OCSP_REVOKED',
  /** Key used for signing not known to GitHub */
  UnknownKey = 'UNKNOWN_KEY',
  /** Unknown signature type */
  UnknownSigType = 'UNKNOWN_SIG_TYPE',
  /** Unsigned */
  Unsigned = 'UNSIGNED',
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = 'UNVERIFIED_EMAIL',
  /** Valid signature and verified by GitHub */
  Valid = 'VALID'
}

/** Represents a GPG signature on a Commit or Tag. */
type GpgSignature = GitSignature & {
  /** Email used to sign this object. */
  readonly email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  readonly isValid: Scalars['Boolean']['output'];
  /** Hex-encoded ID of the key that signed this object. */
  readonly keyId?: Maybe<Scalars['String']['output']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  readonly payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  readonly signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  readonly signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  readonly state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  readonly wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */
type GrantEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of the user to grant the migrator role */
  readonly login: Scalars['String']['input'];
};

/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
type GrantEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organizations that had the migrator role applied to for the given user. */
  readonly organizations?: Maybe<OrganizationConnection>;
};


/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
type GrantEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of GrantMigratorRole */
type GrantMigratorRoleInput = {
  /** The user login or Team slug to grant the migrator role. */
  readonly actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  readonly actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of GrantMigratorRole */
type GrantMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  readonly success?: Maybe<Scalars['Boolean']['output']>;
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
type HeadRefDeletedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  readonly headRef?: Maybe<Ref>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  readonly headRefName: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
type HeadRefForcePushedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  readonly afterCommit?: Maybe<Commit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  readonly beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  readonly ref?: Maybe<Ref>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
type HeadRefRestoredEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
};

/** Detail needed to display a hovercard for a user */
type Hovercard = {
  /** Each of the contexts for this hovercard */
  readonly contexts: ReadonlyArray<HovercardContext>;
};

/** An individual line of a hovercard */
type HovercardContext = {
  /** A string describing this context */
  readonly message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  readonly octicon: Scalars['String']['output'];
};

/** The possible states in which authentication can be configured with an identity provider. */
enum IdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = 'CONFIGURED',
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = 'ENFORCED',
  /** Authentication with an identity provider is not configured. */
  Unconfigured = 'UNCONFIGURED'
}

/** Autogenerated input type of ImportProject */
type ImportProjectInput = {
  /** The description of Project. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of columns containing issues and pull requests. */
  readonly columnImports: ReadonlyArray<ProjectColumnImport>;
  /** The name of Project. */
  readonly name: Scalars['String']['input'];
  /** The name of the Organization or User to create the Project under. */
  readonly ownerName: Scalars['String']['input'];
  /** Whether the Project is public or not. */
  readonly public?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of ImportProject */
type ImportProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new Project! */
  readonly project?: Maybe<Project>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
type InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The email of the person to invite as an administrator. */
  readonly email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of a user to invite as an administrator. */
  readonly invitee?: InputMaybe<Scalars['String']['input']>;
  /** The role of the administrator. */
  readonly role?: InputMaybe<EnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin */
type InviteEnterpriseAdminPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The created enterprise administrator invitation. */
  readonly invitation?: Maybe<EnterpriseAdministratorInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
enum IpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/** An IP address or range of addresses that is allowed to access an owner's resources. */
type IpAllowListEntry = Node & {
  /** A single IP address or range of IP addresses in CIDR notation. */
  readonly allowListValue: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the entry is currently active. */
  readonly isActive: Scalars['Boolean']['output'];
  /** The name of the IP allow list entry. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** The owner of the IP allow list entry. */
  readonly owner: IpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for IpAllowListEntry. */
type IpAllowListEntryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<IpAllowListEntryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<IpAllowListEntry>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type IpAllowListEntryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<IpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
type IpAllowListEntryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order IP allow list entries by. */
  readonly field: IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
enum IpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = 'ALLOW_LIST_VALUE',
  /** Order IP allow list entries by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
enum IpAllowListForInstalledAppsEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/** Types that can own an IP allow list. */
type IpAllowListOwner = App | Enterprise | Organization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type Issue = Assignable & Closable & Comment & Deletable & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & SubscribableThread & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** Reason that the conversation was locked. */
  readonly activeLockReason?: Maybe<LockReason>;
  /** A list of Users assigned to this object. */
  readonly assignees: UserConnection;
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** Identifies the body of the issue. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The http path for this issue body */
  readonly bodyResourcePath: Scalars['URI']['output'];
  /** Identifies the body of the issue rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** The http URL for this issue body */
  readonly bodyUrl: Scalars['URI']['output'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of comments associated with the Issue. */
  readonly comments: IssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  /** Identifies the primary key from the database as a BigInt. */
  readonly fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  /** The hovercard information for this issue */
  readonly hovercard: Hovercard;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** Indicates whether or not this issue is currently pinned to the repository issues list */
  readonly isPinned?: Maybe<Scalars['Boolean']['output']>;
  /** Is this issue read by the viewer */
  readonly isReadByViewer?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  readonly labels?: Maybe<LabelConnection>;
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Branches linked to this issue. */
  readonly linkedBranches: LinkedBranchConnection;
  /** `true` if the object is locked */
  readonly locked: Scalars['Boolean']['output'];
  /** Identifies the milestone associated with the issue. */
  readonly milestone?: Maybe<Milestone>;
  /** Identifies the issue number. */
  readonly number: Scalars['Int']['output'];
  /** A list of Users that are participating in the Issue conversation. */
  readonly participants: UserConnection;
  /** List of project cards associated with this issue. */
  readonly projectCards: ProjectCardConnection;
  /** List of project items associated with this issue. */
  readonly projectItems: ProjectV2ItemConnection;
  /** Find a project by number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  readonly projectsV2: ProjectV2Connection;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The HTTP path for this issue */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the state of the issue. */
  readonly state: IssueState;
  /** Identifies the reason for the issue state. */
  readonly stateReason?: Maybe<IssueStateReason>;
  /**
   * A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  readonly timeline: IssueTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the issue. */
  readonly timelineItems: IssueTimelineItemsConnection;
  /** Identifies the issue title. */
  readonly title: Scalars['String']['output'];
  /** Identifies the issue title rendered to HTML. */
  readonly titleHTML: Scalars['String']['output'];
  /** A list of issues that track this issue */
  readonly trackedInIssues: IssueConnection;
  /** A list of issues tracked inside the current issue */
  readonly trackedIssues: IssueConnection;
  /** The number of tracked issues for this issue */
  readonly trackedIssuesCount: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
  /** Identifies the viewer's thread subscription form action. */
  readonly viewerThreadSubscriptionFormAction?: Maybe<ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  readonly viewerThreadSubscriptionStatus?: Maybe<ThreadSubscriptionState>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueHovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueLinkedBranchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueProjectCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<ReadonlyArray<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueProjectItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueTimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueTimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<ReadonlyArray<IssueTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueTrackedInIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueTrackedIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueTrackedIssuesCountArgs = {
  states?: InputMaybe<ReadonlyArray<InputMaybe<TrackedIssueStates>>>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
type IssueUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible state reasons of a closed issue. */
enum IssueClosedStateReason {
  /** An issue that has been closed as completed */
  Completed = 'COMPLETED',
  /** An issue that has been closed as not planned */
  NotPlanned = 'NOT_PLANNED'
}

/** Represents a comment on an Issue. */
type IssueComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  /** Identifies the primary key from the database as a BigInt. */
  readonly fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  readonly isMinimized: Scalars['Boolean']['output'];
  /** Identifies the issue associated with the comment. */
  readonly issue: Issue;
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  readonly minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
   */
  readonly pullRequest?: Maybe<PullRequest>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The HTTP path for this issue comment */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue comment */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  readonly viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** Represents a comment on an Issue. */
type IssueCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** Represents a comment on an Issue. */
type IssueCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for IssueComment. */
type IssueCommentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<IssueCommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<IssueComment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type IssueCommentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<IssueComment>;
};

/** Ways in which lists of issue comments can be ordered upon return. */
type IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order issue comments by. */
  readonly field: IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
enum IssueCommentOrderField {
  /** Order issue comments by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The connection type for Issue. */
type IssueConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<IssueEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Issue>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** This aggregates issues opened by a user within one repository. */
type IssueContributionsByRepository = {
  /** The issue contributions. */
  readonly contributions: CreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  readonly repository: Repository;
};


/** This aggregates issues opened by a user within one repository. */
type IssueContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** An edge in a connection. */
type IssueEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Issue>;
};

/** Ways in which to filter lists of issues. */
type IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  readonly assignee?: InputMaybe<Scalars['String']['input']>;
  /** List issues created by given name. */
  readonly createdBy?: InputMaybe<Scalars['String']['input']>;
  /** List issues where the list of label names exist on the issue. */
  readonly labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** List issues where the given name is mentioned in the issue. */
  readonly mentioned?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its database ID. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  readonly milestone?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  readonly milestoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** List issues that have been updated at or after the given date. */
  readonly since?: InputMaybe<Scalars['DateTime']['input']>;
  /** List issues filtered by the list of states given. */
  readonly states?: InputMaybe<ReadonlyArray<IssueState>>;
  /** List issues subscribed to by viewer. */
  readonly viewerSubscribed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Used for return value of Repository.issueOrPullRequest. */
type IssueOrPullRequest = Issue | PullRequest;

/** Ways in which lists of issues can be ordered upon return. */
type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order issues by. */
  readonly field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
enum IssueOrderField {
  /** Order issues by comment count */
  Comments = 'COMMENTS',
  /** Order issues by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order issues by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of an issue. */
enum IssueState {
  /** An issue that has been closed */
  Closed = 'CLOSED',
  /** An issue that is still open */
  Open = 'OPEN'
}

/** The possible state reasons of an issue. */
enum IssueStateReason {
  /** An issue that has been closed as completed */
  Completed = 'COMPLETED',
  /** An issue that has been closed as not planned */
  NotPlanned = 'NOT_PLANNED',
  /** An issue that has been reopened */
  Reopened = 'REOPENED'
}

/** A repository issue template. */
type IssueTemplate = {
  /** The template purpose. */
  readonly about?: Maybe<Scalars['String']['output']>;
  /** The suggested assignees. */
  readonly assignees: UserConnection;
  /** The suggested issue body. */
  readonly body?: Maybe<Scalars['String']['output']>;
  /** The template filename. */
  readonly filename: Scalars['String']['output'];
  /** The suggested issue labels */
  readonly labels?: Maybe<LabelConnection>;
  /** The template name. */
  readonly name: Scalars['String']['output'];
  /** The suggested issue title. */
  readonly title?: Maybe<Scalars['String']['output']>;
};


/** A repository issue template. */
type IssueTemplateAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository issue template. */
type IssueTemplateLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** The connection type for IssueTimelineItem. */
type IssueTimelineConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<IssueTimelineItemEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<IssueTimelineItem>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An item in an issue timeline */
type IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;

/** An edge in a connection. */
type IssueTimelineItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<IssueTimelineItem>;
};

/** An item in an issue timeline */
type IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;

/** The connection type for IssueTimelineItems. */
type IssueTimelineItemsConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<IssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  readonly filteredCount: Scalars['Int']['output'];
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<IssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  readonly pageCount: Scalars['Int']['output'];
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** Identifies the date and time when the timeline was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** An edge in a connection. */
type IssueTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<IssueTimelineItems>;
};

/** The possible item types found in a timeline. */
enum IssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** Represents a user signing up for a GitHub account. */
type JoinedGitHubContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
type Label = Node & {
  /** Identifies the label color. */
  readonly color: Scalars['String']['output'];
  /** Identifies the date and time when the label was created. */
  readonly createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** A brief description of this label. */
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Indicates whether or not this is a default label. */
  readonly isDefault: Scalars['Boolean']['output'];
  /** A list of issues associated with this label. */
  readonly issues: IssueConnection;
  /** Identifies the label name. */
  readonly name: Scalars['String']['output'];
  /** A list of pull requests associated with this label. */
  readonly pullRequests: PullRequestConnection;
  /** The repository associated with this label. */
  readonly repository: Repository;
  /** The HTTP path for this label. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the label was last updated. */
  readonly updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTTP URL for this label. */
  readonly url: Scalars['URI']['output'];
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
type LabelIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<IssueState>>;
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
type LabelPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<PullRequestState>>;
};

/** The connection type for Label. */
type LabelConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<LabelEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Label>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type LabelEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Label>;
};

/** Ways in which lists of labels can be ordered upon return. */
type LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order labels by. */
  readonly field: LabelOrderField;
};

/** Properties by which label connections can be ordered. */
enum LabelOrderField {
  /** Order labels by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order labels by name */
  Name = 'NAME'
}

/** An object that can have labels assigned to it. */
type Labelable = {
  /** A list of labels associated with the object. */
  readonly labels?: Maybe<LabelConnection>;
};


/** An object that can have labels assigned to it. */
type LabelableLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
type LabeledEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the label associated with the 'labeled' event. */
  readonly label: Label;
  /** Identifies the `Labelable` associated with the event. */
  readonly labelable: Labelable;
};

/** Represents a given language found in repositories. */
type Language = Node & {
  /** The color defined for the current language. */
  readonly color?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The name of the current language. */
  readonly name: Scalars['String']['output'];
};

/** A list of languages associated with the parent. */
type LanguageConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<LanguageEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Language>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** The total size in bytes of files written in that language. */
  readonly totalSize: Scalars['Int']['output'];
};

/** Represents the language of a repository. */
type LanguageEdge = {
  readonly cursor: Scalars['String']['output'];
  readonly node: Language;
  /** The number of bytes of code written in the language. */
  readonly size: Scalars['Int']['output'];
};

/** Ordering options for language connections. */
type LanguageOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order languages by. */
  readonly field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
enum LanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = 'SIZE'
}

/** A repository's open source license */
type License = Node & {
  /** The full text of the license */
  readonly body: Scalars['String']['output'];
  /** The conditions set by the license */
  readonly conditions: ReadonlyArray<Maybe<LicenseRule>>;
  /** A human-readable description of the license */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** Whether the license should be featured */
  readonly featured: Scalars['Boolean']['output'];
  /** Whether the license should be displayed in license pickers */
  readonly hidden: Scalars['Boolean']['output'];
  readonly id: Scalars['ID']['output'];
  /** Instructions on how to implement the license */
  readonly implementation?: Maybe<Scalars['String']['output']>;
  /** The lowercased SPDX ID of the license */
  readonly key: Scalars['String']['output'];
  /** The limitations set by the license */
  readonly limitations: ReadonlyArray<Maybe<LicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  readonly name: Scalars['String']['output'];
  /** Customary short name if applicable (e.g, GPLv3) */
  readonly nickname?: Maybe<Scalars['String']['output']>;
  /** The permissions set by the license */
  readonly permissions: ReadonlyArray<Maybe<LicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  readonly pseudoLicense: Scalars['Boolean']['output'];
  /** Short identifier specified by <https://spdx.org/licenses> */
  readonly spdxId?: Maybe<Scalars['String']['output']>;
  /** URL to the license on <https://choosealicense.com> */
  readonly url?: Maybe<Scalars['URI']['output']>;
};

/** Describes a License's conditions, permissions, and limitations */
type LicenseRule = {
  /** A description of the rule */
  readonly description: Scalars['String']['output'];
  /** The machine-readable rule key */
  readonly key: Scalars['String']['output'];
  /** The human-readable rule label */
  readonly label: Scalars['String']['output'];
};

/** Autogenerated input type of LinkProjectV2ToRepository */
type LinkProjectV2ToRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the repository. */
  readonly projectId: Scalars['ID']['input'];
  /** The ID of the repository to link to the project. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkProjectV2ToRepository */
type LinkProjectV2ToRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the project is linked to. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of LinkProjectV2ToTeam */
type LinkProjectV2ToTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the team. */
  readonly projectId: Scalars['ID']['input'];
  /** The ID of the team to link to the project. */
  readonly teamId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkProjectV2ToTeam */
type LinkProjectV2ToTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team the project is linked to */
  readonly team?: Maybe<Team>;
};

/** Autogenerated input type of LinkRepositoryToProject */
type LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to link to a Repository */
  readonly projectId: Scalars['ID']['input'];
  /** The ID of the Repository to link to a Project. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of LinkRepositoryToProject */
type LinkRepositoryToProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The linked Project. */
  readonly project?: Maybe<Project>;
  /** The linked Repository. */
  readonly repository?: Maybe<Repository>;
};

/** A branch linked to an issue. */
type LinkedBranch = Node & {
  readonly id: Scalars['ID']['output'];
  /** The branch's ref. */
  readonly ref?: Maybe<Ref>;
};

/** The connection type for LinkedBranch. */
type LinkedBranchConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<LinkedBranchEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<LinkedBranch>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type LinkedBranchEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<LinkedBranch>;
};

/** Autogenerated input type of LockLockable */
type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A reason for why the item will be locked. */
  readonly lockReason?: InputMaybe<LockReason>;
  /** ID of the item to be locked. */
  readonly lockableId: Scalars['ID']['input'];
};

/** Autogenerated return type of LockLockable */
type LockLockablePayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was locked. */
  readonly lockedRecord?: Maybe<Lockable>;
};

/** The possible reasons that an issue or pull request was locked. */
enum LockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = 'OFF_TOPIC',
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = 'RESOLVED',
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = 'SPAM',
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = 'TOO_HEATED'
}

/** An object that can be locked. */
type Lockable = {
  /** Reason that the conversation was locked. */
  readonly activeLockReason?: Maybe<LockReason>;
  /** `true` if the object is locked */
  readonly locked: Scalars['Boolean']['output'];
};

/** Represents a 'locked' event on a given issue or pull request. */
type LockedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Reason that the conversation was locked (optional). */
  readonly lockReason?: Maybe<LockReason>;
  /** Object that was locked. */
  readonly lockable: Lockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
type Mannequin = Actor & Node & UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** The user that has claimed the data attributed to this mannequin. */
  readonly claimant?: Maybe<User>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The mannequin's email on the source instance. */
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The username of the actor. */
  readonly login: Scalars['String']['output'];
  /** The HTML path to this resource. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The URL to this resource. */
  readonly url: Scalars['URI']['output'];
};


/** A placeholder user for attribution of imported data on GitHub. */
type MannequinAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Mannequin. */
type MannequinConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MannequinEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Mannequin>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a mannequin. */
type MannequinEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Mannequin>;
};

/** Ordering options for mannequins. */
type MannequinOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order mannequins by. */
  readonly field: MannequinOrderField;
};

/** Properties by which mannequins can be ordered. */
enum MannequinOrderField {
  /** Order mannequins why when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order mannequins alphabetically by their source login. */
  Login = 'LOGIN'
}

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
type MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkDiscussionCommentAsAnswer */
type MarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that includes the chosen comment. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of MarkFileAsViewed */
type MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as viewed */
  readonly path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkFileAsViewed */
type MarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of MarkProjectV2AsTemplate */
type MarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to mark as a template. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkProjectV2AsTemplate */
type MarkProjectV2AsTemplatePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
type MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be marked as ready for review. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MarkPullRequestReadyForReview */
type MarkPullRequestReadyForReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is ready for review. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
type MarkedAsDuplicateEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  readonly canonical?: Maybe<IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  readonly duplicate?: Maybe<IssueOrPullRequest>;
  readonly id: Scalars['ID']['output'];
  /** Canonical and duplicate belong to different repositories. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
};

/** A public description of a Marketplace category. */
type MarketplaceCategory = Node & {
  /** The category's description. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The technical description of how apps listed in this category work with GitHub. */
  readonly howItWorks?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The category's name. */
  readonly name: Scalars['String']['output'];
  /** How many Marketplace listings have this as their primary category. */
  readonly primaryListingCount: Scalars['Int']['output'];
  /** The HTTP path for this Marketplace category. */
  readonly resourcePath: Scalars['URI']['output'];
  /** How many Marketplace listings have this as their secondary category. */
  readonly secondaryListingCount: Scalars['Int']['output'];
  /** The short name of the category used in its URL. */
  readonly slug: Scalars['String']['output'];
  /** The HTTP URL for this Marketplace category. */
  readonly url: Scalars['URI']['output'];
};

/** A listing in the GitHub integration marketplace. */
type MarketplaceListing = Node & {
  /** The GitHub App this listing represents. */
  readonly app?: Maybe<App>;
  /** URL to the listing owner's company site. */
  readonly companyUrl?: Maybe<Scalars['URI']['output']>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  readonly configurationResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  readonly configurationUrl: Scalars['URI']['output'];
  /** URL to the listing's documentation. */
  readonly documentationUrl?: Maybe<Scalars['URI']['output']>;
  /** The listing's detailed description. */
  readonly extendedDescription?: Maybe<Scalars['String']['output']>;
  /** The listing's detailed description rendered to HTML. */
  readonly extendedDescriptionHTML: Scalars['HTML']['output'];
  /** The listing's introductory description. */
  readonly fullDescription: Scalars['String']['output'];
  /** The listing's introductory description rendered to HTML. */
  readonly fullDescriptionHTML: Scalars['HTML']['output'];
  /** Does this listing have any plans with a free trial? */
  readonly hasPublishedFreeTrialPlans: Scalars['Boolean']['output'];
  /** Does this listing have a terms of service link? */
  readonly hasTermsOfService: Scalars['Boolean']['output'];
  /** Whether the creator of the app is a verified org */
  readonly hasVerifiedOwner: Scalars['Boolean']['output'];
  /** A technical description of how this app works with GitHub. */
  readonly howItWorks?: Maybe<Scalars['String']['output']>;
  /** The listing's technical description rendered to HTML. */
  readonly howItWorksHTML: Scalars['HTML']['output'];
  readonly id: Scalars['ID']['output'];
  /** URL to install the product to the viewer's account or organization. */
  readonly installationUrl?: Maybe<Scalars['URI']['output']>;
  /** Whether this listing's app has been installed for the current viewer */
  readonly installedForViewer: Scalars['Boolean']['output'];
  /** Whether this listing has been removed from the Marketplace. */
  readonly isArchived: Scalars['Boolean']['output'];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  readonly isDraft: Scalars['Boolean']['output'];
  /** Whether the product this listing represents is available as part of a paid plan. */
  readonly isPaid: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for display in the Marketplace. */
  readonly isPublic: Scalars['Boolean']['output'];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  readonly isRejected: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  readonly isUnverified: Scalars['Boolean']['output'];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  readonly isUnverifiedPending: Scalars['Boolean']['output'];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  readonly isVerificationPendingFromDraft: Scalars['Boolean']['output'];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  readonly isVerificationPendingFromUnverified: Scalars['Boolean']['output'];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  readonly isVerified: Scalars['Boolean']['output'];
  /** The hex color code, without the leading '#', for the logo background. */
  readonly logoBackgroundColor: Scalars['String']['output'];
  /** URL for the listing's logo image. */
  readonly logoUrl?: Maybe<Scalars['URI']['output']>;
  /** The listing's full name. */
  readonly name: Scalars['String']['output'];
  /** The listing's very short description without a trailing period or ampersands. */
  readonly normalizedShortDescription: Scalars['String']['output'];
  /** URL to the listing's detailed pricing. */
  readonly pricingUrl?: Maybe<Scalars['URI']['output']>;
  /** The category that best describes the listing. */
  readonly primaryCategory: MarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  readonly privacyPolicyUrl: Scalars['URI']['output'];
  /** The HTTP path for the Marketplace listing. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The URLs for the listing's screenshots. */
  readonly screenshotUrls: ReadonlyArray<Maybe<Scalars['String']['output']>>;
  /** An alternate category that describes the listing. */
  readonly secondaryCategory?: Maybe<MarketplaceCategory>;
  /** The listing's very short description. */
  readonly shortDescription: Scalars['String']['output'];
  /** The short name of the listing used in its URL. */
  readonly slug: Scalars['String']['output'];
  /** URL to the listing's status page. */
  readonly statusUrl?: Maybe<Scalars['URI']['output']>;
  /** An email address for support for this listing's app. */
  readonly supportEmail?: Maybe<Scalars['String']['output']>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  readonly supportUrl: Scalars['URI']['output'];
  /** URL to the listing's terms of service. */
  readonly termsOfServiceUrl?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the Marketplace listing. */
  readonly url: Scalars['URI']['output'];
  /** Can the current viewer add plans for this Marketplace listing. */
  readonly viewerCanAddPlans: Scalars['Boolean']['output'];
  /** Can the current viewer approve this Marketplace listing. */
  readonly viewerCanApprove: Scalars['Boolean']['output'];
  /** Can the current viewer delist this Marketplace listing. */
  readonly viewerCanDelist: Scalars['Boolean']['output'];
  /** Can the current viewer edit this Marketplace listing. */
  readonly viewerCanEdit: Scalars['Boolean']['output'];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  readonly viewerCanEditCategories: Scalars['Boolean']['output'];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  readonly viewerCanEditPlans: Scalars['Boolean']['output'];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  readonly viewerCanRedraft: Scalars['Boolean']['output'];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  readonly viewerCanReject: Scalars['Boolean']['output'];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  readonly viewerCanRequestApproval: Scalars['Boolean']['output'];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  readonly viewerHasPurchased: Scalars['Boolean']['output'];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  readonly viewerHasPurchasedForAllOrganizations: Scalars['Boolean']['output'];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  readonly viewerIsListingAdmin: Scalars['Boolean']['output'];
};


/** A listing in the GitHub integration marketplace. */
type MarketplaceListingLogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** Look up Marketplace Listings */
type MarketplaceListingConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MarketplaceListingEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<MarketplaceListing>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type MarketplaceListingEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<MarketplaceListing>;
};

/** Entities that have members who can set status messages. */
type MemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  readonly memberStatuses: UserStatusConnection;
};


/** Entities that have members who can set status messages. */
type MemberStatusableMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
type MembersCanDeleteReposClearAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a members_can_delete_repos.disable event. */
type MembersCanDeleteReposDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a members_can_delete_repos.enable event. */
type MembersCanDeleteReposEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
type MentionedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
};

/** Autogenerated input type of MergeBranch */
type MergeBranchInput = {
  /** The email address to associate with this commit. */
  readonly authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** The name of the base branch that the provided head will be merged into. */
  readonly base: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  readonly commitMessage?: InputMaybe<Scalars['String']['input']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  readonly head: Scalars['String']['input'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of MergeBranch */
type MergeBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The resulting merge Commit. */
  readonly mergeCommit?: Maybe<Commit>;
};

/** The possible default commit messages for merges. */
enum MergeCommitMessage {
  /** Default to a blank commit message. */
  Blank = 'BLANK',
  /** Default to the pull request's body. */
  PrBody = 'PR_BODY',
  /** Default to the pull request's title. */
  PrTitle = 'PR_TITLE'
}

/** The possible default commit titles for merges. */
enum MergeCommitTitle {
  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */
  MergeMessage = 'MERGE_MESSAGE',
  /** Default to the pull request's title. */
  PrTitle = 'PR_TITLE'
}

/** Autogenerated input type of MergePullRequest */
type MergePullRequestInput = {
  /** The email address to associate with this merge. */
  readonly authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  readonly commitBody?: InputMaybe<Scalars['String']['input']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  readonly commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  readonly expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  readonly mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of MergePullRequest */
type MergePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was merged. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** The queue of pull request entries to be merged into a protected branch in a repository. */
type MergeQueue = Node & {
  /** The configuration for this merge queue */
  readonly configuration?: Maybe<MergeQueueConfiguration>;
  /** The entries in the queue */
  readonly entries?: Maybe<MergeQueueEntryConnection>;
  readonly id: Scalars['ID']['output'];
  /** The estimated time in seconds until a newly added entry would be merged */
  readonly nextEntryEstimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;
  /** The repository this merge queue belongs to */
  readonly repository?: Maybe<Repository>;
  /** The HTTP path for this merge queue */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this merge queue */
  readonly url: Scalars['URI']['output'];
};


/** The queue of pull request entries to be merged into a protected branch in a repository. */
type MergeQueueEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Configuration for a MergeQueue */
type MergeQueueConfiguration = {
  /** The amount of time in minutes to wait for a check response before considering it a failure. */
  readonly checkResponseTimeout?: Maybe<Scalars['Int']['output']>;
  /** The maximum number of entries to build at once. */
  readonly maximumEntriesToBuild?: Maybe<Scalars['Int']['output']>;
  /** The maximum number of entries to merge at once. */
  readonly maximumEntriesToMerge?: Maybe<Scalars['Int']['output']>;
  /** The merge method to use for this queue. */
  readonly mergeMethod?: Maybe<PullRequestMergeMethod>;
  /** The strategy to use when merging entries. */
  readonly mergingStrategy?: Maybe<MergeQueueMergingStrategy>;
  /** The minimum number of entries required to merge at once. */
  readonly minimumEntriesToMerge?: Maybe<Scalars['Int']['output']>;
  /**
   * The amount of time in minutes to wait before ignoring the minumum number of
   * entries in the queue requirement and merging a collection of entries
   */
  readonly minimumEntriesToMergeWaitTime?: Maybe<Scalars['Int']['output']>;
};

/** Entries in a MergeQueue */
type MergeQueueEntry = Node & {
  /** The base commit for this entry */
  readonly baseCommit?: Maybe<Commit>;
  /** The date and time this entry was added to the merge queue */
  readonly enqueuedAt: Scalars['DateTime']['output'];
  /** The actor that enqueued this entry */
  readonly enqueuer: Actor;
  /** The estimated time in seconds until this entry will be merged */
  readonly estimatedTimeToMerge?: Maybe<Scalars['Int']['output']>;
  /** The head commit for this entry */
  readonly headCommit?: Maybe<Commit>;
  readonly id: Scalars['ID']['output'];
  /** Whether this pull request should jump the queue */
  readonly jump: Scalars['Boolean']['output'];
  /** The merge queue that this entry belongs to */
  readonly mergeQueue?: Maybe<MergeQueue>;
  /** The position of this entry in the queue */
  readonly position: Scalars['Int']['output'];
  /** The pull request that will be added to a merge group */
  readonly pullRequest?: Maybe<PullRequest>;
  /** Does this pull request need to be deployed on its own */
  readonly solo: Scalars['Boolean']['output'];
  /** The state of this entry in the queue */
  readonly state: MergeQueueEntryState;
};

/** The connection type for MergeQueueEntry. */
type MergeQueueEntryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MergeQueueEntryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<MergeQueueEntry>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type MergeQueueEntryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<MergeQueueEntry>;
};

/** The possible states for a merge queue entry. */
enum MergeQueueEntryState {
  /** The entry is currently waiting for checks to pass. */
  AwaitingChecks = 'AWAITING_CHECKS',
  /** The entry is currently locked. */
  Locked = 'LOCKED',
  /** The entry is currently mergeable. */
  Mergeable = 'MERGEABLE',
  /** The entry is currently queued. */
  Queued = 'QUEUED',
  /** The entry is currently unmergeable. */
  Unmergeable = 'UNMERGEABLE'
}

/** The possible merging strategies for a merge queue. */
enum MergeQueueMergingStrategy {
  /** Entries only allowed to merge if they are passing. */
  Allgreen = 'ALLGREEN',
  /** Failing Entires are allowed to merge if they are with a passing entry. */
  Headgreen = 'HEADGREEN'
}

/** Detailed status information about a pull request merge. */
enum MergeStateStatus {
  /** The head ref is out of date. */
  Behind = 'BEHIND',
  /** The merge is blocked. */
  Blocked = 'BLOCKED',
  /** Mergeable and passing commit status. */
  Clean = 'CLEAN',
  /** The merge commit cannot be cleanly created. */
  Dirty = 'DIRTY',
  /**
   * The merge is blocked due to the pull request being a draft.
   * @deprecated DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.
   */
  Draft = 'DRAFT',
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = 'HAS_HOOKS',
  /** The state cannot currently be determined. */
  Unknown = 'UNKNOWN',
  /** Mergeable with non-passing commit status. */
  Unstable = 'UNSTABLE'
}

/** Whether or not a PullRequest can be merged. */
enum MergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = 'CONFLICTING',
  /** The pull request can be merged. */
  Mergeable = 'MERGEABLE',
  /** The mergeability of the pull request is still being calculated. */
  Unknown = 'UNKNOWN'
}

/** Represents a 'merged' event on a given pull request. */
type MergedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the commit associated with the `merge` event. */
  readonly commit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the Ref associated with the `merge` event. */
  readonly mergeRef?: Maybe<Ref>;
  /** Identifies the name of the Ref associated with the `merge` event. */
  readonly mergeRefName: Scalars['String']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** The HTTP path for this merged event. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this merged event. */
  readonly url: Scalars['URI']['output'];
};

/** Represents a GitHub Enterprise Importer (GEI) migration. */
type Migration = {
  /** The migration flag to continue on error. */
  readonly continueOnError: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the migration failed. */
  readonly failureReason?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  readonly migrationLogUrl?: Maybe<Scalars['URI']['output']>;
  /** The migration source. */
  readonly migrationSource: MigrationSource;
  /** The target repository name. */
  readonly repositoryName: Scalars['String']['output'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  readonly sourceUrl: Scalars['URI']['output'];
  /** The migration state. */
  readonly state: MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  readonly warningsCount: Scalars['Int']['output'];
};

/** A GitHub Enterprise Importer (GEI) migration source. */
type MigrationSource = Node & {
  readonly id: Scalars['ID']['output'];
  /** The migration source name. */
  readonly name: Scalars['String']['output'];
  /** The migration source type. */
  readonly type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  readonly url: Scalars['URI']['output'];
};

/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */
enum MigrationSourceType {
  /** An Azure DevOps migration source. */
  AzureDevops = 'AZURE_DEVOPS',
  /** A Bitbucket Server migration source. */
  BitbucketServer = 'BITBUCKET_SERVER',
  /** A GitHub Migration API source. */
  GithubArchive = 'GITHUB_ARCHIVE'
}

/** The GitHub Enterprise Importer (GEI) migration state. */
enum MigrationState {
  /** The migration has failed. */
  Failed = 'FAILED',
  /** The migration has invalid credentials. */
  FailedValidation = 'FAILED_VALIDATION',
  /** The migration is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The migration has not started. */
  NotStarted = 'NOT_STARTED',
  /** The migration needs to have its credentials validated. */
  PendingValidation = 'PENDING_VALIDATION',
  /** The migration has been queued. */
  Queued = 'QUEUED',
  /** The migration has succeeded. */
  Succeeded = 'SUCCEEDED'
}

/** Represents a Milestone object on a given repository. */
type Milestone = Closable & Node & UniformResourceLocatable & {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the actor who created the milestone. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the description of the milestone. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** Identifies the due date of the milestone. */
  readonly dueOn?: Maybe<Scalars['DateTime']['output']>;
  readonly id: Scalars['ID']['output'];
  /** A list of issues associated with the milestone. */
  readonly issues: IssueConnection;
  /** Identifies the number of the milestone. */
  readonly number: Scalars['Int']['output'];
  /** Identifies the percentage complete for the milestone */
  readonly progressPercentage: Scalars['Float']['output'];
  /** A list of pull requests associated with the milestone. */
  readonly pullRequests: PullRequestConnection;
  /** The repository associated with this milestone. */
  readonly repository: Repository;
  /** The HTTP path for this milestone */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the state of the milestone. */
  readonly state: MilestoneState;
  /** Identifies the title of the milestone. */
  readonly title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this milestone */
  readonly url: Scalars['URI']['output'];
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
};


/** Represents a Milestone object on a given repository. */
type MilestoneIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<IssueState>>;
};


/** Represents a Milestone object on a given repository. */
type MilestonePullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<PullRequestState>>;
};

/** The connection type for Milestone. */
type MilestoneConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MilestoneEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Milestone>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type MilestoneEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Milestone>;
};

/** Types that can be inside a Milestone. */
type MilestoneItem = Issue | PullRequest;

/** Ordering options for milestone connections. */
type MilestoneOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order milestones by. */
  readonly field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
enum MilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order milestones by when they are due. */
  DueDate = 'DUE_DATE',
  /** Order milestones by their number. */
  Number = 'NUMBER',
  /** Order milestones by when they were last updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of a milestone. */
enum MilestoneState {
  /** A milestone that has been closed. */
  Closed = 'CLOSED',
  /** A milestone that is still open. */
  Open = 'OPEN'
}

/** Represents a 'milestoned' event on a given issue or pull request. */
type MilestonedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  readonly milestoneTitle: Scalars['String']['output'];
  /** Object referenced by event. */
  readonly subject: MilestoneItem;
};

/** Entities that can be minimized. */
type Minimizable = {
  /** Returns whether or not a comment has been minimized. */
  readonly isMinimized: Scalars['Boolean']['output'];
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  readonly minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Check if the current viewer can minimize this object. */
  readonly viewerCanMinimize: Scalars['Boolean']['output'];
};

/** Autogenerated input type of MinimizeComment */
type MinimizeCommentInput = {
  /** The classification of comment */
  readonly classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of MinimizeComment */
type MinimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The comment that was minimized. */
  readonly minimizedComment?: Maybe<Minimizable>;
};

/** Autogenerated input type of MoveProjectCard */
type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  readonly afterCardId?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the card to move. */
  readonly cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move it into. */
  readonly columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveProjectCard */
type MoveProjectCardPayload = {
  /** The new edge of the moved card. */
  readonly cardEdge?: Maybe<ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of MoveProjectColumn */
type MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  readonly afterColumnId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move. */
  readonly columnId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveProjectColumn */
type MoveProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new edge of the moved column. */
  readonly columnEdge?: Maybe<ProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
type MovedColumnsInProjectEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Column name the issue or pull request was moved from. */
  readonly previousProjectColumnName: Scalars['String']['output'];
  /** Project referenced by event. */
  readonly project?: Maybe<Project>;
  /** Project card referenced by this project event. */
  readonly projectCard?: Maybe<ProjectCard>;
  /** Column name the issue or pull request was moved to. */
  readonly projectColumnName: Scalars['String']['output'];
};

/** The root query for implementing GraphQL mutations. */
type Mutation = {
  /** Clear all of a customer's queued migrations */
  readonly abortQueuedMigrations?: Maybe<AbortQueuedMigrationsPayload>;
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  readonly acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  readonly acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  readonly addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  readonly addComment?: Maybe<AddCommentPayload>;
  /** Adds a comment to a Discussion, possibly as a reply to another comment. */
  readonly addDiscussionComment?: Maybe<AddDiscussionCommentPayload>;
  /** Vote for an option in a discussion poll. */
  readonly addDiscussionPollVote?: Maybe<AddDiscussionPollVotePayload>;
  /** Adds enterprise members to an organization within the enterprise. */
  readonly addEnterpriseOrganizationMember?: Maybe<AddEnterpriseOrganizationMemberPayload>;
  /** Adds a support entitlement to an enterprise member. */
  readonly addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>;
  /** Adds labels to a labelable object. */
  readonly addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  readonly addProjectCard?: Maybe<AddProjectCardPayload>;
  /** Adds a column to a Project. */
  readonly addProjectColumn?: Maybe<AddProjectColumnPayload>;
  /** Creates a new draft issue and add it to a Project. */
  readonly addProjectV2DraftIssue?: Maybe<AddProjectV2DraftIssuePayload>;
  /** Links an existing content instance to a Project. */
  readonly addProjectV2ItemById?: Maybe<AddProjectV2ItemByIdPayload>;
  /** Adds a review to a Pull Request. */
  readonly addPullRequestReview?: Maybe<AddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  readonly addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  readonly addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>;
  /** Adds a reply to an existing Pull Request Review Thread. */
  readonly addPullRequestReviewThreadReply?: Maybe<AddPullRequestReviewThreadReplyPayload>;
  /** Adds a reaction to a subject. */
  readonly addReaction?: Maybe<AddReactionPayload>;
  /** Adds a star to a Starrable. */
  readonly addStar?: Maybe<AddStarPayload>;
  /** Add an upvote to a discussion or discussion comment. */
  readonly addUpvote?: Maybe<AddUpvotePayload>;
  /** Adds a verifiable domain to an owning account. */
  readonly addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>;
  /** Approve all pending deployments under one or more environments */
  readonly approveDeployments?: Maybe<ApproveDeploymentsPayload>;
  /** Approve a verifiable domain for notification delivery. */
  readonly approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>;
  /** Archives a ProjectV2Item */
  readonly archiveProjectV2Item?: Maybe<ArchiveProjectV2ItemPayload>;
  /** Marks a repository as archived. */
  readonly archiveRepository?: Maybe<ArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  readonly cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>;
  /** Cancel an active sponsorship. */
  readonly cancelSponsorship?: Maybe<CancelSponsorshipPayload>;
  /** Update your status on GitHub. */
  readonly changeUserStatus?: Maybe<ChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  readonly clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>;
  /**
   * This mutation clears the value of a field for an item in a Project. Currently
   * only text, number, date, assignees, labels, single-select, iteration and
   * milestone fields are supported.
   */
  readonly clearProjectV2ItemFieldValue?: Maybe<ClearProjectV2ItemFieldValuePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  readonly cloneProject?: Maybe<CloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  readonly cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>;
  /** Close a discussion. */
  readonly closeDiscussion?: Maybe<CloseDiscussionPayload>;
  /** Close an issue. */
  readonly closeIssue?: Maybe<CloseIssuePayload>;
  /** Close a pull request. */
  readonly closePullRequest?: Maybe<ClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  readonly convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>;
  /** Converts a pull request to draft */
  readonly convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>;
  /** Copy a project. */
  readonly copyProjectV2?: Maybe<CopyProjectV2Payload>;
  /** Invites a user to claim reattributable data */
  readonly createAttributionInvitation?: Maybe<CreateAttributionInvitationPayload>;
  /** Create a new branch protection rule */
  readonly createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>;
  /** Create a check run. */
  readonly createCheckRun?: Maybe<CreateCheckRunPayload>;
  /** Create a check suite */
  readonly createCheckSuite?: Maybe<CreateCheckSuitePayload>;
  /**
   * Appends a commit to the given branch as the authenticated user.
   *
   * This mutation creates a commit whose parent is the HEAD of the provided
   * branch and also updates that branch to point to the new commit.
   * It can be thought of as similar to `git commit`.
   *
   * ### Locating a Branch
   *
   * Commits are appended to a `branch` of type `Ref`.
   * This must refer to a git branch (i.e.  the fully qualified path must
   * begin with `refs/heads/`, although including this prefix is optional.
   *
   * Callers may specify the `branch` to commit to either by its global node
   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For
   * more details see the documentation for `CommittableBranch`.
   *
   * ### Describing Changes
   *
   * `fileChanges` are specified as a `FilesChanges` object describing
   * `FileAdditions` and `FileDeletions`.
   *
   * Please see the documentation for `FileChanges` for more information on
   * how to use this argument to describe any set of file changes.
   *
   * ### Authorship
   *
   * Similar to the web commit interface, this mutation does not support
   * specifying the author or committer of the commit and will not add
   * support for this in the future.
   *
   * A commit created by a successful execution of this mutation will be
   * authored by the owner of the credential which authenticates the API
   * request.  The committer will be identical to that of commits authored
   * using the web interface.
   *
   * If you need full control over author and committer information, please
   * use the Git Database REST API instead.
   *
   * ### Commit Signing
   *
   * Commits made using this mutation are automatically signed by GitHub if
   * supported and will be marked as verified in the user interface.
   */
  readonly createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>;
  /** Creates a new deployment event. */
  readonly createDeployment?: Maybe<CreateDeploymentPayload>;
  /** Create a deployment status. */
  readonly createDeploymentStatus?: Maybe<CreateDeploymentStatusPayload>;
  /** Create a discussion. */
  readonly createDiscussion?: Maybe<CreateDiscussionPayload>;
  /** Creates an organization as part of an enterprise account. */
  readonly createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>;
  /** Creates an environment or simply returns it if already exists. */
  readonly createEnvironment?: Maybe<CreateEnvironmentPayload>;
  /** Creates a new IP allow list entry. */
  readonly createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  readonly createIssue?: Maybe<CreateIssuePayload>;
  /** Creates a new label. */
  readonly createLabel?: Maybe<CreateLabelPayload>;
  /** Create a branch linked to an issue. */
  readonly createLinkedBranch?: Maybe<CreateLinkedBranchPayload>;
  /** Creates a GitHub Enterprise Importer (GEI) migration source. */
  readonly createMigrationSource?: Maybe<CreateMigrationSourcePayload>;
  /** Creates a new project. */
  readonly createProject?: Maybe<CreateProjectPayload>;
  /** Creates a new project. */
  readonly createProjectV2?: Maybe<CreateProjectV2Payload>;
  /** Create a new project field. */
  readonly createProjectV2Field?: Maybe<CreateProjectV2FieldPayload>;
  /** Create a new pull request */
  readonly createPullRequest?: Maybe<CreatePullRequestPayload>;
  /** Create a new Git Ref. */
  readonly createRef?: Maybe<CreateRefPayload>;
  /** Create a new repository. */
  readonly createRepository?: Maybe<CreateRepositoryPayload>;
  /** Create a repository ruleset */
  readonly createRepositoryRuleset?: Maybe<CreateRepositoryRulesetPayload>;
  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */
  readonly createSponsorsListing?: Maybe<CreateSponsorsListingPayload>;
  /** Create a new payment tier for your GitHub Sponsors profile. */
  readonly createSponsorsTier?: Maybe<CreateSponsorsTierPayload>;
  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */
  readonly createSponsorship?: Maybe<CreateSponsorshipPayload>;
  /**
   * Make many one-time sponsorships for different sponsorable users or
   * organizations at once. Can only sponsor those who have a public GitHub
   * Sponsors profile.
   */
  readonly createSponsorships?: Maybe<CreateSponsorshipsPayload>;
  /** Creates a new team discussion. */
  readonly createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  readonly createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>;
  /** Rejects a suggested topic for the repository. */
  readonly declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  readonly deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  readonly deleteDeployment?: Maybe<DeleteDeploymentPayload>;
  /** Delete a discussion and all of its replies. */
  readonly deleteDiscussion?: Maybe<DeleteDiscussionPayload>;
  /** Delete a discussion comment. If it has replies, wipe it instead. */
  readonly deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>;
  /** Deletes an environment */
  readonly deleteEnvironment?: Maybe<DeleteEnvironmentPayload>;
  /** Deletes an IP allow list entry. */
  readonly deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  readonly deleteIssue?: Maybe<DeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  readonly deleteIssueComment?: Maybe<DeleteIssueCommentPayload>;
  /** Deletes a label. */
  readonly deleteLabel?: Maybe<DeleteLabelPayload>;
  /** Unlink a branch from an issue. */
  readonly deleteLinkedBranch?: Maybe<DeleteLinkedBranchPayload>;
  /** Delete a package version. */
  readonly deletePackageVersion?: Maybe<DeletePackageVersionPayload>;
  /** Deletes a project. */
  readonly deleteProject?: Maybe<DeleteProjectPayload>;
  /** Deletes a project card. */
  readonly deleteProjectCard?: Maybe<DeleteProjectCardPayload>;
  /** Deletes a project column. */
  readonly deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>;
  /** Delete a project. */
  readonly deleteProjectV2?: Maybe<DeleteProjectV2Payload>;
  /** Delete a project field. */
  readonly deleteProjectV2Field?: Maybe<DeleteProjectV2FieldPayload>;
  /** Deletes an item from a Project. */
  readonly deleteProjectV2Item?: Maybe<DeleteProjectV2ItemPayload>;
  /** Deletes a project workflow. */
  readonly deleteProjectV2Workflow?: Maybe<DeleteProjectV2WorkflowPayload>;
  /** Deletes a pull request review. */
  readonly deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  readonly deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  readonly deleteRef?: Maybe<DeleteRefPayload>;
  /** Delete a repository ruleset */
  readonly deleteRepositoryRuleset?: Maybe<DeleteRepositoryRulesetPayload>;
  /** Deletes a team discussion. */
  readonly deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  readonly deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>;
  /** Deletes a verifiable domain. */
  readonly deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>;
  /** Remove a pull request from the merge queue. */
  readonly dequeuePullRequest?: Maybe<DequeuePullRequestPayload>;
  /** Disable auto merge on the given pull request */
  readonly disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>;
  /** Dismisses an approved or rejected pull request review. */
  readonly dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>;
  /** Dismisses the Dependabot alert. */
  readonly dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>;
  /** Enable the default auto-merge on a pull request. */
  readonly enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>;
  /** Add a pull request to the merge queue. */
  readonly enqueuePullRequest?: Maybe<EnqueuePullRequestPayload>;
  /** Follow an organization. */
  readonly followOrganization?: Maybe<FollowOrganizationPayload>;
  /** Follow a user. */
  readonly followUser?: Maybe<FollowUserPayload>;
  /** Grant the migrator role to a user for all organizations under an enterprise account. */
  readonly grantEnterpriseOrganizationsMigratorRole?: Maybe<GrantEnterpriseOrganizationsMigratorRolePayload>;
  /** Grant the migrator role to a user or a team. */
  readonly grantMigratorRole?: Maybe<GrantMigratorRolePayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  readonly importProject?: Maybe<ImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  readonly inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>;
  /** Links a project to a repository. */
  readonly linkProjectV2ToRepository?: Maybe<LinkProjectV2ToRepositoryPayload>;
  /** Links a project to a team. */
  readonly linkProjectV2ToTeam?: Maybe<LinkProjectV2ToTeamPayload>;
  /** Creates a repository link for a project. */
  readonly linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  readonly lockLockable?: Maybe<LockLockablePayload>;
  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */
  readonly markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>;
  /** Mark a pull request file as viewed */
  readonly markFileAsViewed?: Maybe<MarkFileAsViewedPayload>;
  /** Mark a project as a template. Note that only projects which are owned by an Organization can be marked as a template. */
  readonly markProjectV2AsTemplate?: Maybe<MarkProjectV2AsTemplatePayload>;
  /** Marks a pull request ready for review. */
  readonly markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  readonly mergeBranch?: Maybe<MergeBranchPayload>;
  /** Merge a pull request. */
  readonly mergePullRequest?: Maybe<MergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  readonly minimizeComment?: Maybe<MinimizeCommentPayload>;
  /** Moves a project card to another place. */
  readonly moveProjectCard?: Maybe<MoveProjectCardPayload>;
  /** Moves a project column to another place. */
  readonly moveProjectColumn?: Maybe<MoveProjectColumnPayload>;
  /** Pin an issue to a repository */
  readonly pinIssue?: Maybe<PinIssuePayload>;
  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */
  readonly publishSponsorsTier?: Maybe<PublishSponsorsTierPayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  readonly regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Regenerates a verifiable domain's verification token. */
  readonly regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>;
  /** Reject all pending deployments under one or more environments */
  readonly rejectDeployments?: Maybe<RejectDeploymentsPayload>;
  /** Removes assignees from an assignable object. */
  readonly removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  readonly removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>;
  /** Removes the identity provider from an enterprise */
  readonly removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>;
  /** Removes a user from all organizations within the enterprise */
  readonly removeEnterpriseMember?: Maybe<RemoveEnterpriseMemberPayload>;
  /** Removes an organization from the enterprise */
  readonly removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>;
  /** Removes a support entitlement from an enterprise member. */
  readonly removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>;
  /** Removes labels from a Labelable object. */
  readonly removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  readonly removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  readonly removeReaction?: Maybe<RemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  readonly removeStar?: Maybe<RemoveStarPayload>;
  /** Remove an upvote to a discussion or discussion comment. */
  readonly removeUpvote?: Maybe<RemoveUpvotePayload>;
  /** Reopen a discussion. */
  readonly reopenDiscussion?: Maybe<ReopenDiscussionPayload>;
  /** Reopen a issue. */
  readonly reopenIssue?: Maybe<ReopenIssuePayload>;
  /** Reopen a pull request. */
  readonly reopenPullRequest?: Maybe<ReopenPullRequestPayload>;
  /** Set review requests on a pull request. */
  readonly requestReviews?: Maybe<RequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  readonly rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  readonly resolveReviewThread?: Maybe<ResolveReviewThreadPayload>;
  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */
  readonly retireSponsorsTier?: Maybe<RetireSponsorsTierPayload>;
  /** Create a pull request that reverts the changes from a merged pull request. */
  readonly revertPullRequest?: Maybe<RevertPullRequestPayload>;
  /** Revoke the migrator role to a user for all organizations under an enterprise account. */
  readonly revokeEnterpriseOrganizationsMigratorRole?: Maybe<RevokeEnterpriseOrganizationsMigratorRolePayload>;
  /** Revoke the migrator role from a user or a team. */
  readonly revokeMigratorRole?: Maybe<RevokeMigratorRolePayload>;
  /** Creates or updates the identity provider for an enterprise. */
  readonly setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>;
  /** Set an organization level interaction limit for an organization's public repositories. */
  readonly setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>;
  /** Sets an interaction limit setting for a repository. */
  readonly setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>;
  /** Set a user level interaction limit for an user's public repositories. */
  readonly setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>;
  /** Starts a GitHub Enterprise Importer organization migration. */
  readonly startOrganizationMigration?: Maybe<StartOrganizationMigrationPayload>;
  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */
  readonly startRepositoryMigration?: Maybe<StartRepositoryMigrationPayload>;
  /** Submits a pending pull request review. */
  readonly submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>;
  /** Transfer an organization from one enterprise to another enterprise. */
  readonly transferEnterpriseOrganization?: Maybe<TransferEnterpriseOrganizationPayload>;
  /** Transfer an issue to a different repository */
  readonly transferIssue?: Maybe<TransferIssuePayload>;
  /** Unarchives a ProjectV2Item */
  readonly unarchiveProjectV2Item?: Maybe<UnarchiveProjectV2ItemPayload>;
  /** Unarchives a repository. */
  readonly unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>;
  /** Unfollow an organization. */
  readonly unfollowOrganization?: Maybe<UnfollowOrganizationPayload>;
  /** Unfollow a user. */
  readonly unfollowUser?: Maybe<UnfollowUserPayload>;
  /** Unlinks a project from a repository. */
  readonly unlinkProjectV2FromRepository?: Maybe<UnlinkProjectV2FromRepositoryPayload>;
  /** Unlinks a project to a team. */
  readonly unlinkProjectV2FromTeam?: Maybe<UnlinkProjectV2FromTeamPayload>;
  /** Deletes a repository link from a project. */
  readonly unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  readonly unlockLockable?: Maybe<UnlockLockablePayload>;
  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */
  readonly unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>;
  /** Unmark a pull request file as viewed */
  readonly unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>;
  /** Unmark an issue as a duplicate of another issue. */
  readonly unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>;
  /** Unmark a project as a template. */
  readonly unmarkProjectV2AsTemplate?: Maybe<UnmarkProjectV2AsTemplatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  readonly unminimizeComment?: Maybe<UnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  readonly unpinIssue?: Maybe<UnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  readonly unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>;
  /** Update a branch protection rule */
  readonly updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>;
  /** Update a check run */
  readonly updateCheckRun?: Maybe<UpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  readonly updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>;
  /** Update a discussion */
  readonly updateDiscussion?: Maybe<UpdateDiscussionPayload>;
  /** Update the contents of a comment on a Discussion */
  readonly updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>;
  /** Updates the role of an enterprise administrator. */
  readonly updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  readonly updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the base repository permission for organizations in an enterprise. */
  readonly updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  readonly updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  readonly updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  readonly updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  readonly updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  readonly updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization admin can make purchases. */
  readonly updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  readonly updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  readonly updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  readonly updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates the role of an enterprise owner with an organization. */
  readonly updateEnterpriseOwnerOrganizationRole?: Maybe<UpdateEnterpriseOwnerOrganizationRolePayload>;
  /** Updates an enterprise's profile. */
  readonly updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  readonly updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  readonly updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  readonly updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Updates an environment. */
  readonly updateEnvironment?: Maybe<UpdateEnvironmentPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  readonly updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  readonly updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>;
  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */
  readonly updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;
  /** Updates an Issue. */
  readonly updateIssue?: Maybe<UpdateIssuePayload>;
  /** Updates an IssueComment object. */
  readonly updateIssueComment?: Maybe<UpdateIssueCommentPayload>;
  /** Updates an existing label. */
  readonly updateLabel?: Maybe<UpdateLabelPayload>;
  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */
  readonly updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>;
  /** Sets whether private repository forks are enabled for an organization. */
  readonly updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */
  readonly updateOrganizationWebCommitSignoffSetting?: Maybe<UpdateOrganizationWebCommitSignoffSettingPayload>;
  /** Updates an existing project. */
  readonly updateProject?: Maybe<UpdateProjectPayload>;
  /** Updates an existing project card. */
  readonly updateProjectCard?: Maybe<UpdateProjectCardPayload>;
  /** Updates an existing project column. */
  readonly updateProjectColumn?: Maybe<UpdateProjectColumnPayload>;
  /** Updates an existing project (beta). */
  readonly updateProjectV2?: Maybe<UpdateProjectV2Payload>;
  /** Update the collaborators on a team or a project */
  readonly updateProjectV2Collaborators?: Maybe<UpdateProjectV2CollaboratorsPayload>;
  /** Updates a draft issue within a Project. */
  readonly updateProjectV2DraftIssue?: Maybe<UpdateProjectV2DraftIssuePayload>;
  /**
   * This mutation updates the value of a field for an item in a Project. Currently
   * only single-select, text, number, date, and iteration fields are supported.
   */
  readonly updateProjectV2ItemFieldValue?: Maybe<UpdateProjectV2ItemFieldValuePayload>;
  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */
  readonly updateProjectV2ItemPosition?: Maybe<UpdateProjectV2ItemPositionPayload>;
  /** Update a pull request */
  readonly updatePullRequest?: Maybe<UpdatePullRequestPayload>;
  /** Merge or Rebase HEAD from upstream branch into pull request branch */
  readonly updatePullRequestBranch?: Maybe<UpdatePullRequestBranchPayload>;
  /** Updates the body of a pull request review. */
  readonly updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  readonly updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  readonly updateRef?: Maybe<UpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   *
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   *
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   *
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   *
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  readonly updateRefs?: Maybe<UpdateRefsPayload>;
  /** Update information about a repository. */
  readonly updateRepository?: Maybe<UpdateRepositoryPayload>;
  /** Update a repository ruleset */
  readonly updateRepositoryRuleset?: Maybe<UpdateRepositoryRulesetPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for a repository. */
  readonly updateRepositoryWebCommitSignoffSetting?: Maybe<UpdateRepositoryWebCommitSignoffSettingPayload>;
  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */
  readonly updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>;
  /** Updates the state for subscribable subjects. */
  readonly updateSubscription?: Maybe<UpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  readonly updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  readonly updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  readonly updateTeamReviewAssignment?: Maybe<UpdateTeamReviewAssignmentPayload>;
  /** Update team repository. */
  readonly updateTeamsRepository?: Maybe<UpdateTeamsRepositoryPayload>;
  /** Replaces the repository's topics with the given topics. */
  readonly updateTopics?: Maybe<UpdateTopicsPayload>;
  /** Verify that a verifiable domain has the expected DNS record. */
  readonly verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>;
};


/** The root query for implementing GraphQL mutations. */
type MutationAbortQueuedMigrationsArgs = {
  input: AbortQueuedMigrationsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAcceptEnterpriseAdministratorInvitationArgs = {
  input: AcceptEnterpriseAdministratorInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAcceptTopicSuggestionArgs = {
  input: AcceptTopicSuggestionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddAssigneesToAssignableArgs = {
  input: AddAssigneesToAssignableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddCommentArgs = {
  input: AddCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddDiscussionCommentArgs = {
  input: AddDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddDiscussionPollVoteArgs = {
  input: AddDiscussionPollVoteInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddEnterpriseOrganizationMemberArgs = {
  input: AddEnterpriseOrganizationMemberInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddEnterpriseSupportEntitlementArgs = {
  input: AddEnterpriseSupportEntitlementInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddLabelsToLabelableArgs = {
  input: AddLabelsToLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddProjectCardArgs = {
  input: AddProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddProjectColumnArgs = {
  input: AddProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddProjectV2DraftIssueArgs = {
  input: AddProjectV2DraftIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddProjectV2ItemByIdArgs = {
  input: AddProjectV2ItemByIdInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddPullRequestReviewArgs = {
  input: AddPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddPullRequestReviewCommentArgs = {
  input: AddPullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddPullRequestReviewThreadArgs = {
  input: AddPullRequestReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddPullRequestReviewThreadReplyArgs = {
  input: AddPullRequestReviewThreadReplyInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddReactionArgs = {
  input: AddReactionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddStarArgs = {
  input: AddStarInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddUpvoteArgs = {
  input: AddUpvoteInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationAddVerifiableDomainArgs = {
  input: AddVerifiableDomainInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationApproveDeploymentsArgs = {
  input: ApproveDeploymentsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationApproveVerifiableDomainArgs = {
  input: ApproveVerifiableDomainInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationArchiveProjectV2ItemArgs = {
  input: ArchiveProjectV2ItemInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationArchiveRepositoryArgs = {
  input: ArchiveRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCancelEnterpriseAdminInvitationArgs = {
  input: CancelEnterpriseAdminInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCancelSponsorshipArgs = {
  input: CancelSponsorshipInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationChangeUserStatusArgs = {
  input: ChangeUserStatusInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationClearLabelsFromLabelableArgs = {
  input: ClearLabelsFromLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationClearProjectV2ItemFieldValueArgs = {
  input: ClearProjectV2ItemFieldValueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCloneProjectArgs = {
  input: CloneProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCloneTemplateRepositoryArgs = {
  input: CloneTemplateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCloseDiscussionArgs = {
  input: CloseDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCloseIssueArgs = {
  input: CloseIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationClosePullRequestArgs = {
  input: ClosePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationConvertProjectCardNoteToIssueArgs = {
  input: ConvertProjectCardNoteToIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationConvertPullRequestToDraftArgs = {
  input: ConvertPullRequestToDraftInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCopyProjectV2Args = {
  input: CopyProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateAttributionInvitationArgs = {
  input: CreateAttributionInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateBranchProtectionRuleArgs = {
  input: CreateBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateCheckRunArgs = {
  input: CreateCheckRunInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateCheckSuiteArgs = {
  input: CreateCheckSuiteInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateCommitOnBranchArgs = {
  input: CreateCommitOnBranchInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateDeploymentArgs = {
  input: CreateDeploymentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateDeploymentStatusArgs = {
  input: CreateDeploymentStatusInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateDiscussionArgs = {
  input: CreateDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateEnterpriseOrganizationArgs = {
  input: CreateEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateEnvironmentArgs = {
  input: CreateEnvironmentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateIpAllowListEntryArgs = {
  input: CreateIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateIssueArgs = {
  input: CreateIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateLabelArgs = {
  input: CreateLabelInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateLinkedBranchArgs = {
  input: CreateLinkedBranchInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateMigrationSourceArgs = {
  input: CreateMigrationSourceInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateProjectV2Args = {
  input: CreateProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateProjectV2FieldArgs = {
  input: CreateProjectV2FieldInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreatePullRequestArgs = {
  input: CreatePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateRefArgs = {
  input: CreateRefInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateRepositoryArgs = {
  input: CreateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateRepositoryRulesetArgs = {
  input: CreateRepositoryRulesetInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateSponsorsListingArgs = {
  input: CreateSponsorsListingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateSponsorsTierArgs = {
  input: CreateSponsorsTierInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateSponsorshipArgs = {
  input: CreateSponsorshipInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateSponsorshipsArgs = {
  input: CreateSponsorshipsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateTeamDiscussionArgs = {
  input: CreateTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationCreateTeamDiscussionCommentArgs = {
  input: CreateTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeclineTopicSuggestionArgs = {
  input: DeclineTopicSuggestionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteBranchProtectionRuleArgs = {
  input: DeleteBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteDeploymentArgs = {
  input: DeleteDeploymentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteDiscussionArgs = {
  input: DeleteDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteDiscussionCommentArgs = {
  input: DeleteDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteEnvironmentArgs = {
  input: DeleteEnvironmentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteIpAllowListEntryArgs = {
  input: DeleteIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteIssueArgs = {
  input: DeleteIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteIssueCommentArgs = {
  input: DeleteIssueCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteLabelArgs = {
  input: DeleteLabelInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteLinkedBranchArgs = {
  input: DeleteLinkedBranchInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeletePackageVersionArgs = {
  input: DeletePackageVersionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectArgs = {
  input: DeleteProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectCardArgs = {
  input: DeleteProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectColumnArgs = {
  input: DeleteProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectV2Args = {
  input: DeleteProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectV2FieldArgs = {
  input: DeleteProjectV2FieldInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectV2ItemArgs = {
  input: DeleteProjectV2ItemInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteProjectV2WorkflowArgs = {
  input: DeleteProjectV2WorkflowInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeletePullRequestReviewArgs = {
  input: DeletePullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeletePullRequestReviewCommentArgs = {
  input: DeletePullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteRefArgs = {
  input: DeleteRefInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteRepositoryRulesetArgs = {
  input: DeleteRepositoryRulesetInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteTeamDiscussionArgs = {
  input: DeleteTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteTeamDiscussionCommentArgs = {
  input: DeleteTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDeleteVerifiableDomainArgs = {
  input: DeleteVerifiableDomainInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDequeuePullRequestArgs = {
  input: DequeuePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDisablePullRequestAutoMergeArgs = {
  input: DisablePullRequestAutoMergeInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDismissPullRequestReviewArgs = {
  input: DismissPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationDismissRepositoryVulnerabilityAlertArgs = {
  input: DismissRepositoryVulnerabilityAlertInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationEnablePullRequestAutoMergeArgs = {
  input: EnablePullRequestAutoMergeInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationEnqueuePullRequestArgs = {
  input: EnqueuePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationFollowOrganizationArgs = {
  input: FollowOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationFollowUserArgs = {
  input: FollowUserInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationGrantEnterpriseOrganizationsMigratorRoleArgs = {
  input: GrantEnterpriseOrganizationsMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationGrantMigratorRoleArgs = {
  input: GrantMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationImportProjectArgs = {
  input: ImportProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationInviteEnterpriseAdminArgs = {
  input: InviteEnterpriseAdminInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationLinkProjectV2ToRepositoryArgs = {
  input: LinkProjectV2ToRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationLinkProjectV2ToTeamArgs = {
  input: LinkProjectV2ToTeamInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationLinkRepositoryToProjectArgs = {
  input: LinkRepositoryToProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationLockLockableArgs = {
  input: LockLockableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMarkDiscussionCommentAsAnswerArgs = {
  input: MarkDiscussionCommentAsAnswerInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMarkFileAsViewedArgs = {
  input: MarkFileAsViewedInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMarkProjectV2AsTemplateArgs = {
  input: MarkProjectV2AsTemplateInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMarkPullRequestReadyForReviewArgs = {
  input: MarkPullRequestReadyForReviewInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMergeBranchArgs = {
  input: MergeBranchInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMergePullRequestArgs = {
  input: MergePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMinimizeCommentArgs = {
  input: MinimizeCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMoveProjectCardArgs = {
  input: MoveProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationMoveProjectColumnArgs = {
  input: MoveProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationPinIssueArgs = {
  input: PinIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationPublishSponsorsTierArgs = {
  input: PublishSponsorsTierInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRegenerateVerifiableDomainTokenArgs = {
  input: RegenerateVerifiableDomainTokenInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRejectDeploymentsArgs = {
  input: RejectDeploymentsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveAssigneesFromAssignableArgs = {
  input: RemoveAssigneesFromAssignableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveEnterpriseAdminArgs = {
  input: RemoveEnterpriseAdminInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveEnterpriseIdentityProviderArgs = {
  input: RemoveEnterpriseIdentityProviderInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveEnterpriseMemberArgs = {
  input: RemoveEnterpriseMemberInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveEnterpriseOrganizationArgs = {
  input: RemoveEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveEnterpriseSupportEntitlementArgs = {
  input: RemoveEnterpriseSupportEntitlementInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveLabelsFromLabelableArgs = {
  input: RemoveLabelsFromLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveOutsideCollaboratorArgs = {
  input: RemoveOutsideCollaboratorInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveReactionArgs = {
  input: RemoveReactionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveStarArgs = {
  input: RemoveStarInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRemoveUpvoteArgs = {
  input: RemoveUpvoteInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationReopenDiscussionArgs = {
  input: ReopenDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationReopenIssueArgs = {
  input: ReopenIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationReopenPullRequestArgs = {
  input: ReopenPullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRequestReviewsArgs = {
  input: RequestReviewsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRerequestCheckSuiteArgs = {
  input: RerequestCheckSuiteInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationResolveReviewThreadArgs = {
  input: ResolveReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRetireSponsorsTierArgs = {
  input: RetireSponsorsTierInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRevertPullRequestArgs = {
  input: RevertPullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRevokeEnterpriseOrganizationsMigratorRoleArgs = {
  input: RevokeEnterpriseOrganizationsMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationRevokeMigratorRoleArgs = {
  input: RevokeMigratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationSetEnterpriseIdentityProviderArgs = {
  input: SetEnterpriseIdentityProviderInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationSetOrganizationInteractionLimitArgs = {
  input: SetOrganizationInteractionLimitInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationSetRepositoryInteractionLimitArgs = {
  input: SetRepositoryInteractionLimitInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationSetUserInteractionLimitArgs = {
  input: SetUserInteractionLimitInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationStartOrganizationMigrationArgs = {
  input: StartOrganizationMigrationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationStartRepositoryMigrationArgs = {
  input: StartRepositoryMigrationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationSubmitPullRequestReviewArgs = {
  input: SubmitPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationTransferEnterpriseOrganizationArgs = {
  input: TransferEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationTransferIssueArgs = {
  input: TransferIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnarchiveProjectV2ItemArgs = {
  input: UnarchiveProjectV2ItemInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnarchiveRepositoryArgs = {
  input: UnarchiveRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnfollowOrganizationArgs = {
  input: UnfollowOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnfollowUserArgs = {
  input: UnfollowUserInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnlinkProjectV2FromRepositoryArgs = {
  input: UnlinkProjectV2FromRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnlinkProjectV2FromTeamArgs = {
  input: UnlinkProjectV2FromTeamInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnlinkRepositoryFromProjectArgs = {
  input: UnlinkRepositoryFromProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnlockLockableArgs = {
  input: UnlockLockableInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnmarkDiscussionCommentAsAnswerArgs = {
  input: UnmarkDiscussionCommentAsAnswerInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnmarkFileAsViewedArgs = {
  input: UnmarkFileAsViewedInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnmarkIssueAsDuplicateArgs = {
  input: UnmarkIssueAsDuplicateInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnmarkProjectV2AsTemplateArgs = {
  input: UnmarkProjectV2AsTemplateInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnminimizeCommentArgs = {
  input: UnminimizeCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnpinIssueArgs = {
  input: UnpinIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUnresolveReviewThreadArgs = {
  input: UnresolveReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateBranchProtectionRuleArgs = {
  input: UpdateBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateCheckRunArgs = {
  input: UpdateCheckRunInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateCheckSuitePreferencesArgs = {
  input: UpdateCheckSuitePreferencesInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateDiscussionArgs = {
  input: UpdateDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateDiscussionCommentArgs = {
  input: UpdateDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseAdministratorRoleArgs = {
  input: UpdateEnterpriseAdministratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseOrganizationProjectsSettingArgs = {
  input: UpdateEnterpriseOrganizationProjectsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseOwnerOrganizationRoleArgs = {
  input: UpdateEnterpriseOwnerOrganizationRoleInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseProfileArgs = {
  input: UpdateEnterpriseProfileInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseRepositoryProjectsSettingArgs = {
  input: UpdateEnterpriseRepositoryProjectsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseTeamDiscussionsSettingArgs = {
  input: UpdateEnterpriseTeamDiscussionsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateEnvironmentArgs = {
  input: UpdateEnvironmentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateIpAllowListEnabledSettingArgs = {
  input: UpdateIpAllowListEnabledSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateIpAllowListEntryArgs = {
  input: UpdateIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs = {
  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateIssueArgs = {
  input: UpdateIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateIssueCommentArgs = {
  input: UpdateIssueCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateLabelArgs = {
  input: UpdateLabelInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateNotificationRestrictionSettingArgs = {
  input: UpdateNotificationRestrictionSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {
  input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateOrganizationWebCommitSignoffSettingArgs = {
  input: UpdateOrganizationWebCommitSignoffSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectArgs = {
  input: UpdateProjectInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectCardArgs = {
  input: UpdateProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectColumnArgs = {
  input: UpdateProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectV2Args = {
  input: UpdateProjectV2Input;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectV2CollaboratorsArgs = {
  input: UpdateProjectV2CollaboratorsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectV2DraftIssueArgs = {
  input: UpdateProjectV2DraftIssueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectV2ItemFieldValueArgs = {
  input: UpdateProjectV2ItemFieldValueInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateProjectV2ItemPositionArgs = {
  input: UpdateProjectV2ItemPositionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdatePullRequestArgs = {
  input: UpdatePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdatePullRequestBranchArgs = {
  input: UpdatePullRequestBranchInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdatePullRequestReviewArgs = {
  input: UpdatePullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdatePullRequestReviewCommentArgs = {
  input: UpdatePullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateRefArgs = {
  input: UpdateRefInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateRefsArgs = {
  input: UpdateRefsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateRepositoryArgs = {
  input: UpdateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateRepositoryRulesetArgs = {
  input: UpdateRepositoryRulesetInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateRepositoryWebCommitSignoffSettingArgs = {
  input: UpdateRepositoryWebCommitSignoffSettingInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateSponsorshipPreferencesArgs = {
  input: UpdateSponsorshipPreferencesInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateTeamDiscussionArgs = {
  input: UpdateTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateTeamDiscussionCommentArgs = {
  input: UpdateTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateTeamReviewAssignmentArgs = {
  input: UpdateTeamReviewAssignmentInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateTeamsRepositoryArgs = {
  input: UpdateTeamsRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationUpdateTopicsArgs = {
  input: UpdateTopicsInput;
};


/** The root query for implementing GraphQL mutations. */
type MutationVerifyVerifiableDomainArgs = {
  input: VerifyVerifiableDomainInput;
};

/** An object with an ID. */
type Node = {
  /** ID of the object. */
  readonly id: Scalars['ID']['output'];
};

/** The possible values for the notification restriction setting. */
enum NotificationRestrictionSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
type OidcProvider = Node & {
  /** The enterprise this identity provider belongs to. */
  readonly enterprise?: Maybe<Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  readonly externalIdentities: ExternalIdentityConnection;
  readonly id: Scalars['ID']['output'];
  /** The OIDC identity provider type */
  readonly providerType: OidcProviderType;
  /** The id of the tenant this provider is attached to */
  readonly tenantId: Scalars['String']['output'];
};


/**
 * An OIDC identity provider configured to provision identities for an enterprise.
 * Visible to enterprise owners or enterprise owners' personal access tokens
 * (classic) with read:enterprise or admin:enterprise scope.
 */
type OidcProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** The OIDC identity provider type */
enum OidcProviderType {
  /** Azure Active Directory */
  Aad = 'AAD'
}

/** Metadata for an audit entry with action oauth_application.* */
type OauthApplicationAuditEntryData = {
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a oauth_application.create event. */
type OauthApplicationCreateAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The application URL of the OAuth application. */
  readonly applicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The callback URL of the OAuth application. */
  readonly callbackUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The rate limit of the OAuth application. */
  readonly rateLimit?: Maybe<Scalars['Int']['output']>;
  /** The state of the OAuth application. */
  readonly state?: Maybe<OauthApplicationCreateAuditEntryState>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The state of an OAuth application when it was created. */
enum OauthApplicationCreateAuditEntryState {
  /** The OAuth application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION',
  /** The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED'
}

/** The corresponding operation type for the action */
enum OperationType {
  /** An existing resource was accessed */
  Access = 'ACCESS',
  /** A resource performed an authentication event */
  Authentication = 'AUTHENTICATION',
  /** A new resource was created */
  Create = 'CREATE',
  /** An existing resource was modified */
  Modify = 'MODIFY',
  /** An existing resource was removed */
  Remove = 'REMOVE',
  /** An existing resource was restored */
  Restore = 'RESTORE',
  /** An existing resource was transferred between multiple resources */
  Transfer = 'TRANSFER'
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/** Audit log entry for a org.add_billing_manager */
type OrgAddBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The email address used to invite a billing manager for the organization. */
  readonly invitationEmail?: Maybe<Scalars['String']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.add_member */
type OrgAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The permission level of the member added to the organization. */
  readonly permission?: Maybe<OrgAddMemberAuditEntryPermission>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The permissions available to members on an Organization. */
enum OrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}

/** Audit log entry for a org.block_user */
type OrgBlockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The blocked user. */
  readonly blockedUser?: Maybe<User>;
  /** The username of the blocked user. */
  readonly blockedUserName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the blocked user. */
  readonly blockedUserResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the blocked user. */
  readonly blockedUserUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.create event. */
type OrgCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The billing plan for the Organization. */
  readonly billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The billing plans available for organizations. */
enum OrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = 'BUSINESS',
  /** Enterprise Cloud Plan */
  BusinessPlus = 'BUSINESS_PLUS',
  /** Free Plan */
  Free = 'FREE',
  /** Tiered Per Seat Plan */
  TieredPerSeat = 'TIERED_PER_SEAT',
  /** Legacy Unlimited Plan */
  Unlimited = 'UNLIMITED'
}

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.disable_saml event. */
type OrgDisableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The SAML provider's digest algorithm URL. */
  readonly digestMethodUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The SAML provider's issuer URL. */
  readonly issuerUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's signature algorithm URL. */
  readonly signatureMethodUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's single sign-on URL. */
  readonly singleSignOnUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.enable_saml event. */
type OrgEnableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The SAML provider's digest algorithm URL. */
  readonly digestMethodUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The SAML provider's issuer URL. */
  readonly issuerUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's signature algorithm URL. */
  readonly signatureMethodUrl?: Maybe<Scalars['URI']['output']>;
  /** The SAML provider's single sign-on URL. */
  readonly singleSignOnUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Ordering options for an organization's enterprise owner connections. */
type OrgEnterpriseOwnerOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order enterprise owners by. */
  readonly field: OrgEnterpriseOwnerOrderField;
};

/** Properties by which enterprise owners can be ordered. */
enum OrgEnterpriseOwnerOrderField {
  /** Order enterprise owners by login. */
  Login = 'LOGIN'
}

/** Audit log entry for a org.invite_member event. */
type OrgInviteMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The email address of the organization invitation. */
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The organization invitation. */
  readonly organizationInvitation?: Maybe<OrganizationInvitation>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.invite_to_business event. */
type OrgInviteToBusinessAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_approved event. */
type OrgOauthAppAccessApprovedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_blocked event. */
type OrgOauthAppAccessBlockedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_denied event. */
type OrgOauthAppAccessDeniedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_requested event. */
type OrgOauthAppAccessRequestedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.oauth_app_access_unblocked event. */
type OrgOauthAppAccessUnblockedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The name of the OAuth application. */
  readonly oauthApplicationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the OAuth application */
  readonly oauthApplicationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the OAuth application */
  readonly oauthApplicationUrl?: Maybe<Scalars['URI']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.remove_billing_manager event. */
type OrgRemoveBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The reason for the billing manager being removed. */
  readonly reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The reason a billing manager was removed from an Organization. */
enum OrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}

/** Audit log entry for a org.remove_member event. */
type OrgRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The types of membership the member has with the organization. */
  readonly membershipTypes?: Maybe<ReadonlyArray<OrgRemoveMemberAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The reason for the member being removed. */
  readonly reason?: Maybe<OrgRemoveMemberAuditEntryReason>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The type of membership a user has with an Organization. */
enum OrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
   */
  Admin = 'ADMIN',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = 'DIRECT_MEMBER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /** A suspended member. */
  Suspended = 'SUSPENDED',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason a member was removed from an Organization. */
enum OrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** User account has been deleted */
  UserAccountDeleted = 'USER_ACCOUNT_DELETED'
}

/** Audit log entry for a org.remove_outside_collaborator event. */
type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The types of membership the outside collaborator has with the organization. */
  readonly membershipTypes?: Maybe<ReadonlyArray<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The reason for the outside collaborator being removed from the Organization. */
  readonly reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The type of membership a user has with an Organization. */
enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason an outside collaborator was removed from an Organization. */
enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}

/** Audit log entry for a org.restore_member event. */
type OrgRestoreMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The number of custom email routings for the restored member. */
  readonly restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of issue assignments for the restored member. */
  readonly restoredIssueAssignmentsCount?: Maybe<Scalars['Int']['output']>;
  /** Restored organization membership objects. */
  readonly restoredMemberships?: Maybe<ReadonlyArray<OrgRestoreMemberAuditEntryMembership>>;
  /** The number of restored memberships. */
  readonly restoredMembershipsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of repositories of the restored member. */
  readonly restoredRepositoriesCount?: Maybe<Scalars['Int']['output']>;
  /** The number of starred repositories for the restored member. */
  readonly restoredRepositoryStarsCount?: Maybe<Scalars['Int']['output']>;
  /** The number of watched repositories for the restored member. */
  readonly restoredRepositoryWatchesCount?: Maybe<Scalars['Int']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Types of memberships that can be restored for an Organization member. */
type OrgRestoreMemberAuditEntryMembership = OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
type OrgRestoreMemberMembershipOrganizationAuditEntryData = OrganizationAuditEntryData & {
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
};

/** Metadata for a repository membership for org.restore_member actions */
type OrgRestoreMemberMembershipRepositoryAuditEntryData = RepositoryAuditEntryData & {
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
};

/** Metadata for a team membership for org.restore_member actions */
type OrgRestoreMemberMembershipTeamAuditEntryData = TeamAuditEntryData & {
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.unblock_user */
type OrgUnblockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The user being unblocked by the organization. */
  readonly blockedUser?: Maybe<User>;
  /** The username of the blocked user. */
  readonly blockedUserName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the blocked user. */
  readonly blockedUserResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the blocked user. */
  readonly blockedUserUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a org.update_default_repository_permission */
type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The new base repository permission level for the organization. */
  readonly permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The former base repository permission level for the organization. */
  readonly permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The default permission a repository can have in an Organization. */
enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** No default permission value. */
  None = 'NONE',
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone and push to repositories. */
  Write = 'WRITE'
}

/** Audit log entry for a org.update_member event. */
type OrgUpdateMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The new member permission level for the organization. */
  readonly permission?: Maybe<OrgUpdateMemberAuditEntryPermission>;
  /** The former member permission level for the organization. */
  readonly permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The permissions available to members on an Organization. */
enum OrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}

/** Audit log entry for a org.update_member_repository_creation_permission event. */
type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** Can members create repositories in the organization. */
  readonly canCreateRepositories?: Maybe<Scalars['Boolean']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The permission for visibility level of repositories for this organization. */
  readonly visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
};

/** The permissions available for repository creation on an Organization. */
enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = 'ALL',
  /** All organization members are restricted from creating internal repositories. */
  Internal = 'INTERNAL',
  /** All organization members are allowed to create any repositories. */
  None = 'NONE',
  /** All organization members are restricted from creating private repositories. */
  Private = 'PRIVATE',
  /** All organization members are restricted from creating private or internal repositories. */
  PrivateInternal = 'PRIVATE_INTERNAL',
  /** All organization members are restricted from creating public repositories. */
  Public = 'PUBLIC',
  /** All organization members are restricted from creating public or internal repositories. */
  PublicInternal = 'PUBLIC_INTERNAL',
  /** All organization members are restricted from creating public or private repositories. */
  PublicPrivate = 'PUBLIC_PRIVATE'
}

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** Can outside collaborators be invited to repositories in the organization. */
  readonly canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type Organization = Actor & AnnouncementBanner & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {
  /** The text of the announcement */
  readonly announcement?: Maybe<Scalars['String']['output']>;
  /** The expiration date of the announcement, if any */
  readonly announcementExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether the announcement can be dismissed by the user */
  readonly announcementUserDismissible?: Maybe<Scalars['Boolean']['output']>;
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  readonly anyPinnableItems: Scalars['Boolean']['output'];
  /** Audit log entries of the organization */
  readonly auditLog: OrganizationAuditEntryConnection;
  /** A URL pointing to the organization's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The organization's public profile description. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The organization's public profile description rendered to HTML. */
  readonly descriptionHTML?: Maybe<Scalars['String']['output']>;
  /** A list of domains owned by the organization. */
  readonly domains?: Maybe<VerifiableDomainConnection>;
  /** The organization's public email. */
  readonly email?: Maybe<Scalars['String']['output']>;
  /** A list of owners of the organization's enterprise account. */
  readonly enterpriseOwners: OrganizationEnterpriseOwnerConnection;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  readonly estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  readonly hasSponsorsListing: Scalars['Boolean']['output'];
  readonly id: Scalars['ID']['output'];
  /** The interaction ability settings for this organization. */
  readonly interactionAbility?: Maybe<RepositoryInteractionAbility>;
  /** The setting value for whether the organization has an IP allow list enabled. */
  readonly ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the organization. */
  readonly ipAllowListEntries: IpAllowListEntryConnection;
  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */
  readonly ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether the given account is sponsoring this user/organization. */
  readonly isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  readonly isSponsoringViewer: Scalars['Boolean']['output'];
  /** Whether the organization has verified its profile email and website. */
  readonly isVerified: Scalars['Boolean']['output'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  readonly itemShowcase: ProfileItemShowcase;
  /** The organization's public profile location. */
  readonly location?: Maybe<Scalars['String']['output']>;
  /** The organization's login name. */
  readonly login: Scalars['String']['output'];
  /** A list of all mannequins for this organization. */
  readonly mannequins: MannequinConnection;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  readonly memberStatuses: UserStatusConnection;
  /** Members can fork private repositories in this organization */
  readonly membersCanForkPrivateRepositories: Scalars['Boolean']['output'];
  /** A list of users who are members of this organization. */
  readonly membersWithRole: OrganizationMemberConnection;
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  readonly monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** The organization's public profile name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** The HTTP path creating a new team */
  readonly newTeamResourcePath: Scalars['URI']['output'];
  /** The HTTP URL creating a new team */
  readonly newTeamUrl: Scalars['URI']['output'];
  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */
  readonly notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;
  /** The billing email for the organization. */
  readonly organizationBillingEmail?: Maybe<Scalars['String']['output']>;
  /** A list of packages under the owner. */
  readonly packages: PackageConnection;
  /** A list of users who have been invited to join this organization. */
  readonly pendingMembers: UserConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  readonly pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  readonly pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  readonly pinnedItemsRemaining: Scalars['Int']['output'];
  /** Find project by number. */
  readonly project?: Maybe<Project>;
  /** Find a project by number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  readonly projects: ProjectConnection;
  /** The HTTP path listing organization's projects */
  readonly projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing organization's projects */
  readonly projectsUrl: Scalars['URI']['output'];
  /** A list of projects under the owner. */
  readonly projectsV2: ProjectV2Connection;
  /** Recent projects that this user has modified in the context of the owner. */
  readonly recentProjects: ProjectV2Connection;
  /** A list of repositories that the user owns. */
  readonly repositories: RepositoryConnection;
  /** Find Repository. */
  readonly repository?: Maybe<Repository>;
  /** Discussion comments this user has authored. */
  readonly repositoryDiscussionComments: DiscussionCommentConnection;
  /** Discussions this user has started. */
  readonly repositoryDiscussions: DiscussionConnection;
  /** A list of all repository migrations for this organization. */
  readonly repositoryMigrations: RepositoryMigrationConnection;
  /**
   * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
   */
  readonly requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']['output']>;
  /** The HTTP path for this organization. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Returns a single ruleset from the current organization by ID. */
  readonly ruleset?: Maybe<RepositoryRuleset>;
  /** A list of rulesets for this organization. */
  readonly rulesets?: Maybe<RepositoryRulesetConnection>;
  /**
   * The Organization's SAML identity provider. Visible to (1) organization owners,
   * (2) organization owners' personal access tokens (classic) with read:org or
   * admin:org scope, (3) GitHub App with an installation token with read or write
   * access to members.
   */
  readonly samlIdentityProvider?: Maybe<OrganizationIdentityProvider>;
  /** List of users and organizations this entity is sponsoring. */
  readonly sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  readonly sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  readonly sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  readonly sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  readonly sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  readonly sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  readonly sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  readonly sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  readonly sponsorshipsAsSponsor: SponsorshipConnection;
  /** Find an organization's team by its slug. */
  readonly team?: Maybe<Team>;
  /** A list of teams in this organization. */
  readonly teams: TeamConnection;
  /** The HTTP path listing organization's teams */
  readonly teamsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing organization's teams */
  readonly teamsUrl: Scalars['URI']['output'];
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  readonly totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** The organization's Twitter username. */
  readonly twitterUsername?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this organization. */
  readonly url: Scalars['URI']['output'];
  /** Organization is adminable by the viewer. */
  readonly viewerCanAdminister: Scalars['Boolean']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  readonly viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  readonly viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Viewer can create repositories on this organization */
  readonly viewerCanCreateRepositories: Scalars['Boolean']['output'];
  /** Viewer can create teams on this organization. */
  readonly viewerCanCreateTeams: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  readonly viewerCanSponsor: Scalars['Boolean']['output'];
  /** Viewer is an active member of this organization. */
  readonly viewerIsAMember: Scalars['Boolean']['output'];
  /** Whether or not this Organization is followed by the viewer. */
  readonly viewerIsFollowing: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  readonly viewerIsSponsoring: Scalars['Boolean']['output'];
  /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */
  readonly webCommitSignoffRequired: Scalars['Boolean']['output'];
  /** The organization's public profile URL. */
  readonly websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationAnyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationAuditLogArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AuditLogOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationDomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VerifiableDomainOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationEnterpriseOwnersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrgEnterpriseOwnerOrder>;
  organizationRole?: InputMaybe<RoleInOrganization>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IpAllowListEntryOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationIsSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationMannequinsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<MannequinOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserStatusOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationMembersWithRoleArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationPackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationPendingMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<ReadonlyArray<PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<ReadonlyArray<PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationProjectArgs = {
  number: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<ReadonlyArray<ProjectState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRepositoriesArgs = {
  affiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<ReadonlyArray<DiscussionState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRepositoryMigrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryMigrationOrder>;
  repositoryName?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<MigrationState>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRulesetArgs = {
  databaseId: Scalars['Int']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationRulesetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorsActivitiesArgs = {
  actions?: InputMaybe<ReadonlyArray<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationSponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationTeamArgs = {
  slug: Scalars['String']['input'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ldapMapped?: InputMaybe<Scalars['Boolean']['input']>;
  notificationSetting?: InputMaybe<TeamNotificationSetting>;
  orderBy?: InputMaybe<TeamOrder>;
  privacy?: InputMaybe<TeamPrivacy>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<TeamRole>;
  rootTeamsOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
type OrganizationTotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

/** An audit entry in an organization audit log. */
type OrganizationAuditEntry = MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
type OrganizationAuditEntryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<OrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<OrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Metadata for an audit entry with action org.* */
type OrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
};

/** An edge in a connection. */
type OrganizationAuditEntryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<OrganizationAuditEntry>;
};

/** A list of organizations managed by an enterprise. */
type OrganizationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<OrganizationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Organization>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type OrganizationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Organization>;
};

/** The connection type for User. */
type OrganizationEnterpriseOwnerConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<OrganizationEnterpriseOwnerEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An enterprise owner in the context of an organization that is part of the enterprise. */
type OrganizationEnterpriseOwnerEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<User>;
  /** The role of the owner with respect to the organization. */
  readonly organizationRole: RoleInOrganization;
};

/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
type OrganizationIdentityProvider = Node & {
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  readonly digestMethod?: Maybe<Scalars['URI']['output']>;
  /** External Identities provisioned by this Identity Provider */
  readonly externalIdentities: ExternalIdentityConnection;
  readonly id: Scalars['ID']['output'];
  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */
  readonly idpCertificate?: Maybe<Scalars['X509Certificate']['output']>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  readonly issuer?: Maybe<Scalars['String']['output']>;
  /** Organization this Identity Provider belongs to */
  readonly organization?: Maybe<Organization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  readonly signatureMethod?: Maybe<Scalars['URI']['output']>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  readonly ssoUrl?: Maybe<Scalars['URI']['output']>;
};


/**
 * An Identity Provider configured to provision SAML and SCIM identities for
 * Organizations. Visible to (1) organization owners, (2) organization owners'
 * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub
 * App with an installation token with read or write access to members.
 */
type OrganizationIdentityProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  membersOnly?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** An Invitation for a user to an organization. */
type OrganizationInvitation = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The email address of the user invited to the organization. */
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The source of the invitation. */
  readonly invitationSource: OrganizationInvitationSource;
  /** The type of invitation that was sent (e.g. email, user). */
  readonly invitationType: OrganizationInvitationType;
  /** The user who was invited to the organization. */
  readonly invitee?: Maybe<User>;
  /** The user who created the invitation. */
  readonly inviter: User;
  /** The organization the invite is for */
  readonly organization: Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  readonly role: OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
type OrganizationInvitationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type OrganizationInvitationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<OrganizationInvitation>;
};

/** The possible organization invitation roles. */
enum OrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = 'ADMIN',
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = 'BILLING_MANAGER',
  /** The user is invited to be a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** The user's previous role will be reinstated. */
  Reinstate = 'REINSTATE'
}

/** The possible organization invitation sources. */
enum OrganizationInvitationSource {
  /** The invitation was created from the web interface or from API */
  Member = 'MEMBER',
  /** The invitation was created from SCIM */
  Scim = 'SCIM',
  /** The invitation was sent before this feature was added */
  Unknown = 'UNKNOWN'
}

/** The possible organization invitation types. */
enum OrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = 'EMAIL',
  /** The invitation was to an existing user. */
  User = 'USER'
}

/** The connection type for User. */
type OrganizationMemberConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<OrganizationMemberEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a user within an organization. */
type OrganizationMemberEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  readonly hasTwoFactorEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The item at the end of the edge. */
  readonly node?: Maybe<User>;
  /** The role this user has in the organization. */
  readonly role?: Maybe<OrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
enum OrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = 'ADMIN',
  /** The user is a member of the organization. */
  Member = 'MEMBER'
}

/** The possible values for the members can create repositories setting on an organization. */
enum OrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Members will be able to create only internal repositories. */
  Internal = 'INTERNAL',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE'
}

/** A GitHub Enterprise Importer (GEI) organization migration. */
type OrganizationMigration = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the organization migration failed. */
  readonly failureReason?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The remaining amount of repos to be migrated. */
  readonly remainingRepositoriesCount?: Maybe<Scalars['Int']['output']>;
  /** The name of the source organization to be migrated. */
  readonly sourceOrgName: Scalars['String']['output'];
  /** The URL of the source organization to migrate. */
  readonly sourceOrgUrl: Scalars['URI']['output'];
  /** The migration state. */
  readonly state: OrganizationMigrationState;
  /** The name of the target organization. */
  readonly targetOrgName: Scalars['String']['output'];
  /** The total amount of repositories to be migrated. */
  readonly totalRepositoriesCount?: Maybe<Scalars['Int']['output']>;
};

/** The Octoshift Organization migration state. */
enum OrganizationMigrationState {
  /** The Octoshift migration has failed. */
  Failed = 'FAILED',
  /** The Octoshift migration has invalid credentials. */
  FailedValidation = 'FAILED_VALIDATION',
  /** The Octoshift migration is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The Octoshift migration has not started. */
  NotStarted = 'NOT_STARTED',
  /** The Octoshift migration needs to have its credentials validated. */
  PendingValidation = 'PENDING_VALIDATION',
  /** The Octoshift migration is performing post repository migrations. */
  PostRepoMigration = 'POST_REPO_MIGRATION',
  /** The Octoshift migration is performing pre repository migrations. */
  PreRepoMigration = 'PRE_REPO_MIGRATION',
  /** The Octoshift migration has been queued. */
  Queued = 'QUEUED',
  /** The Octoshift org migration is performing repository migrations. */
  RepoMigration = 'REPO_MIGRATION',
  /** The Octoshift migration has succeeded. */
  Succeeded = 'SUCCEEDED'
}

/** Used for argument of CreateProjectV2 mutation. */
type OrganizationOrUser = Organization | User;

/** Ordering options for organization connections. */
type OrganizationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order organizations by. */
  readonly field: OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
enum OrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order organizations by login */
  Login = 'LOGIN'
}

/** An organization teams hovercard context */
type OrganizationTeamsHovercardContext = HovercardContext & {
  /** A string describing this context */
  readonly message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  readonly octicon: Scalars['String']['output'];
  /** Teams in this organization the user is a member of that are relevant */
  readonly relevantTeams: TeamConnection;
  /** The path for the full team list for this user */
  readonly teamsResourcePath: Scalars['URI']['output'];
  /** The URL for the full team list for this user */
  readonly teamsUrl: Scalars['URI']['output'];
  /** The total number of teams the user is on in the organization */
  readonly totalTeamCount: Scalars['Int']['output'];
};


/** An organization teams hovercard context */
type OrganizationTeamsHovercardContextRelevantTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An organization list hovercard context */
type OrganizationsHovercardContext = HovercardContext & {
  /** A string describing this context */
  readonly message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  readonly octicon: Scalars['String']['output'];
  /** Organizations this user is a member of that are relevant */
  readonly relevantOrganizations: OrganizationConnection;
  /** The total number of organizations this user is in */
  readonly totalOrganizationCount: Scalars['Int']['output'];
};


/** An organization list hovercard context */
type OrganizationsHovercardContextRelevantOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
};

/** Information for an uploaded package. */
type Package = Node & {
  readonly id: Scalars['ID']['output'];
  /** Find the latest version for the package. */
  readonly latestVersion?: Maybe<PackageVersion>;
  /** Identifies the name of the package. */
  readonly name: Scalars['String']['output'];
  /** Identifies the type of the package. */
  readonly packageType: PackageType;
  /** The repository this package belongs to. */
  readonly repository?: Maybe<Repository>;
  /** Statistics about package activity. */
  readonly statistics?: Maybe<PackageStatistics>;
  /** Find package version by version string. */
  readonly version?: Maybe<PackageVersion>;
  /** list of versions for this package */
  readonly versions: PackageVersionConnection;
};


/** Information for an uploaded package. */
type PackageVersionArgs = {
  version: Scalars['String']['input'];
};


/** Information for an uploaded package. */
type PackageVersionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PackageVersionOrder>;
};

/** The connection type for Package. */
type PackageConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PackageEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Package>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PackageEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Package>;
};

/** A file in a package version. */
type PackageFile = Node & {
  readonly id: Scalars['ID']['output'];
  /** MD5 hash of the file. */
  readonly md5?: Maybe<Scalars['String']['output']>;
  /** Name of the file. */
  readonly name: Scalars['String']['output'];
  /** The package version this file belongs to. */
  readonly packageVersion?: Maybe<PackageVersion>;
  /** SHA1 hash of the file. */
  readonly sha1?: Maybe<Scalars['String']['output']>;
  /** SHA256 hash of the file. */
  readonly sha256?: Maybe<Scalars['String']['output']>;
  /** Size of the file in bytes. */
  readonly size?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** URL to download the asset. */
  readonly url?: Maybe<Scalars['URI']['output']>;
};

/** The connection type for PackageFile. */
type PackageFileConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PackageFileEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PackageFile>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PackageFileEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
type PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  readonly direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package files by. */
  readonly field?: InputMaybe<PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
enum PackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Ways in which lists of packages can be ordered upon return. */
type PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  readonly direction?: InputMaybe<OrderDirection>;
  /** The field in which to order packages by. */
  readonly field?: InputMaybe<PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
enum PackageOrderField {
  /** Order packages by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Represents an owner of a package. */
type PackageOwner = {
  readonly id: Scalars['ID']['output'];
  /** A list of packages under the owner. */
  readonly packages: PackageConnection;
};


/** Represents an owner of a package. */
type PackageOwnerPackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
type PackageStatistics = {
  /** Number of times the package was downloaded since it was created. */
  readonly downloadsTotalCount: Scalars['Int']['output'];
};

/** A version tag contains the mapping between a tag name and a version. */
type PackageTag = Node & {
  readonly id: Scalars['ID']['output'];
  /** Identifies the tag name of the version. */
  readonly name: Scalars['String']['output'];
  /** Version that the tag is associated with. */
  readonly version?: Maybe<PackageVersion>;
};

/** The possible types of a package. */
enum PackageType {
  /** A debian package. */
  Debian = 'DEBIAN',
  /**
   * A docker image.
   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.
   */
  Docker = 'DOCKER',
  /**
   * A maven package.
   * @deprecated MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC.
   */
  Maven = 'MAVEN',
  /**
   * An npm package.
   * @deprecated NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.
   */
  Npm = 'NPM',
  /**
   * A nuget package.
   * @deprecated NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.
   */
  Nuget = 'NUGET',
  /** A python package. */
  Pypi = 'PYPI',
  /**
   * A rubygems package.
   * @deprecated RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC.
   */
  Rubygems = 'RUBYGEMS'
}

/** Information about a specific package version. */
type PackageVersion = Node & {
  /** List of files associated with this package version */
  readonly files: PackageFileConnection;
  readonly id: Scalars['ID']['output'];
  /** The package associated with this version. */
  readonly package?: Maybe<Package>;
  /** The platform this version was built for. */
  readonly platform?: Maybe<Scalars['String']['output']>;
  /** Whether or not this version is a pre-release. */
  readonly preRelease: Scalars['Boolean']['output'];
  /** The README of this package version. */
  readonly readme?: Maybe<Scalars['String']['output']>;
  /** The release associated with this package version. */
  readonly release?: Maybe<Release>;
  /** Statistics about package activity. */
  readonly statistics?: Maybe<PackageVersionStatistics>;
  /** The package version summary. */
  readonly summary?: Maybe<Scalars['String']['output']>;
  /** The version string. */
  readonly version: Scalars['String']['output'];
};


/** Information about a specific package version. */
type PackageVersionFilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PackageFileOrder>;
};

/** The connection type for PackageVersion. */
type PackageVersionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PackageVersionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PackageVersion>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PackageVersionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
type PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  readonly direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package versions by. */
  readonly field?: InputMaybe<PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
enum PackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Represents a object that contains package version activity statistics such as downloads. */
type PackageVersionStatistics = {
  /** Number of times the package was downloaded since it was created. */
  readonly downloadsTotalCount: Scalars['Int']['output'];
};

/** Information about pagination in a connection. */
type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars['String']['output']>;
};

/** The possible types of patch statuses. */
enum PatchStatus {
  /** The file was added. Git status 'A'. */
  Added = 'ADDED',
  /** The file's type was changed. Git status 'T'. */
  Changed = 'CHANGED',
  /** The file was copied. Git status 'C'. */
  Copied = 'COPIED',
  /** The file was deleted. Git status 'D'. */
  Deleted = 'DELETED',
  /** The file's contents were changed. Git status 'M'. */
  Modified = 'MODIFIED',
  /** The file was renamed. Git status 'R'. */
  Renamed = 'RENAMED'
}

/** Types that can grant permissions on a repository to a user */
type PermissionGranter = Organization | Repository | Team;

/** A level of permission and source for a user's access to a repository. */
type PermissionSource = {
  /** The organization the repository belongs to. */
  readonly organization: Organization;
  /** The level of access this source has granted to the user. */
  readonly permission: DefaultRepositoryPermissionField;
  /** The source of this permission. */
  readonly source: PermissionGranter;
};

/** Autogenerated input type of PinIssue */
type PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be pinned */
  readonly issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of PinIssue */
type PinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was pinned */
  readonly issue?: Maybe<Issue>;
};

/** Types that can be pinned to a profile page. */
type PinnableItem = Gist | Repository;

/** The connection type for PinnableItem. */
type PinnableItemConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PinnableItemEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PinnableItem>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PinnableItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
enum PinnableItemType {
  /** A gist. */
  Gist = 'GIST',
  /** An issue. */
  Issue = 'ISSUE',
  /** An organization. */
  Organization = 'ORGANIZATION',
  /** A project. */
  Project = 'PROJECT',
  /** A pull request. */
  PullRequest = 'PULL_REQUEST',
  /** A repository. */
  Repository = 'REPOSITORY',
  /** A team. */
  Team = 'TEAM',
  /** A user. */
  User = 'USER'
}

/** A Pinned Discussion is a discussion pinned to a repository's index page. */
type PinnedDiscussion = Node & RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The discussion that was pinned. */
  readonly discussion: Discussion;
  /** Color stops of the chosen gradient */
  readonly gradientStopColors: ReadonlyArray<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Background texture pattern */
  readonly pattern: PinnedDiscussionPattern;
  /** The actor that pinned this discussion. */
  readonly pinnedBy: Actor;
  /** Preconfigured background gradient option */
  readonly preconfiguredGradient?: Maybe<PinnedDiscussionGradient>;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PinnedDiscussion. */
type PinnedDiscussionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PinnedDiscussionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PinnedDiscussion>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PinnedDiscussionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PinnedDiscussion>;
};

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
enum PinnedDiscussionGradient {
  /** A gradient of blue to mint */
  BlueMint = 'BLUE_MINT',
  /** A gradient of blue to purple */
  BluePurple = 'BLUE_PURPLE',
  /** A gradient of pink to blue */
  PinkBlue = 'PINK_BLUE',
  /** A gradient of purple to coral */
  PurpleCoral = 'PURPLE_CORAL',
  /** A gradient of red to orange */
  RedOrange = 'RED_ORANGE'
}

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
enum PinnedDiscussionPattern {
  /** An upward-facing chevron pattern */
  ChevronUp = 'CHEVRON_UP',
  /** A hollow dot pattern */
  Dot = 'DOT',
  /** A solid dot pattern */
  DotFill = 'DOT_FILL',
  /** A heart pattern */
  HeartFill = 'HEART_FILL',
  /** A plus sign pattern */
  Plus = 'PLUS',
  /** A lightning bolt pattern */
  Zap = 'ZAP'
}

/** Represents a 'pinned' event on a given issue or pull request. */
type PinnedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  readonly issue: Issue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
type PinnedIssue = Node & {
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** Identifies the primary key from the database as a BigInt. */
  readonly fullDatabaseId?: Maybe<Scalars['BigInt']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The issue that was pinned. */
  readonly issue: Issue;
  /** The actor that pinned this issue. */
  readonly pinnedBy: Actor;
  /** The repository that this issue was pinned to. */
  readonly repository: Repository;
};

/** The connection type for PinnedIssue. */
type PinnedIssueConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PinnedIssueEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PinnedIssue>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PinnedIssueEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PinnedIssue>;
};

/** Audit log entry for a private_repository_forking.disable event. */
type PrivateRepositoryForkingDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a private_repository_forking.enable event. */
type PrivateRepositoryForkingEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
type ProfileItemShowcase = {
  /** Whether or not the owner has pinned any repositories or gists. */
  readonly hasPinnedItems: Scalars['Boolean']['output'];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  readonly items: PinnableItemConnection;
};


/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
type ProfileItemShowcaseItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents any entity on GitHub that has a profile page. */
type ProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  readonly anyPinnableItems: Scalars['Boolean']['output'];
  /** The public profile email. */
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  readonly itemShowcase: ProfileItemShowcase;
  /** The public profile location. */
  readonly location?: Maybe<Scalars['String']['output']>;
  /** The username used to login. */
  readonly login: Scalars['String']['output'];
  /** The public profile name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  readonly pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  readonly pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  readonly pinnedItemsRemaining: Scalars['Int']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  readonly viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** The public profile website URL. */
  readonly websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** Represents any entity on GitHub that has a profile page. */
type ProfileOwnerAnyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};


/** Represents any entity on GitHub that has a profile page. */
type ProfileOwnerPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<ReadonlyArray<PinnableItemType>>;
};


/** Represents any entity on GitHub that has a profile page. */
type ProfileOwnerPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<ReadonlyArray<PinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
type Project = Closable & Node & Updatable & {
  /** The project's description body. */
  readonly body?: Maybe<Scalars['String']['output']>;
  /** The projects description body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** List of columns in the project */
  readonly columns: ProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who originally created the project. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The project's name. */
  readonly name: Scalars['String']['output'];
  /** The project's number. */
  readonly number: Scalars['Int']['output'];
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  readonly owner: ProjectOwner;
  /** List of pending cards in this project */
  readonly pendingCards: ProjectCardConnection;
  /** Project progress details. */
  readonly progress: ProjectProgress;
  /** The HTTP path for this project */
  readonly resourcePath: Scalars['URI']['output'];
  /** Whether the project is open or closed. */
  readonly state: ProjectState;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project */
  readonly url: Scalars['URI']['output'];
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
};


/** Projects manage issues, pull requests and notes within a project owner. */
type ProjectColumnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Projects manage issues, pull requests and notes within a project owner. */
type ProjectPendingCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<ReadonlyArray<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A card in a project. */
type ProjectCard = Node & {
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  readonly column?: Maybe<ProjectColumn>;
  /** The card content item */
  readonly content?: Maybe<ProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created this card */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Whether the card is archived */
  readonly isArchived: Scalars['Boolean']['output'];
  /** The card note */
  readonly note?: Maybe<Scalars['String']['output']>;
  /** The project that contains this card. */
  readonly project: Project;
  /** The HTTP path for this card */
  readonly resourcePath: Scalars['URI']['output'];
  /** The state of ProjectCard */
  readonly state?: Maybe<ProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this card */
  readonly url: Scalars['URI']['output'];
};

/** The possible archived states of a project card. */
enum ProjectCardArchivedState {
  /** A project card that is archived */
  Archived = 'ARCHIVED',
  /** A project card that is not archived */
  NotArchived = 'NOT_ARCHIVED'
}

/** The connection type for ProjectCard. */
type ProjectCardConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectCardEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectCard>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectCardEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
type ProjectCardImport = {
  /** The issue or pull request number. */
  readonly number: Scalars['Int']['input'];
  /** Repository name with owner (owner/repository). */
  readonly repository: Scalars['String']['input'];
};

/** Types that can be inside Project Cards. */
type ProjectCardItem = Issue | PullRequest;

/** Various content states of a ProjectCard */
enum ProjectCardState {
  /** The card has content only. */
  ContentOnly = 'CONTENT_ONLY',
  /** The card has a note only. */
  NoteOnly = 'NOTE_ONLY',
  /** The card is redacted. */
  Redacted = 'REDACTED'
}

/** A column inside a project. */
type ProjectColumn = Node & {
  /** List of cards in the column */
  readonly cards: ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The project column's name. */
  readonly name: Scalars['String']['output'];
  /** The project that contains this column. */
  readonly project: Project;
  /** The semantic purpose of the column */
  readonly purpose?: Maybe<ProjectColumnPurpose>;
  /** The HTTP path for this project column */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project column */
  readonly url: Scalars['URI']['output'];
};


/** A column inside a project. */
type ProjectColumnCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<ReadonlyArray<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ProjectColumn. */
type ProjectColumnConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectColumnEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectColumn>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectColumnEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
type ProjectColumnImport = {
  /** The name of the column. */
  readonly columnName: Scalars['String']['input'];
  /** A list of issues and pull requests in the column. */
  readonly issues?: InputMaybe<ReadonlyArray<ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  readonly position: Scalars['Int']['input'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
enum ProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = 'DONE',
  /** The column contains cards which are currently being worked on */
  InProgress = 'IN_PROGRESS',
  /** The column contains cards still to be worked on */
  Todo = 'TODO'
}

/** A list of projects associated with the owner. */
type ProjectConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Project>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Project>;
};

/** Ways in which lists of projects can be ordered upon return. */
type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order projects by. */
  readonly field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
enum ProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order projects by name */
  Name = 'NAME',
  /** Order projects by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a Project. */
type ProjectOwner = {
  readonly id: Scalars['ID']['output'];
  /** Find project by number. */
  readonly project?: Maybe<Project>;
  /** A list of projects under the owner. */
  readonly projects: ProjectConnection;
  /** The HTTP path listing owners projects */
  readonly projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing owners projects */
  readonly projectsUrl: Scalars['URI']['output'];
  /** Can the current viewer create new projects on this owner. */
  readonly viewerCanCreateProjects: Scalars['Boolean']['output'];
};


/** Represents an owner of a Project. */
type ProjectOwnerProjectArgs = {
  number: Scalars['Int']['input'];
};


/** Represents an owner of a Project. */
type ProjectOwnerProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<ReadonlyArray<ProjectState>>;
};

/** Project progress stats. */
type ProjectProgress = {
  /** The number of done cards. */
  readonly doneCount: Scalars['Int']['output'];
  /** The percentage of done cards. */
  readonly donePercentage: Scalars['Float']['output'];
  /** Whether progress tracking is enabled and cards with purpose exist for this project */
  readonly enabled: Scalars['Boolean']['output'];
  /** The number of in-progress cards. */
  readonly inProgressCount: Scalars['Int']['output'];
  /** The percentage of in-progress cards. */
  readonly inProgressPercentage: Scalars['Float']['output'];
  /** The number of to do cards. */
  readonly todoCount: Scalars['Int']['output'];
  /** The percentage of to do cards. */
  readonly todoPercentage: Scalars['Float']['output'];
};

/** State of the project; either 'open' or 'closed' */
enum ProjectState {
  /** The project is closed. */
  Closed = 'CLOSED',
  /** The project is open. */
  Open = 'OPEN'
}

/** GitHub-provided templates for Projects */
enum ProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = 'BASIC_KANBAN',
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = 'BUG_TRIAGE'
}

/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2 = Closable & Node & Updatable & {
  /** Returns true if the project is closed. */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who originally created the project. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** A field of the project */
  readonly field?: Maybe<ProjectV2FieldConfiguration>;
  /** List of fields and their constraints in the project */
  readonly fields: ProjectV2FieldConfigurationConnection;
  readonly id: Scalars['ID']['output'];
  /** List of items in the project */
  readonly items: ProjectV2ItemConnection;
  /** The project's number. */
  readonly number: Scalars['Int']['output'];
  /** The project's owner. Currently limited to organizations and users. */
  readonly owner: ProjectV2Owner;
  /** Returns true if the project is public. */
  readonly public: Scalars['Boolean']['output'];
  /** The project's readme. */
  readonly readme?: Maybe<Scalars['String']['output']>;
  /** The repositories the project is linked to. */
  readonly repositories: RepositoryConnection;
  /** The HTTP path for this project */
  readonly resourcePath: Scalars['URI']['output'];
  /** The project's short description. */
  readonly shortDescription?: Maybe<Scalars['String']['output']>;
  /** The teams the project is linked to. */
  readonly teams: TeamConnection;
  /** Returns true if this project is a template. */
  readonly template: Scalars['Boolean']['output'];
  /** The project's name. */
  readonly title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this project */
  readonly url: Scalars['URI']['output'];
  /** A view of the project */
  readonly view?: Maybe<ProjectV2View>;
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** List of views in the project */
  readonly views: ProjectV2ViewConnection;
  /** A workflow of the project */
  readonly workflow?: Maybe<ProjectV2Workflow>;
  /** List of the workflows in the project */
  readonly workflows: ProjectV2WorkflowConnection;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2FieldArgs = {
  name: Scalars['String']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2FieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2ItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2ItemOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2RepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2TeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2ViewArgs = {
  number: Scalars['Int']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2ViewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2ViewOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2WorkflowArgs = {
  number: Scalars['Int']['input'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
type ProjectV2WorkflowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2WorkflowOrder>;
};

/** Possible collaborators for a project. */
type ProjectV2Actor = Team | User;

/** The connection type for ProjectV2Actor. */
type ProjectV2ActorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2ActorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2Actor>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2ActorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2Actor>;
};

/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */
type ProjectV2Collaborator = {
  /** The role to grant the collaborator */
  readonly role: ProjectV2Roles;
  /** The ID of the team as a collaborator. */
  readonly teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the user as a collaborator. */
  readonly userId?: InputMaybe<Scalars['ID']['input']>;
};

/** The connection type for ProjectV2. */
type ProjectV2Connection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2Edge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** The type of a project field. */
enum ProjectV2CustomFieldType {
  /** Date */
  Date = 'DATE',
  /** Number */
  Number = 'NUMBER',
  /** Single Select */
  SingleSelect = 'SINGLE_SELECT',
  /** Text */
  Text = 'TEXT'
}

/** An edge in a connection. */
type ProjectV2Edge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2>;
};

/** A field inside a project. */
type ProjectV2Field = Node & ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  readonly dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The project field's name. */
  readonly name: Scalars['String']['output'];
  /** The project that contains this field. */
  readonly project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** Common fields across different project field types */
type ProjectV2FieldCommon = {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  readonly dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The project field's name. */
  readonly name: Scalars['String']['output'];
  /** The project that contains this field. */
  readonly project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** Configurations for project fields. */
type ProjectV2FieldConfiguration = ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField;

/** The connection type for ProjectV2FieldConfiguration. */
type ProjectV2FieldConfigurationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2FieldConfigurationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2FieldConfiguration>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2FieldConfigurationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2FieldConfiguration>;
};

/** The connection type for ProjectV2Field. */
type ProjectV2FieldConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2FieldEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2Field>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2FieldEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2Field>;
};

/** Ordering options for project v2 field connections */
type ProjectV2FieldOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order the project v2 fields by. */
  readonly field: ProjectV2FieldOrderField;
};

/** Properties by which project v2 field connections can be ordered. */
enum ProjectV2FieldOrderField {
  /** Order project v2 fields by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order project v2 fields by name */
  Name = 'NAME',
  /** Order project v2 fields by position */
  Position = 'POSITION'
}

/** The type of a project field. */
enum ProjectV2FieldType {
  /** Assignees */
  Assignees = 'ASSIGNEES',
  /** Date */
  Date = 'DATE',
  /** Iteration */
  Iteration = 'ITERATION',
  /** Labels */
  Labels = 'LABELS',
  /** Linked Pull Requests */
  LinkedPullRequests = 'LINKED_PULL_REQUESTS',
  /** Milestone */
  Milestone = 'MILESTONE',
  /** Number */
  Number = 'NUMBER',
  /** Repository */
  Repository = 'REPOSITORY',
  /** Reviewers */
  Reviewers = 'REVIEWERS',
  /** Single Select */
  SingleSelect = 'SINGLE_SELECT',
  /** Text */
  Text = 'TEXT',
  /** Title */
  Title = 'TITLE',
  /** Tracked by */
  TrackedBy = 'TRACKED_BY',
  /** Tracks */
  Tracks = 'TRACKS'
}

/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */
type ProjectV2FieldValue = {
  /** The ISO 8601 date to set on the field. */
  readonly date?: InputMaybe<Scalars['Date']['input']>;
  /** The id of the iteration to set on the field. */
  readonly iterationId?: InputMaybe<Scalars['String']['input']>;
  /** The number to set on the field. */
  readonly number?: InputMaybe<Scalars['Float']['input']>;
  /** The id of the single select option to set on the field. */
  readonly singleSelectOptionId?: InputMaybe<Scalars['String']['input']>;
  /** The text to set on the field. */
  readonly text?: InputMaybe<Scalars['String']['input']>;
};

/** Ways in which to filter lists of projects. */
type ProjectV2Filters = {
  /** List project v2 filtered by the state given. */
  readonly state?: InputMaybe<ProjectV2State>;
};

/** An item within a Project. */
type ProjectV2Item = Node & {
  /** The content of the referenced draft issue, issue, or pull request */
  readonly content?: Maybe<ProjectV2ItemContent>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The field value of the first project field which matches the 'name' argument that is set on the item. */
  readonly fieldValueByName?: Maybe<ProjectV2ItemFieldValue>;
  /** The field values that are set on the item. */
  readonly fieldValues: ProjectV2ItemFieldValueConnection;
  readonly id: Scalars['ID']['output'];
  /** Whether the item is archived. */
  readonly isArchived: Scalars['Boolean']['output'];
  /** The project that contains this item. */
  readonly project: ProjectV2;
  /** The type of the item. */
  readonly type: ProjectV2ItemType;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** An item within a Project. */
type ProjectV2ItemFieldValueByNameArgs = {
  name: Scalars['String']['input'];
};


/** An item within a Project. */
type ProjectV2ItemFieldValuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2ItemFieldValueOrder>;
};

/** The connection type for ProjectV2Item. */
type ProjectV2ItemConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2ItemEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2Item>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Types that can be inside Project Items. */
type ProjectV2ItemContent = DraftIssue | Issue | PullRequest;

/** An edge in a connection. */
type ProjectV2ItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2Item>;
};

/** The value of a date field in a Project item. */
type ProjectV2ItemFieldDateValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** Date value for the field */
  readonly date?: Maybe<Scalars['Date']['output']>;
  /** The project field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  readonly id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  readonly item: ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The value of an iteration field in a Project item. */
type ProjectV2ItemFieldIterationValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The duration of the iteration in days. */
  readonly duration: Scalars['Int']['output'];
  /** The project field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  readonly id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  readonly item: ProjectV2Item;
  /** The ID of the iteration. */
  readonly iterationId: Scalars['String']['output'];
  /** The start date of the iteration. */
  readonly startDate: Scalars['Date']['output'];
  /** The title of the iteration. */
  readonly title: Scalars['String']['output'];
  /** The title of the iteration, with HTML. */
  readonly titleHTML: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The value of the labels field in a Project item. */
type ProjectV2ItemFieldLabelValue = {
  /** The field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  /** Labels value of a field */
  readonly labels?: Maybe<LabelConnection>;
};


/** The value of the labels field in a Project item. */
type ProjectV2ItemFieldLabelValueLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The value of a milestone field in a Project item. */
type ProjectV2ItemFieldMilestoneValue = {
  /** The field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  /** Milestone value of a field */
  readonly milestone?: Maybe<Milestone>;
};

/** The value of a number field in a Project item. */
type ProjectV2ItemFieldNumberValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  readonly id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  readonly item: ProjectV2Item;
  /** Number as a float(8) */
  readonly number?: Maybe<Scalars['Float']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The value of a pull request field in a Project item. */
type ProjectV2ItemFieldPullRequestValue = {
  /** The field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  /** The pull requests for this field */
  readonly pullRequests?: Maybe<PullRequestConnection>;
};


/** The value of a pull request field in a Project item. */
type ProjectV2ItemFieldPullRequestValuePullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PullRequestOrder>;
};

/** The value of a repository field in a Project item. */
type ProjectV2ItemFieldRepositoryValue = {
  /** The field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  /** The repository for this field. */
  readonly repository?: Maybe<Repository>;
};

/** The value of a reviewers field in a Project item. */
type ProjectV2ItemFieldReviewerValue = {
  /** The field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  /** The reviewers for this field. */
  readonly reviewers?: Maybe<RequestedReviewerConnection>;
};


/** The value of a reviewers field in a Project item. */
type ProjectV2ItemFieldReviewerValueReviewersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The value of a single select field in a Project item. */
type ProjectV2ItemFieldSingleSelectValue = Node & ProjectV2ItemFieldValueCommon & {
  /** The color applied to the selected single-select option. */
  readonly color: ProjectV2SingleSelectFieldOptionColor;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** A plain-text description of the selected single-select option, such as what the option means. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The description of the selected single-select option, including HTML tags. */
  readonly descriptionHTML?: Maybe<Scalars['String']['output']>;
  /** The project field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  readonly id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  readonly item: ProjectV2Item;
  /** The name of the selected single select option. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** The html name of the selected single select option. */
  readonly nameHTML?: Maybe<Scalars['String']['output']>;
  /** The id of the selected single select option. */
  readonly optionId?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The value of a text field in a Project item. */
type ProjectV2ItemFieldTextValue = Node & ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  readonly id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  readonly item: ProjectV2Item;
  /** Text value of a field */
  readonly text?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The value of a user field in a Project item. */
type ProjectV2ItemFieldUserValue = {
  /** The field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  /** The users for this field */
  readonly users?: Maybe<UserConnection>;
};


/** The value of a user field in a Project item. */
type ProjectV2ItemFieldUserValueUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Project field values */
type ProjectV2ItemFieldValue = ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldLabelValue | ProjectV2ItemFieldMilestoneValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldPullRequestValue | ProjectV2ItemFieldRepositoryValue | ProjectV2ItemFieldReviewerValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2ItemFieldUserValue;

/** Common fields across different project field value types */
type ProjectV2ItemFieldValueCommon = {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created the item. */
  readonly creator?: Maybe<Actor>;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The project field that contains this value. */
  readonly field: ProjectV2FieldConfiguration;
  readonly id: Scalars['ID']['output'];
  /** The project item that contains this value. */
  readonly item: ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ProjectV2ItemFieldValue. */
type ProjectV2ItemFieldValueConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2ItemFieldValueEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2ItemFieldValue>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2ItemFieldValueEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2ItemFieldValue>;
};

/** Ordering options for project v2 item field value connections */
type ProjectV2ItemFieldValueOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order the project v2 item field values by. */
  readonly field: ProjectV2ItemFieldValueOrderField;
};

/** Properties by which project v2 item field value connections can be ordered. */
enum ProjectV2ItemFieldValueOrderField {
  /** Order project v2 item field values by the their position in the project */
  Position = 'POSITION'
}

/** Ordering options for project v2 item connections */
type ProjectV2ItemOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order the project v2 items by. */
  readonly field: ProjectV2ItemOrderField;
};

/** Properties by which project v2 item connections can be ordered. */
enum ProjectV2ItemOrderField {
  /** Order project v2 items by the their position in the project */
  Position = 'POSITION'
}

/** The type of a project item. */
enum ProjectV2ItemType {
  /** Draft Issue */
  DraftIssue = 'DRAFT_ISSUE',
  /** Issue */
  Issue = 'ISSUE',
  /** Pull Request */
  PullRequest = 'PULL_REQUEST',
  /** Redacted Item */
  Redacted = 'REDACTED'
}

/** An iteration field inside a project. */
type ProjectV2IterationField = Node & ProjectV2FieldCommon & {
  /** Iteration configuration settings */
  readonly configuration: ProjectV2IterationFieldConfiguration;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  readonly dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The project field's name. */
  readonly name: Scalars['String']['output'];
  /** The project that contains this field. */
  readonly project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** Iteration field configuration for a project. */
type ProjectV2IterationFieldConfiguration = {
  /** The iteration's completed iterations */
  readonly completedIterations: ReadonlyArray<ProjectV2IterationFieldIteration>;
  /** The iteration's duration in days */
  readonly duration: Scalars['Int']['output'];
  /** The iteration's iterations */
  readonly iterations: ReadonlyArray<ProjectV2IterationFieldIteration>;
  /** The iteration's start day of the week */
  readonly startDay: Scalars['Int']['output'];
};

/** Iteration field iteration settings for a project. */
type ProjectV2IterationFieldIteration = {
  /** The iteration's duration in days */
  readonly duration: Scalars['Int']['output'];
  /** The iteration's ID. */
  readonly id: Scalars['String']['output'];
  /** The iteration's start date */
  readonly startDate: Scalars['Date']['output'];
  /** The iteration's title. */
  readonly title: Scalars['String']['output'];
  /** The iteration's html title. */
  readonly titleHTML: Scalars['String']['output'];
};

/** Ways in which lists of projects can be ordered upon return. */
type ProjectV2Order = {
  /** The direction in which to order projects by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order projects by. */
  readonly field: ProjectV2OrderField;
};

/** Properties by which projects can be ordered. */
enum ProjectV2OrderField {
  /** The project's date and time of creation */
  CreatedAt = 'CREATED_AT',
  /** The project's number */
  Number = 'NUMBER',
  /** The project's title */
  Title = 'TITLE',
  /** The project's date and time of update */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a project (beta). */
type ProjectV2Owner = {
  readonly id: Scalars['ID']['output'];
  /** Find a project by number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  readonly projectsV2: ProjectV2Connection;
};


/** Represents an owner of a project (beta). */
type ProjectV2OwnerProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** Represents an owner of a project (beta). */
type ProjectV2OwnerProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Recent projects for the owner. */
type ProjectV2Recent = {
  /** Recent projects that this user has modified in the context of the owner. */
  readonly recentProjects: ProjectV2Connection;
};


/** Recent projects for the owner. */
type ProjectV2RecentRecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible roles of a collaborator on a project. */
enum ProjectV2Roles {
  /** The collaborator can view, edit, and maange the settings of the project */
  Admin = 'ADMIN',
  /** The collaborator has no direct access to the project */
  None = 'NONE',
  /** The collaborator can view the project */
  Reader = 'READER',
  /** The collaborator can view and edit the project */
  Writer = 'WRITER'
}

/** A single select field inside a project. */
type ProjectV2SingleSelectField = Node & ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The field's type. */
  readonly dataType: ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The project field's name. */
  readonly name: Scalars['String']['output'];
  /** Options for the single select field */
  readonly options: ReadonlyArray<ProjectV2SingleSelectFieldOption>;
  /** The project that contains this field. */
  readonly project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** A single select field inside a project. */
type ProjectV2SingleSelectFieldOptionsArgs = {
  names?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** Single select field option for a configuration for a project. */
type ProjectV2SingleSelectFieldOption = {
  /** The option's display color. */
  readonly color: ProjectV2SingleSelectFieldOptionColor;
  /** The option's plain-text description. */
  readonly description: Scalars['String']['output'];
  /** The option's description, possibly containing HTML. */
  readonly descriptionHTML: Scalars['String']['output'];
  /** The option's ID. */
  readonly id: Scalars['String']['output'];
  /** The option's name. */
  readonly name: Scalars['String']['output'];
  /** The option's html name. */
  readonly nameHTML: Scalars['String']['output'];
};

/** The display color of a single-select field option. */
enum ProjectV2SingleSelectFieldOptionColor {
  /** BLUE */
  Blue = 'BLUE',
  /** GRAY */
  Gray = 'GRAY',
  /** GREEN */
  Green = 'GREEN',
  /** ORANGE */
  Orange = 'ORANGE',
  /** PINK */
  Pink = 'PINK',
  /** PURPLE */
  Purple = 'PURPLE',
  /** RED */
  Red = 'RED',
  /** YELLOW */
  Yellow = 'YELLOW'
}

/** Represents a single select field option */
type ProjectV2SingleSelectFieldOptionInput = {
  /** The display color of the option */
  readonly color: ProjectV2SingleSelectFieldOptionColor;
  /** The description text of the option */
  readonly description: Scalars['String']['input'];
  /** The name of the option */
  readonly name: Scalars['String']['input'];
};

/** Represents a sort by field and direction. */
type ProjectV2SortBy = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  readonly direction: OrderDirection;
  /** The field by which items are sorted. */
  readonly field: ProjectV2Field;
};

/** The connection type for ProjectV2SortBy. */
type ProjectV2SortByConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2SortByEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2SortBy>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2SortByEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2SortBy>;
};

/** Represents a sort by field and direction. */
type ProjectV2SortByField = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  readonly direction: OrderDirection;
  /** The field by which items are sorted. */
  readonly field: ProjectV2FieldConfiguration;
};

/** The connection type for ProjectV2SortByField. */
type ProjectV2SortByFieldConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2SortByFieldEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2SortByField>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2SortByFieldEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2SortByField>;
};

/** The possible states of a project v2. */
enum ProjectV2State {
  /** A project v2 that has been closed */
  Closed = 'CLOSED',
  /** A project v2 that is still open */
  Open = 'OPEN'
}

/** A view within a ProjectV2. */
type ProjectV2View = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The view's visible fields. */
  readonly fields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /** The project view's filter. */
  readonly filter?: Maybe<Scalars['String']['output']>;
  /**
   * The view's group-by field.
   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  readonly groupBy?: Maybe<ProjectV2FieldConnection>;
  /** The view's group-by field. */
  readonly groupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;
  readonly id: Scalars['ID']['output'];
  /** The project view's layout. */
  readonly layout: ProjectV2ViewLayout;
  /** The project view's name. */
  readonly name: Scalars['String']['output'];
  /** The project view's number. */
  readonly number: Scalars['Int']['output'];
  /** The project that contains this view. */
  readonly project: ProjectV2;
  /**
   * The view's sort-by config.
   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  readonly sortBy?: Maybe<ProjectV2SortByConnection>;
  /** The view's sort-by config. */
  readonly sortByFields?: Maybe<ProjectV2SortByFieldConnection>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /**
   * The view's vertical-group-by field.
   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  readonly verticalGroupBy?: Maybe<ProjectV2FieldConnection>;
  /** The view's vertical-group-by field. */
  readonly verticalGroupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;
  /**
   * The view's visible fields.
   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.
   */
  readonly visibleFields?: Maybe<ProjectV2FieldConnection>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewGroupByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewGroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewSortByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewSortByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewVerticalGroupByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewVerticalGroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
type ProjectV2ViewVisibleFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2FieldOrder>;
};

/** The connection type for ProjectV2View. */
type ProjectV2ViewConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2ViewEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2View>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2ViewEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2View>;
};

/** The layout of a project v2 view. */
enum ProjectV2ViewLayout {
  /** Board layout */
  BoardLayout = 'BOARD_LAYOUT',
  /** Roadmap layout */
  RoadmapLayout = 'ROADMAP_LAYOUT',
  /** Table layout */
  TableLayout = 'TABLE_LAYOUT'
}

/** Ordering options for project v2 view connections */
type ProjectV2ViewOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order the project v2 views by. */
  readonly field: ProjectV2ViewOrderField;
};

/** Properties by which project v2 view connections can be ordered. */
enum ProjectV2ViewOrderField {
  /** Order project v2 views by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order project v2 views by name */
  Name = 'NAME',
  /** Order project v2 views by position */
  Position = 'POSITION'
}

/** A workflow inside a project. */
type ProjectV2Workflow = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The workflows' enabled state. */
  readonly enabled: Scalars['Boolean']['output'];
  readonly id: Scalars['ID']['output'];
  /** The workflows' name. */
  readonly name: Scalars['String']['output'];
  /** The workflows' number. */
  readonly number: Scalars['Int']['output'];
  /** The project that contains this workflow. */
  readonly project: ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ProjectV2Workflow. */
type ProjectV2WorkflowConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProjectV2WorkflowEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ProjectV2Workflow>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ProjectV2WorkflowEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ProjectV2Workflow>;
};

/** Ordering options for project v2 workflows connections */
type ProjectV2WorkflowOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order the project v2 workflows by. */
  readonly field: ProjectV2WorkflowsOrderField;
};

/** Properties by which project workflows can be ordered. */
enum ProjectV2WorkflowsOrderField {
  /** The workflows' date and time of creation */
  CreatedAt = 'CREATED_AT',
  /** The workflows' name */
  Name = 'NAME',
  /** The workflows' number */
  Number = 'NUMBER',
  /** The workflows' date and time of update */
  UpdatedAt = 'UPDATED_AT'
}

/** A user's public key. */
type PublicKey = Node & {
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  readonly accessedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  readonly createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** The fingerprint for this PublicKey. */
  readonly fingerprint: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  readonly isReadOnly?: Maybe<Scalars['Boolean']['output']>;
  /** The public key string. */
  readonly key: Scalars['String']['output'];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  readonly updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for PublicKey. */
type PublicKeyConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PublicKeyEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PublicKey>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PublicKeyEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PublicKey>;
};

/** Autogenerated input type of PublishSponsorsTier */
type PublishSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft tier to publish. */
  readonly tierId: Scalars['ID']['input'];
};

/** Autogenerated return type of PublishSponsorsTier */
type PublishSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was published. */
  readonly sponsorsTier?: Maybe<SponsorsTier>;
};

/** A repository pull request. */
type PullRequest = Assignable & Closable & Comment & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** Reason that the conversation was locked. */
  readonly activeLockReason?: Maybe<LockReason>;
  /** The number of additions in this pull request. */
  readonly additions: Scalars['Int']['output'];
  /** A list of Users assigned to this object. */
  readonly assignees: UserConnection;
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** Returns the auto-merge request object if one exists for this pull request. */
  readonly autoMergeRequest?: Maybe<AutoMergeRequest>;
  /** Identifies the base Ref associated with the pull request. */
  readonly baseRef?: Maybe<Ref>;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  readonly baseRefName: Scalars['String']['output'];
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  readonly baseRefOid: Scalars['GitObjectID']['output'];
  /** The repository associated with this pull request's base Ref. */
  readonly baseRepository?: Maybe<Repository>;
  /** The body as Markdown. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /** Whether or not the pull request is rebaseable. */
  readonly canBeRebased: Scalars['Boolean']['output'];
  /** The number of changed files in this pull request. */
  readonly changedFiles: Scalars['Int']['output'];
  /** The HTTP path for the checks of this pull request. */
  readonly checksResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the checks of this pull request. */
  readonly checksUrl: Scalars['URI']['output'];
  /** `true` if the pull request is closed */
  readonly closed: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was closed. */
  readonly closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** List of issues that were may be closed by this pull request */
  readonly closingIssuesReferences?: Maybe<IssueConnection>;
  /** A list of comments associated with the pull request. */
  readonly comments: IssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  readonly commits: PullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The number of deletions in this pull request. */
  readonly deletions: Scalars['Int']['output'];
  /** The actor who edited this pull request's body. */
  readonly editor?: Maybe<Actor>;
  /** Lists the files changed within this pull request. */
  readonly files?: Maybe<PullRequestChangedFileConnection>;
  /** Identifies the head Ref associated with the pull request. */
  readonly headRef?: Maybe<Ref>;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  readonly headRefName: Scalars['String']['output'];
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  readonly headRefOid: Scalars['GitObjectID']['output'];
  /** The repository associated with this pull request's head Ref. */
  readonly headRepository?: Maybe<Repository>;
  /** The owner of the repository associated with this pull request's head Ref. */
  readonly headRepositoryOwner?: Maybe<RepositoryOwner>;
  /** The hovercard information for this issue */
  readonly hovercard: Hovercard;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** The head and base repositories are different. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
  /** Identifies if the pull request is a draft. */
  readonly isDraft: Scalars['Boolean']['output'];
  /** Is this pull request read by the viewer */
  readonly isReadByViewer?: Maybe<Scalars['Boolean']['output']>;
  /** A list of labels associated with the object. */
  readonly labels?: Maybe<LabelConnection>;
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of latest reviews per user associated with the pull request. */
  readonly latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>;
  /** A list of latest reviews per user associated with the pull request that are not also pending review. */
  readonly latestReviews?: Maybe<PullRequestReviewConnection>;
  /** `true` if the pull request is locked */
  readonly locked: Scalars['Boolean']['output'];
  /** Indicates whether maintainers can modify the pull request. */
  readonly maintainerCanModify: Scalars['Boolean']['output'];
  /** The commit that was created when this pull request was merged. */
  readonly mergeCommit?: Maybe<Commit>;
  /** The merge queue entry of the pull request in the base branch's merge queue */
  readonly mergeQueueEntry?: Maybe<MergeQueueEntry>;
  /** Detailed information about the current pull request merge state status. */
  readonly mergeStateStatus: MergeStateStatus;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  readonly mergeable: MergeableState;
  /** Whether or not the pull request was merged. */
  readonly merged: Scalars['Boolean']['output'];
  /** The date and time that the pull request was merged. */
  readonly mergedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who merged the pull request. */
  readonly mergedBy?: Maybe<Actor>;
  /** Identifies the milestone associated with the pull request. */
  readonly milestone?: Maybe<Milestone>;
  /** Identifies the pull request number. */
  readonly number: Scalars['Int']['output'];
  /** A list of Users that are participating in the Pull Request conversation. */
  readonly participants: UserConnection;
  /** The permalink to the pull request. */
  readonly permalink: Scalars['URI']['output'];
  /**
   * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
   */
  readonly potentialMergeCommit?: Maybe<Commit>;
  /** List of project cards associated with this pull request. */
  readonly projectCards: ProjectCardConnection;
  /** List of project items associated with this pull request. */
  readonly projectItems: ProjectV2ItemConnection;
  /** Find a project by number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  readonly projectsV2: ProjectV2Connection;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The HTTP path for this pull request. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP path for reverting this pull request. */
  readonly revertResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for reverting this pull request. */
  readonly revertUrl: Scalars['URI']['output'];
  /** The current status of this pull request with respect to code review. */
  readonly reviewDecision?: Maybe<PullRequestReviewDecision>;
  /** A list of review requests associated with the pull request. */
  readonly reviewRequests?: Maybe<ReviewRequestConnection>;
  /** The list of all review threads for this pull request. */
  readonly reviewThreads: PullRequestReviewThreadConnection;
  /** A list of reviews associated with the pull request. */
  readonly reviews?: Maybe<PullRequestReviewConnection>;
  /** Identifies the state of the pull request. */
  readonly state: PullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  readonly suggestedReviewers: ReadonlyArray<Maybe<SuggestedReviewer>>;
  /**
   * A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  readonly timeline: PullRequestTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the pull request. */
  readonly timelineItems: PullRequestTimelineItemsConnection;
  /** Identifies the pull request title. */
  readonly title: Scalars['String']['output'];
  /** Identifies the pull request title rendered to HTML. */
  readonly titleHTML: Scalars['HTML']['output'];
  /** Returns a count of how many comments this pull request has received. */
  readonly totalCommentsCount?: Maybe<Scalars['Int']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this pull request. */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Whether or not the viewer can apply suggestion. */
  readonly viewerCanApplySuggestion: Scalars['Boolean']['output'];
  /** Indicates if the object can be closed by the viewer. */
  readonly viewerCanClose: Scalars['Boolean']['output'];
  /** Check if the viewer can restore the deleted head ref. */
  readonly viewerCanDeleteHeadRef: Scalars['Boolean']['output'];
  /** Whether or not the viewer can disable auto-merge */
  readonly viewerCanDisableAutoMerge: Scalars['Boolean']['output'];
  /** Can the viewer edit files within this pull request. */
  readonly viewerCanEditFiles: Scalars['Boolean']['output'];
  /** Whether or not the viewer can enable auto-merge */
  readonly viewerCanEnableAutoMerge: Scalars['Boolean']['output'];
  /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */
  readonly viewerCanMergeAsAdmin: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Indicates if the object can be reopened by the viewer. */
  readonly viewerCanReopen: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /**
   * Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.
   * If the head ref is up to date or unable to be updated by this user, this will return false.
   */
  readonly viewerCanUpdateBranch: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
  /** The latest review given from the viewer. */
  readonly viewerLatestReview?: Maybe<PullRequestReview>;
  /** The person who has requested the viewer for review on this pull request. */
  readonly viewerLatestReviewRequest?: Maybe<ReviewRequest>;
  /** The merge body text for the viewer and method. */
  readonly viewerMergeBodyText: Scalars['String']['output'];
  /** The merge headline text for the viewer and method. */
  readonly viewerMergeHeadlineText: Scalars['String']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
};


/** A repository pull request. */
type PullRequestAssigneesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestClosingIssuesReferencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  userLinkedOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
type PullRequestCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};


/** A repository pull request. */
type PullRequestCommitsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestFilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestHovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
type PullRequestLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
};


/** A repository pull request. */
type PullRequestLatestOpinionatedReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  writersOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository pull request. */
type PullRequestLatestReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestProjectCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  archivedStates?: InputMaybe<ReadonlyArray<InputMaybe<ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestProjectItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** A repository pull request. */
type PullRequestProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository pull request. */
type PullRequestReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A repository pull request. */
type PullRequestReviewRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestReviewThreadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<ReadonlyArray<PullRequestReviewState>>;
};


/** A repository pull request. */
type PullRequestTimelineArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A repository pull request. */
type PullRequestTimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  itemTypes?: InputMaybe<ReadonlyArray<PullRequestTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository pull request. */
type PullRequestViewerMergeBodyTextArgs = {
  mergeType?: InputMaybe<PullRequestMergeMethod>;
};


/** A repository pull request. */
type PullRequestViewerMergeHeadlineTextArgs = {
  mergeType?: InputMaybe<PullRequestMergeMethod>;
};

/** The possible methods for updating a pull request's head branch with the base branch. */
enum PullRequestBranchUpdateMethod {
  /** Update branch via merge */
  Merge = 'MERGE',
  /** Update branch via rebase */
  Rebase = 'REBASE'
}

/** A file changed in a pull request. */
type PullRequestChangedFile = {
  /** The number of additions to the file. */
  readonly additions: Scalars['Int']['output'];
  /** How the file was changed in this PullRequest */
  readonly changeType: PatchStatus;
  /** The number of deletions to the file. */
  readonly deletions: Scalars['Int']['output'];
  /** The path of the file. */
  readonly path: Scalars['String']['output'];
  /** The state of the file for the viewer. */
  readonly viewerViewedState: FileViewedState;
};

/** The connection type for PullRequestChangedFile. */
type PullRequestChangedFileConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PullRequestChangedFileEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
type PullRequestCommit = Node & UniformResourceLocatable & {
  /** The Git commit object */
  readonly commit: Commit;
  readonly id: Scalars['ID']['output'];
  /** The pull request this commit belongs to */
  readonly pullRequest: PullRequest;
  /** The HTTP path for this pull request commit */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this pull request commit */
  readonly url: Scalars['URI']['output'];
};

/** Represents a commit comment thread part of a pull request. */
type PullRequestCommitCommentThread = Node & RepositoryNode & {
  /** The comments that exist in this thread. */
  readonly comments: CommitCommentConnection;
  /** The commit the comments were made on. */
  readonly commit: Commit;
  readonly id: Scalars['ID']['output'];
  /** The file the comments were made on. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** The position in the diff for the commit that the comment was made on. */
  readonly position?: Maybe<Scalars['Int']['output']>;
  /** The pull request this commit comment thread belongs to */
  readonly pullRequest: PullRequest;
  /** The repository associated with this node. */
  readonly repository: Repository;
};


/** Represents a commit comment thread part of a pull request. */
type PullRequestCommitCommentThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestCommit. */
type PullRequestCommitConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestCommitEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestCommit>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PullRequestCommitEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestCommit>;
};

/** The connection type for PullRequest. */
type PullRequestConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequest>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** This aggregates pull requests opened by a user within one repository. */
type PullRequestContributionsByRepository = {
  /** The pull request contributions. */
  readonly contributions: CreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  readonly repository: Repository;
};


/** This aggregates pull requests opened by a user within one repository. */
type PullRequestContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** An edge in a connection. */
type PullRequestEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
enum PullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = 'MERGE',
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = 'REBASE',
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = 'SQUASH'
}

/** Ways in which lists of issues can be ordered upon return. */
type PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order pull requests by. */
  readonly field: PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
enum PullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order pull_requests by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
type PullRequestParameters = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  readonly dismissStaleReviewsOnPush: Scalars['Boolean']['output'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  readonly requireCodeOwnerReview: Scalars['Boolean']['output'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  readonly requireLastPushApproval: Scalars['Boolean']['output'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  readonly requiredApprovingReviewCount: Scalars['Int']['output'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  readonly requiredReviewThreadResolution: Scalars['Boolean']['output'];
};

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
type PullRequestParametersInput = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  readonly dismissStaleReviewsOnPush: Scalars['Boolean']['input'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  readonly requireCodeOwnerReview: Scalars['Boolean']['input'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  readonly requireLastPushApproval: Scalars['Boolean']['input'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  readonly requiredApprovingReviewCount: Scalars['Int']['input'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  readonly requiredReviewThreadResolution: Scalars['Boolean']['input'];
};

/** A review object for a given pull request. */
type PullRequestReview = Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** Indicates whether the author of this review has push access to the repository. */
  readonly authorCanPushToRepository: Scalars['Boolean']['output'];
  /** Identifies the pull request review body. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body of this review rendered as plain text. */
  readonly bodyText: Scalars['String']['output'];
  /** A list of review comments for the current pull request review. */
  readonly comments: PullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  readonly commit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of teams that this review was made on behalf of. */
  readonly onBehalfOf: TeamConnection;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the pull request associated with this pull request review. */
  readonly pullRequest: PullRequest;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The HTTP path permalink for this PullRequestReview. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the current state of the pull request review. */
  readonly state: PullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  readonly submittedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this PullRequestReview. */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A review object for a given pull request. */
type PullRequestReviewCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A review object for a given pull request. */
type PullRequestReviewOnBehalfOfArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A review object for a given pull request. */
type PullRequestReviewReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A review object for a given pull request. */
type PullRequestReviewUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A review comment associated with a given repository pull request. */
type PullRequestReviewComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /** Author's association with the subject of the comment. */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The comment body of this review comment. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The comment body of this review comment rendered as plain text. */
  readonly bodyText: Scalars['String']['output'];
  /** Identifies the commit associated with the comment. */
  readonly commit?: Maybe<Commit>;
  /** Identifies when the comment was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The diff hunk to which the comment applies. */
  readonly diffHunk: Scalars['String']['output'];
  /** Identifies when the comment was created in a draft state. */
  readonly draftedAt: Scalars['DateTime']['output'];
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** Returns whether or not a comment has been minimized. */
  readonly isMinimized: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The end line number on the file to which the comment applies */
  readonly line?: Maybe<Scalars['Int']['output']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  readonly minimizedReason?: Maybe<Scalars['String']['output']>;
  /** Identifies the original commit associated with the comment. */
  readonly originalCommit?: Maybe<Commit>;
  /** The end line number on the file to which the comment applied when it was first created */
  readonly originalLine?: Maybe<Scalars['Int']['output']>;
  /**
   * The original line index in the diff to which the comment applies.
   * @deprecated We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.
   */
  readonly originalPosition: Scalars['Int']['output'];
  /** The start line number on the file to which the comment applied when it was first created */
  readonly originalStartLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment body is outdated */
  readonly outdated: Scalars['Boolean']['output'];
  /** The path to which the comment applies. */
  readonly path: Scalars['String']['output'];
  /**
   * The line index in the diff to which the comment applies.
   * @deprecated We are phasing out diff-relative positioning for PR comments Use the `line` and `startLine` fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC.
   */
  readonly position?: Maybe<Scalars['Int']['output']>;
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The pull request associated with this review comment. */
  readonly pullRequest: PullRequest;
  /** The pull request review associated with this review comment. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** The comment this is a reply to. */
  readonly replyTo?: Maybe<PullRequestReviewComment>;
  /** The repository associated with this node. */
  readonly repository: Repository;
  /** The HTTP path permalink for this review comment. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The start line number on the file to which the comment applies */
  readonly startLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies the state of the comment. */
  readonly state: PullRequestReviewCommentState;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  readonly subjectType: PullRequestReviewThreadSubjectType;
  /** Identifies when the comment was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL permalink for this review comment. */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Check if the current viewer can minimize this object. */
  readonly viewerCanMinimize: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A review comment associated with a given repository pull request. */
type PullRequestReviewCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A review comment associated with a given repository pull request. */
type PullRequestReviewCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestReviewComment. */
type PullRequestReviewCommentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PullRequestReviewCommentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
enum PullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = 'PENDING',
  /** A comment that is part of a submitted review */
  Submitted = 'SUBMITTED'
}

/** The connection type for PullRequestReview. */
type PullRequestReviewConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestReviewEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestReview>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** This aggregates pull request reviews made by a user within one repository. */
type PullRequestReviewContributionsByRepository = {
  /** The pull request review contributions. */
  readonly contributions: CreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  readonly repository: Repository;
};


/** This aggregates pull request reviews made by a user within one repository. */
type PullRequestReviewContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributionOrder>;
};

/** The review status of a pull request. */
enum PullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = 'APPROVED',
  /** Changes have been requested on the pull request. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** A review is required before the pull request can be merged. */
  ReviewRequired = 'REVIEW_REQUIRED'
}

/** An edge in a connection. */
type PullRequestReviewEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestReview>;
};

/** The possible events to perform on a pull request review. */
enum PullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = 'APPROVE',
  /** Submit general feedback without explicit approval. */
  Comment = 'COMMENT',
  /** Dismiss review so it now longer effects merging. */
  Dismiss = 'DISMISS',
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = 'REQUEST_CHANGES'
}

/** The possible states of a pull request review. */
enum PullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = 'APPROVED',
  /** A review blocking the pull request from merging. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** An informational review. */
  Commented = 'COMMENTED',
  /** A review that has been dismissed. */
  Dismissed = 'DISMISSED',
  /** A review that has not yet been submitted. */
  Pending = 'PENDING'
}

/** A threaded list of comments for a given pull request. */
type PullRequestReviewThread = Node & {
  /** A list of pull request comments associated with the thread. */
  readonly comments: PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  readonly diffSide: DiffSide;
  readonly id: Scalars['ID']['output'];
  /** Whether or not the thread has been collapsed (resolved) */
  readonly isCollapsed: Scalars['Boolean']['output'];
  /** Indicates whether this thread was outdated by newer changes. */
  readonly isOutdated: Scalars['Boolean']['output'];
  /** Whether this thread has been resolved */
  readonly isResolved: Scalars['Boolean']['output'];
  /** The line in the file to which this thread refers */
  readonly line?: Maybe<Scalars['Int']['output']>;
  /** The original line in the file to which this thread refers. */
  readonly originalLine?: Maybe<Scalars['Int']['output']>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  readonly originalStartLine?: Maybe<Scalars['Int']['output']>;
  /** Identifies the file path of this thread. */
  readonly path: Scalars['String']['output'];
  /** Identifies the pull request associated with this thread. */
  readonly pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  readonly repository: Repository;
  /** The user who resolved this thread */
  readonly resolvedBy?: Maybe<User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  readonly startDiffSide?: Maybe<DiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  readonly startLine?: Maybe<Scalars['Int']['output']>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  readonly subjectType: PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  readonly viewerCanReply: Scalars['Boolean']['output'];
  /** Whether or not the viewer can resolve this thread */
  readonly viewerCanResolve: Scalars['Boolean']['output'];
  /** Whether or not the viewer can unresolve this thread */
  readonly viewerCanUnresolve: Scalars['Boolean']['output'];
};


/** A threaded list of comments for a given pull request. */
type PullRequestReviewThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};

/** Review comment threads for a pull request review. */
type PullRequestReviewThreadConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PullRequestReviewThreadEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestReviewThread>;
};

/** The possible subject types of a pull request review comment. */
enum PullRequestReviewThreadSubjectType {
  /** A comment that has been made against the file of a pull request */
  File = 'FILE',
  /** A comment that has been made against the line of a pull request */
  Line = 'LINE'
}

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
type PullRequestRevisionMarker = {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The last commit the viewer has seen. */
  readonly lastSeenCommit: Commit;
  /** The pull request to which the marker belongs. */
  readonly pullRequest: PullRequest;
};

/** The possible states of a pull request. */
enum PullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that has been closed by being merged. */
  Merged = 'MERGED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}

/** A repository pull request template. */
type PullRequestTemplate = {
  /** The body of the template */
  readonly body?: Maybe<Scalars['String']['output']>;
  /** The filename of the template */
  readonly filename?: Maybe<Scalars['String']['output']>;
  /** The repository the template belongs to */
  readonly repository: Repository;
};

/** A threaded list of comments for a given pull request. */
type PullRequestThread = Node & {
  /** A list of pull request comments associated with the thread. */
  readonly comments: PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  readonly diffSide: DiffSide;
  readonly id: Scalars['ID']['output'];
  /** Whether or not the thread has been collapsed (resolved) */
  readonly isCollapsed: Scalars['Boolean']['output'];
  /** Indicates whether this thread was outdated by newer changes. */
  readonly isOutdated: Scalars['Boolean']['output'];
  /** Whether this thread has been resolved */
  readonly isResolved: Scalars['Boolean']['output'];
  /** The line in the file to which this thread refers */
  readonly line?: Maybe<Scalars['Int']['output']>;
  /** Identifies the file path of this thread. */
  readonly path: Scalars['String']['output'];
  /** Identifies the pull request associated with this thread. */
  readonly pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  readonly repository: Repository;
  /** The user who resolved this thread */
  readonly resolvedBy?: Maybe<User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  readonly startDiffSide?: Maybe<DiffSide>;
  /** The line of the first file diff in the thread. */
  readonly startLine?: Maybe<Scalars['Int']['output']>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  readonly subjectType: PullRequestReviewThreadSubjectType;
  /** Indicates whether the current viewer can reply to this thread. */
  readonly viewerCanReply: Scalars['Boolean']['output'];
  /** Whether or not the viewer can resolve this thread */
  readonly viewerCanResolve: Scalars['Boolean']['output'];
  /** Whether or not the viewer can unresolve this thread */
  readonly viewerCanUnresolve: Scalars['Boolean']['output'];
};


/** A threaded list of comments for a given pull request. */
type PullRequestThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PullRequestTimelineItem. */
type PullRequestTimelineConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An item in a pull request timeline */
type PullRequestTimelineItem = AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;

/** An edge in a connection. */
type PullRequestTimelineItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestTimelineItem>;
};

/** An item in a pull request timeline */
type PullRequestTimelineItems = AddedToMergeQueueEvent | AddedToProjectEvent | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
type PullRequestTimelineItemsConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  readonly filteredCount: Scalars['Int']['output'];
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  readonly pageCount: Scalars['Int']['output'];
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** Identifies the date and time when the timeline was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** An edge in a connection. */
type PullRequestTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
enum PullRequestTimelineItemsItemType {
  /** Represents an 'added_to_merge_queue' event on a given pull request. */
  AddedToMergeQueueEvent = 'ADDED_TO_MERGE_QUEUE_EVENT',
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = 'DEPLOYED_EVENT',
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = 'MERGED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = 'PULL_REQUEST_COMMIT',
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',
  /** A review object for a given pull request. */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_merge_queue' event on a given pull request. */
  RemovedFromMergeQueueEvent = 'REMOVED_FROM_MERGE_QUEUE_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** The possible target states when updating a pull request. */
enum PullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}

/** A Git push. */
type Push = Node & {
  readonly id: Scalars['ID']['output'];
  /** The SHA after the push */
  readonly nextSha?: Maybe<Scalars['GitObjectID']['output']>;
  /** The permalink for this push. */
  readonly permalink: Scalars['URI']['output'];
  /** The SHA before the push */
  readonly previousSha?: Maybe<Scalars['GitObjectID']['output']>;
  /** The actor who pushed */
  readonly pusher: Actor;
  /** The repository that was pushed to */
  readonly repository: Repository;
};

/** A team, user, or app who has the ability to push to a protected branch. */
type PushAllowance = Node & {
  /** The actor that can push. */
  readonly actor?: Maybe<PushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  readonly id: Scalars['ID']['output'];
};

/** Types that can be an actor. */
type PushAllowanceActor = App | Team | User;

/** The connection type for PushAllowance. */
type PushAllowanceConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PushAllowanceEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<PushAllowance>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type PushAllowanceEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<PushAllowance>;
};

/** The query root of GitHub's GraphQL interface. */
type Query = {
  /** Look up a code of conduct by its key */
  readonly codeOfConduct?: Maybe<CodeOfConduct>;
  /** Look up a code of conduct by its key */
  readonly codesOfConduct?: Maybe<ReadonlyArray<Maybe<CodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  readonly enterprise?: Maybe<Enterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  readonly enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  readonly enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>;
  /** Look up an open source license by its key */
  readonly license?: Maybe<License>;
  /** Return a list of known open source licenses */
  readonly licenses: ReadonlyArray<Maybe<License>>;
  /** Get alphabetically sorted list of Marketplace categories */
  readonly marketplaceCategories: ReadonlyArray<MarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  readonly marketplaceCategory?: Maybe<MarketplaceCategory>;
  /** Look up a single Marketplace listing */
  readonly marketplaceListing?: Maybe<MarketplaceListing>;
  /** Look up Marketplace listings */
  readonly marketplaceListings: MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  readonly meta: GitHubMetadata;
  /** Fetches an object given its ID. */
  readonly node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  readonly nodes: ReadonlyArray<Maybe<Node>>;
  /** Lookup a organization by login. */
  readonly organization?: Maybe<Organization>;
  /** The client's rate limit information. */
  readonly rateLimit?: Maybe<RateLimit>;
  /**
   * Workaround for re-exposing the root query object. (Refer to
   * https://github.com/facebook/relay/issues/112 for more information.)
   */
  readonly relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  readonly repository?: Maybe<Repository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  readonly repositoryOwner?: Maybe<RepositoryOwner>;
  /** Lookup resource by a URL. */
  readonly resource?: Maybe<UniformResourceLocatable>;
  /** Perform a search across resources, returning a maximum of 1,000 results. */
  readonly search: SearchResultItemConnection;
  /** GitHub Security Advisories */
  readonly securityAdvisories: SecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  readonly securityAdvisory?: Maybe<SecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  readonly securityVulnerabilities: SecurityVulnerabilityConnection;
  /** Users and organizations who can be sponsored via GitHub Sponsors. */
  readonly sponsorables: SponsorableItemConnection;
  /** Look up a topic by name. */
  readonly topic?: Maybe<Topic>;
  /** Lookup a user by login. */
  readonly user?: Maybe<User>;
  /** The currently authenticated user. */
  readonly viewer: User;
};


/** The query root of GitHub's GraphQL interface. */
type QueryCodeOfConductArgs = {
  key: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryEnterpriseArgs = {
  invitationToken?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryEnterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars['String']['input'];
  role: EnterpriseAdministratorRole;
  userLogin: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryEnterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryLicenseArgs = {
  key: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryMarketplaceCategoriesArgs = {
  excludeEmpty?: InputMaybe<Scalars['Boolean']['input']>;
  excludeSubcategories?: InputMaybe<Scalars['Boolean']['input']>;
  includeCategories?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** The query root of GitHub's GraphQL interface. */
type QueryMarketplaceCategoryArgs = {
  slug: Scalars['String']['input'];
  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
type QueryMarketplaceListingArgs = {
  slug: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryMarketplaceListingsArgs = {
  adminId?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  allStates?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categorySlug?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  organizationId?: InputMaybe<Scalars['ID']['input']>;
  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']['input']>;
  slugs?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  useTopicAliases?: InputMaybe<Scalars['Boolean']['input']>;
  viewerCanAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryNodesArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
type QueryOrganizationArgs = {
  login: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryRateLimitArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
type QueryRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  owner: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryRepositoryOwnerArgs = {
  login: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryResourceArgs = {
  url: Scalars['URI']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QuerySearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query: Scalars['String']['input'];
  type: SearchType;
};


/** The query root of GitHub's GraphQL interface. */
type QuerySecurityAdvisoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<ReadonlyArray<SecurityAdvisoryClassification>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<SecurityAdvisoryIdentifierFilter>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SecurityAdvisoryOrder>;
  publishedSince?: InputMaybe<Scalars['DateTime']['input']>;
  updatedSince?: InputMaybe<Scalars['DateTime']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
type QuerySecurityAdvisoryArgs = {
  ghsaId: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QuerySecurityVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<ReadonlyArray<SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<ReadonlyArray<SecurityAdvisorySeverity>>;
};


/** The query root of GitHub's GraphQL interface. */
type QuerySponsorablesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependencyEcosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  ecosystem?: InputMaybe<DependencyGraphEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyDependencies?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<SponsorableOrder>;
  orgLoginForDependencies?: InputMaybe<Scalars['String']['input']>;
};


/** The query root of GitHub's GraphQL interface. */
type QueryTopicArgs = {
  name: Scalars['String']['input'];
};


/** The query root of GitHub's GraphQL interface. */
type QueryUserArgs = {
  login: Scalars['String']['input'];
};

/** Represents the client's rate limit. */
type RateLimit = {
  /** The point cost for the current query counting against the rate limit. */
  readonly cost: Scalars['Int']['output'];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  readonly limit: Scalars['Int']['output'];
  /** The maximum number of nodes this query may return */
  readonly nodeCount: Scalars['Int']['output'];
  /** The number of points remaining in the current rate limit window. */
  readonly remaining: Scalars['Int']['output'];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  readonly resetAt: Scalars['DateTime']['output'];
  /** The number of points used in the current rate limit window. */
  readonly used: Scalars['Int']['output'];
};

/** Represents a subject that can be reacted on. */
type Reactable = {
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
};


/** Represents a subject that can be reacted on. */
type ReactableReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};

/** The connection type for User. */
type ReactingUserConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReactingUserEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a user that's made a reaction. */
type ReactingUserEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  readonly node: User;
  /** The moment when the user made the reaction. */
  readonly reactedAt: Scalars['DateTime']['output'];
};

/** An emoji reaction to a particular piece of content. */
type Reaction = Node & {
  /** Identifies the emoji reaction. */
  readonly content: ReactionContent;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The reactable piece of content */
  readonly reactable: Reactable;
  /** Identifies the user who created this reaction. */
  readonly user?: Maybe<User>;
};

/** A list of reactions that have been left on the subject. */
type ReactionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReactionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Reaction>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  readonly viewerHasReacted: Scalars['Boolean']['output'];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
enum ReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = 'CONFUSED',
  /** Represents the `:eyes:` emoji. */
  Eyes = 'EYES',
  /** Represents the `:heart:` emoji. */
  Heart = 'HEART',
  /** Represents the `:hooray:` emoji. */
  Hooray = 'HOORAY',
  /** Represents the `:laugh:` emoji. */
  Laugh = 'LAUGH',
  /** Represents the `:rocket:` emoji. */
  Rocket = 'ROCKET',
  /** Represents the `:-1:` emoji. */
  ThumbsDown = 'THUMBS_DOWN',
  /** Represents the `:+1:` emoji. */
  ThumbsUp = 'THUMBS_UP'
}

/** An edge in a connection. */
type ReactionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Reaction>;
};

/** A group of emoji reactions to a particular piece of content. */
type ReactionGroup = {
  /** Identifies the emoji reaction. */
  readonly content: ReactionContent;
  /** Identifies when the reaction was created. */
  readonly createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Reactors to the reaction subject with the emotion represented by this reaction group. */
  readonly reactors: ReactorConnection;
  /** The subject that was reacted to. */
  readonly subject: Reactable;
  /**
   * Users who have reacted to the reaction subject with the emotion represented by this reaction group
   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.
   */
  readonly users: ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  readonly viewerHasReacted: Scalars['Boolean']['output'];
};


/** A group of emoji reactions to a particular piece of content. */
type ReactionGroupReactorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A group of emoji reactions to a particular piece of content. */
type ReactionGroupUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Ways in which lists of reactions can be ordered upon return. */
type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order reactions by. */
  readonly field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
enum ReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Types that can be assigned to reactions. */
type Reactor = Bot | Mannequin | Organization | User;

/** The connection type for Reactor. */
type ReactorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReactorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Reactor>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents an author of a reaction. */
type ReactorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The author of the reaction. */
  readonly node: Reactor;
  /** The moment when the user made the reaction. */
  readonly reactedAt: Scalars['DateTime']['output'];
};

/** Represents a 'ready_for_review' event on a given pull request. */
type ReadyForReviewEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** The HTTP path for this ready for review event. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this ready for review event. */
  readonly url: Scalars['URI']['output'];
};

/** Represents a Git reference. */
type Ref = Node & {
  /** A list of pull requests with this ref as the head ref. */
  readonly associatedPullRequests: PullRequestConnection;
  /** Branch protection rules for this ref */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */
  readonly compare?: Maybe<Comparison>;
  readonly id: Scalars['ID']['output'];
  /** The ref name. */
  readonly name: Scalars['String']['output'];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  readonly prefix: Scalars['String']['output'];
  /** Branch protection rules that are viewable by non-admins */
  readonly refUpdateRule?: Maybe<RefUpdateRule>;
  /** The repository the ref belongs to. */
  readonly repository: Repository;
  /** The object the ref points to. Returns null when object does not exist. */
  readonly target?: Maybe<GitObject>;
};


/** Represents a Git reference. */
type RefAssociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<PullRequestState>>;
};


/** Represents a Git reference. */
type RefCompareArgs = {
  headRef: Scalars['String']['input'];
};

/** The connection type for Ref. */
type RefConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RefEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Ref>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RefEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Ref>;
};

/** Parameters to be used for the ref_name condition */
type RefNameConditionTarget = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  readonly exclude: ReadonlyArray<Scalars['String']['output']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  readonly include: ReadonlyArray<Scalars['String']['output']>;
};

/** Parameters to be used for the ref_name condition */
type RefNameConditionTargetInput = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  readonly exclude: ReadonlyArray<Scalars['String']['input']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  readonly include: ReadonlyArray<Scalars['String']['input']>;
};

/** Ways in which lists of git refs can be ordered upon return. */
type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order refs by. */
  readonly field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
enum RefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = 'ALPHABETICAL',
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = 'TAG_COMMIT_DATE'
}

/** A ref update */
type RefUpdate = {
  /** The value this ref should be updated to. */
  readonly afterOid: Scalars['GitObjectID']['input'];
  /** The value this ref needs to point to before the update. */
  readonly beforeOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** Force a non fast-forward update. */
  readonly force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  readonly name: Scalars['GitRefname']['input'];
};

/** A ref update rules for a viewer. */
type RefUpdateRule = {
  /** Can this branch be deleted. */
  readonly allowsDeletions: Scalars['Boolean']['output'];
  /** Are force pushes allowed on this branch. */
  readonly allowsForcePushes: Scalars['Boolean']['output'];
  /** Can matching branches be created. */
  readonly blocksCreations: Scalars['Boolean']['output'];
  /** Identifies the protection rule pattern. */
  readonly pattern: Scalars['String']['output'];
  /** Number of approving reviews required to update matching branches. */
  readonly requiredApprovingReviewCount?: Maybe<Scalars['Int']['output']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusCheckContexts?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  /** Are reviews from code owners required to update matching branches. */
  readonly requiresCodeOwnerReviews: Scalars['Boolean']['output'];
  /** Are conversations required to be resolved before merging. */
  readonly requiresConversationResolution: Scalars['Boolean']['output'];
  /** Are merge commits prohibited from being pushed to this branch. */
  readonly requiresLinearHistory: Scalars['Boolean']['output'];
  /** Are commits required to be signed. */
  readonly requiresSignatures: Scalars['Boolean']['output'];
  /** Is the viewer allowed to dismiss reviews. */
  readonly viewerAllowedToDismissReviews: Scalars['Boolean']['output'];
  /** Can the viewer push to the branch */
  readonly viewerCanPush: Scalars['Boolean']['output'];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
type ReferencedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the commit associated with the 'referenced' event. */
  readonly commit?: Maybe<Commit>;
  /** Identifies the repository associated with the 'referenced' event. */
  readonly commitRepository: Repository;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Reference originated in a different repository. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  readonly isDirectReference: Scalars['Boolean']['output'];
  /** Object referenced by event. */
  readonly subject: ReferencedSubject;
};

/** Any referencable object */
type ReferencedSubject = Issue | PullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set an identity provider. */
  readonly enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider for the enterprise. */
  readonly identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
type RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of RegenerateVerifiableDomainToken */
type RegenerateVerifiableDomainTokenPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verification token that was generated. */
  readonly verificationToken?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RejectDeployments */
type RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for rejecting deployments */
  readonly comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  readonly environmentIds: ReadonlyArray<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  readonly workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated return type of RejectDeployments */
type RejectDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The affected deployments. */
  readonly deployments?: Maybe<ReadonlyArray<Deployment>>;
};

/** A release contains the content for a release. */
type Release = Node & Reactable & UniformResourceLocatable & {
  /** The author of the release */
  readonly author?: Maybe<User>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the release. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The description of this release rendered to HTML. */
  readonly descriptionHTML?: Maybe<Scalars['HTML']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Whether or not the release is a draft */
  readonly isDraft: Scalars['Boolean']['output'];
  /** Whether or not the release is the latest releast */
  readonly isLatest: Scalars['Boolean']['output'];
  /** Whether or not the release is a prerelease */
  readonly isPrerelease: Scalars['Boolean']['output'];
  /** A list of users mentioned in the release description */
  readonly mentions?: Maybe<UserConnection>;
  /** The title of the release. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the release was created. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /** List of releases assets which are dependent on this release. */
  readonly releaseAssets: ReleaseAssetConnection;
  /** The repository that the release belongs to. */
  readonly repository: Repository;
  /** The HTTP path for this issue */
  readonly resourcePath: Scalars['URI']['output'];
  /** A description of the release, rendered to HTML without any links in it. */
  readonly shortDescriptionHTML?: Maybe<Scalars['HTML']['output']>;
  /** The Git tag the release points to */
  readonly tag?: Maybe<Ref>;
  /** The tag commit for this release. */
  readonly tagCommit?: Maybe<Commit>;
  /** The name of the release's Git tag */
  readonly tagName: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this issue */
  readonly url: Scalars['URI']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
};


/** A release contains the content for a release. */
type ReleaseMentionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A release contains the content for a release. */
type ReleaseReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A release contains the content for a release. */
type ReleaseReleaseAssetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


/** A release contains the content for a release. */
type ReleaseShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A release asset contains the content for a release asset. */
type ReleaseAsset = Node & {
  /** The asset's content-type */
  readonly contentType: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The number of times this asset was downloaded */
  readonly downloadCount: Scalars['Int']['output'];
  /** Identifies the URL where you can download the release asset via the browser. */
  readonly downloadUrl: Scalars['URI']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the title of the release asset. */
  readonly name: Scalars['String']['output'];
  /** Release that the asset is associated with */
  readonly release?: Maybe<Release>;
  /** The size (in bytes) of the asset */
  readonly size: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The user that performed the upload */
  readonly uploadedBy: User;
  /** Identifies the URL of the release asset. */
  readonly url: Scalars['URI']['output'];
};

/** The connection type for ReleaseAsset. */
type ReleaseAssetConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReleaseAssetEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ReleaseAsset>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ReleaseAssetEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ReleaseAsset>;
};

/** The connection type for Release. */
type ReleaseConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Release>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ReleaseEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Release>;
};

/** Ways in which lists of releases can be ordered upon return. */
type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  readonly direction: OrderDirection;
  /** The field in which to order releases by. */
  readonly field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
enum ReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order releases alphabetically by name */
  Name = 'NAME'
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
type RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  readonly assignableId: Scalars['ID']['input'];
  /** The id of users to remove as assignees. */
  readonly assigneeIds: ReadonlyArray<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
type RemoveAssigneesFromAssignablePayload = {
  /** The item that was unassigned. */
  readonly assignable?: Maybe<Assignable>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
type RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID from which to remove the administrator. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of the user to remove as an administrator. */
  readonly login: Scalars['String']['input'];
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
type RemoveEnterpriseAdminPayload = {
  /** The user who was removed as an administrator. */
  readonly admin?: Maybe<User>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of removing an administrator. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The viewer performing the mutation. */
  readonly viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
type RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  readonly enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider */
type RemoveEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider that was removed from the enterprise. */
  readonly identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseMember */
type RemoveEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the user should be removed. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The ID of the user to remove from the enterprise. */
  readonly userId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseMember */
type RemoveEnterpriseMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  readonly enterprise?: Maybe<Enterprise>;
  /** The user that was removed from the enterprise. */
  readonly user?: Maybe<User>;
  /** The viewer performing the mutation. */
  readonly viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
type RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the organization should be removed. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to remove from the enterprise. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
type RemoveEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  readonly enterprise?: Maybe<Enterprise>;
  /** The organization that was removed from the enterprise. */
  readonly organization?: Maybe<Organization>;
  /** The viewer performing the mutation. */
  readonly viewer?: Maybe<User>;
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
type RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will lose the support entitlement. */
  readonly login: Scalars['String']['input'];
};

/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */
type RemoveEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of removing the support entitlement. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
type RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of labels to remove. */
  readonly labelIds: ReadonlyArray<Scalars['ID']['input']>;
  /** The id of the Labelable to remove labels from. */
  readonly labelableId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
type RemoveLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The Labelable the labels were removed from. */
  readonly labelable?: Maybe<Labelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
type RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization to remove the outside collaborator from. */
  readonly organizationId: Scalars['ID']['input'];
  /** The ID of the outside collaborator to remove. */
  readonly userId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveOutsideCollaborator */
type RemoveOutsideCollaboratorPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was removed as an outside collaborator. */
  readonly removedUser?: Maybe<User>;
};

/** Autogenerated input type of RemoveReaction */
type RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji reaction to remove. */
  readonly content: ReactionContent;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveReaction */
type RemoveReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The reaction object. */
  readonly reaction?: Maybe<Reaction>;
  /** The reaction groups for the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** The reactable subject. */
  readonly subject?: Maybe<Reactable>;
};

/** Autogenerated input type of RemoveStar */
type RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to unstar. */
  readonly starrableId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveStar */
type RemoveStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The starrable. */
  readonly starrable?: Maybe<Starrable>;
};

/** Autogenerated input type of RemoveUpvote */
type RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveUpvote */
type RemoveUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The votable subject. */
  readonly subject?: Maybe<Votable>;
};

/** Represents a 'removed_from_merge_queue' event on a given pull request. */
type RemovedFromMergeQueueEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the before commit SHA for the 'removed_from_merge_queue' event. */
  readonly beforeCommit?: Maybe<Commit>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The user who removed this Pull Request from the merge queue */
  readonly enqueuer?: Maybe<User>;
  readonly id: Scalars['ID']['output'];
  /** The merge queue where this pull request was removed from. */
  readonly mergeQueue?: Maybe<MergeQueue>;
  /** PullRequest referenced by event. */
  readonly pullRequest?: Maybe<PullRequest>;
  /** The reason this pull request was removed from the queue. */
  readonly reason?: Maybe<Scalars['String']['output']>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
type RemovedFromProjectEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Project referenced by event. */
  readonly project?: Maybe<Project>;
  /** Column name referenced by this project event. */
  readonly projectColumnName: Scalars['String']['output'];
};

/** Represents a 'renamed' event on a given issue or pull request */
type RenamedTitleEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the current title of the issue or pull request. */
  readonly currentTitle: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the previous title of the issue or pull request. */
  readonly previousTitle: Scalars['String']['output'];
  /** Subject that was renamed. */
  readonly subject: RenamedTitleSubject;
};

/** An object which has a renamable title */
type RenamedTitleSubject = Issue | PullRequest;

/** Autogenerated input type of ReopenDiscussion */
type ReopenDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be reopened. */
  readonly discussionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenDiscussion */
type ReopenDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that was reopened. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of ReopenIssue */
type ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be opened. */
  readonly issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenIssue */
type ReopenIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was opened. */
  readonly issue?: Maybe<Issue>;
};

/** Autogenerated input type of ReopenPullRequest */
type ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be reopened. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReopenPullRequest */
type ReopenPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was reopened. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
type ReopenedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Object that was reopened. */
  readonly closable: Closable;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The reason the issue state was changed to open. */
  readonly stateReason?: Maybe<IssueStateReason>;
};

/** Audit log entry for a repo.access event. */
type RepoAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  readonly visibility?: Maybe<RepoAccessAuditEntryVisibility>;
};

/** The privacy of a repository */
enum RepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.add_member event. */
type RepoAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  readonly visibility?: Maybe<RepoAddMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
enum RepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.add_topic event. */
type RepoAddTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the topic added to the repository */
  readonly topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  readonly topicName?: Maybe<Scalars['String']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.archived event. */
type RepoArchivedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  readonly visibility?: Maybe<RepoArchivedAuditEntryVisibility>;
};

/** The privacy of a repository */
enum RepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.change_merge_setting event. */
type RepoChangeMergeSettingAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the change was to enable (true) or disable (false) the merge type */
  readonly isEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The merge method affected by the change */
  readonly mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The merge options available for pull requests to this repository. */
enum RepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = 'MERGE',
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = 'REBASE',
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = 'SQUASH'
}

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repo.create event. */
type RepoCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The name of the parent repository for this forked repository. */
  readonly forkParentName?: Maybe<Scalars['String']['output']>;
  /** The name of the root repository for this network. */
  readonly forkSourceName?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  readonly visibility?: Maybe<RepoCreateAuditEntryVisibility>;
};

/** The privacy of a repository */
enum RepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.destroy event. */
type RepoDestroyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  readonly visibility?: Maybe<RepoDestroyAuditEntryVisibility>;
};

/** The privacy of a repository */
enum RepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.remove_member event. */
type RepoRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
  /** The visibility of the repository */
  readonly visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
enum RepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.remove_topic event. */
type RepoRemoveTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the topic added to the repository */
  readonly topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  readonly topicName?: Maybe<Scalars['String']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The reasons a piece of content can be reported or minimized. */
enum ReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = 'ABUSE',
  /** A duplicated piece of content */
  Duplicate = 'DUPLICATE',
  /** An irrelevant piece of content */
  OffTopic = 'OFF_TOPIC',
  /** An outdated piece of content */
  Outdated = 'OUTDATED',
  /** The content has been resolved */
  Resolved = 'RESOLVED',
  /** A spammy piece of content */
  Spam = 'SPAM'
}

/** A repository contains the content for a project. */
type Repository = Node & PackageOwner & ProjectOwner & ProjectV2Recent & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable & {
  /**
   * Whether or not a pull request head branch that is behind its base branch can
   * always be updated even if it is not required to be up to date before merging.
   */
  readonly allowUpdateBranch: Scalars['Boolean']['output'];
  /** Identifies the date and time when the repository was archived. */
  readonly archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of users that can be assigned to issues in this repository. */
  readonly assignableUsers: UserConnection;
  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */
  readonly autoMergeAllowed: Scalars['Boolean']['output'];
  /** A list of branch protection rules for this repository. */
  readonly branchProtectionRules: BranchProtectionRuleConnection;
  /** Returns the code of conduct for this repository */
  readonly codeOfConduct?: Maybe<CodeOfConduct>;
  /** Information extracted from the repository's `CODEOWNERS` file. */
  readonly codeowners?: Maybe<RepositoryCodeowners>;
  /** A list of collaborators associated with the repository. */
  readonly collaborators?: Maybe<RepositoryCollaboratorConnection>;
  /** A list of commit comments associated with the repository. */
  readonly commitComments: CommitCommentConnection;
  /** Returns a list of contact links associated to the repository */
  readonly contactLinks?: Maybe<ReadonlyArray<RepositoryContactLink>>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The Ref associated with the repository's default branch. */
  readonly defaultBranchRef?: Maybe<Ref>;
  /** Whether or not branches are automatically deleted when merged in this repository. */
  readonly deleteBranchOnMerge: Scalars['Boolean']['output'];
  /** A list of dependency manifests contained in the repository */
  readonly dependencyGraphManifests?: Maybe<DependencyGraphManifestConnection>;
  /** A list of deploy keys that are on this repository. */
  readonly deployKeys: DeployKeyConnection;
  /** Deployments associated with the repository */
  readonly deployments: DeploymentConnection;
  /** The description of the repository. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The description of the repository rendered to HTML. */
  readonly descriptionHTML: Scalars['HTML']['output'];
  /** Returns a single discussion from the current repository by number. */
  readonly discussion?: Maybe<Discussion>;
  /** A list of discussion categories that are available in the repository. */
  readonly discussionCategories: DiscussionCategoryConnection;
  /** A discussion category by slug. */
  readonly discussionCategory?: Maybe<DiscussionCategory>;
  /** A list of discussions that have been opened in the repository. */
  readonly discussions: DiscussionConnection;
  /** The number of kilobytes this repository occupies on disk. */
  readonly diskUsage?: Maybe<Scalars['Int']['output']>;
  /** Returns a single active environment from the current repository by name. */
  readonly environment?: Maybe<Environment>;
  /** A list of environments that are in this repository. */
  readonly environments: EnvironmentConnection;
  /** Returns how many forks there are of this repository in the whole network. */
  readonly forkCount: Scalars['Int']['output'];
  /** Whether this repository allows forks. */
  readonly forkingAllowed: Scalars['Boolean']['output'];
  /** A list of direct forked repositories. */
  readonly forks: RepositoryConnection;
  /** The funding links for this repository */
  readonly fundingLinks: ReadonlyArray<FundingLink>;
  /** Indicates if the repository has the Discussions feature enabled. */
  readonly hasDiscussionsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has issues feature enabled. */
  readonly hasIssuesEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has the Projects feature enabled. */
  readonly hasProjectsEnabled: Scalars['Boolean']['output'];
  /** Whether vulnerability alerts are enabled for the repository. */
  readonly hasVulnerabilityAlertsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has wiki feature enabled. */
  readonly hasWikiEnabled: Scalars['Boolean']['output'];
  /** The repository's URL. */
  readonly homepageUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The interaction ability settings for this repository. */
  readonly interactionAbility?: Maybe<RepositoryInteractionAbility>;
  /** Indicates if the repository is unmaintained. */
  readonly isArchived: Scalars['Boolean']['output'];
  /** Returns true if blank issue creation is allowed */
  readonly isBlankIssuesEnabled: Scalars['Boolean']['output'];
  /** Returns whether or not this repository disabled. */
  readonly isDisabled: Scalars['Boolean']['output'];
  /** Returns whether or not this repository is empty. */
  readonly isEmpty: Scalars['Boolean']['output'];
  /** Identifies if the repository is a fork. */
  readonly isFork: Scalars['Boolean']['output'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  readonly isInOrganization: Scalars['Boolean']['output'];
  /** Indicates if the repository has been locked or not. */
  readonly isLocked: Scalars['Boolean']['output'];
  /** Identifies if the repository is a mirror. */
  readonly isMirror: Scalars['Boolean']['output'];
  /** Identifies if the repository is private or internal. */
  readonly isPrivate: Scalars['Boolean']['output'];
  /** Returns true if this repository has a security policy */
  readonly isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  readonly isTemplate: Scalars['Boolean']['output'];
  /** Is this repository a user configuration repository? */
  readonly isUserConfigurationRepository: Scalars['Boolean']['output'];
  /** Returns a single issue from the current repository by number. */
  readonly issue?: Maybe<Issue>;
  /** Returns a single issue-like object from the current repository by number. */
  readonly issueOrPullRequest?: Maybe<IssueOrPullRequest>;
  /** Returns a list of issue templates associated to the repository */
  readonly issueTemplates?: Maybe<ReadonlyArray<IssueTemplate>>;
  /** A list of issues that have been opened in the repository. */
  readonly issues: IssueConnection;
  /** Returns a single label by name */
  readonly label?: Maybe<Label>;
  /** A list of labels associated with the repository. */
  readonly labels?: Maybe<LabelConnection>;
  /** A list containing a breakdown of the language composition of the repository. */
  readonly languages?: Maybe<LanguageConnection>;
  /** Get the latest release for the repository if one exists. */
  readonly latestRelease?: Maybe<Release>;
  /** The license associated with the repository */
  readonly licenseInfo?: Maybe<License>;
  /** The reason the repository has been locked. */
  readonly lockReason?: Maybe<RepositoryLockReason>;
  /** A list of Users that can be mentioned in the context of the repository. */
  readonly mentionableUsers: UserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  readonly mergeCommitAllowed: Scalars['Boolean']['output'];
  /** How the default commit message will be generated when merging a pull request. */
  readonly mergeCommitMessage: MergeCommitMessage;
  /** How the default commit title will be generated when merging a pull request. */
  readonly mergeCommitTitle: MergeCommitTitle;
  /** The merge queue for a specified branch, otherwise the default branch if not provided. */
  readonly mergeQueue?: Maybe<MergeQueue>;
  /** Returns a single milestone from the current repository by number. */
  readonly milestone?: Maybe<Milestone>;
  /** A list of milestones associated with the repository. */
  readonly milestones?: Maybe<MilestoneConnection>;
  /** The repository's original mirror URL. */
  readonly mirrorUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the repository. */
  readonly name: Scalars['String']['output'];
  /** The repository's name with owner. */
  readonly nameWithOwner: Scalars['String']['output'];
  /** A Git object in the repository */
  readonly object?: Maybe<GitObject>;
  /** The image used to represent this repository in Open Graph data. */
  readonly openGraphImageUrl: Scalars['URI']['output'];
  /** The User owner of the repository. */
  readonly owner: RepositoryOwner;
  /** A list of packages under the owner. */
  readonly packages: PackageConnection;
  /** The repository parent, if this is a fork. */
  readonly parent?: Maybe<Repository>;
  /** A list of discussions that have been pinned in this repository. */
  readonly pinnedDiscussions: PinnedDiscussionConnection;
  /** A list of pinned issues for this repository. */
  readonly pinnedIssues?: Maybe<PinnedIssueConnection>;
  /** The primary language of the repository's code. */
  readonly primaryLanguage?: Maybe<Language>;
  /** Find project by number. */
  readonly project?: Maybe<Project>;
  /** Finds and returns the Project according to the provided Project number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  readonly projects: ProjectConnection;
  /** The HTTP path listing the repository's projects */
  readonly projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing the repository's projects */
  readonly projectsUrl: Scalars['URI']['output'];
  /** List of projects linked to this repository. */
  readonly projectsV2: ProjectV2Connection;
  /** Returns a single pull request from the current repository by number. */
  readonly pullRequest?: Maybe<PullRequest>;
  /** Returns a list of pull request templates associated to the repository */
  readonly pullRequestTemplates?: Maybe<ReadonlyArray<PullRequestTemplate>>;
  /** A list of pull requests that have been opened in the repository. */
  readonly pullRequests: PullRequestConnection;
  /** Identifies the date and time when the repository was last pushed to. */
  readonly pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Whether or not rebase-merging is enabled on this repository. */
  readonly rebaseMergeAllowed: Scalars['Boolean']['output'];
  /** Recent projects that this user has modified in the context of the owner. */
  readonly recentProjects: ProjectV2Connection;
  /** Fetch a given ref from the repository */
  readonly ref?: Maybe<Ref>;
  /** Fetch a list of refs from the repository */
  readonly refs?: Maybe<RefConnection>;
  /** Lookup a single release given various criteria. */
  readonly release?: Maybe<Release>;
  /** List of releases which are dependent on this repository. */
  readonly releases: ReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  readonly repositoryTopics: RepositoryTopicConnection;
  /** The HTTP path for this repository */
  readonly resourcePath: Scalars['URI']['output'];
  /** Returns a single ruleset from the current repository by ID. */
  readonly ruleset?: Maybe<RepositoryRuleset>;
  /** A list of rulesets for this repository. */
  readonly rulesets?: Maybe<RepositoryRulesetConnection>;
  /** The security policy URL. */
  readonly securityPolicyUrl?: Maybe<Scalars['URI']['output']>;
  /** A description of the repository, rendered to HTML without any links in it. */
  readonly shortDescriptionHTML: Scalars['HTML']['output'];
  /** Whether or not squash-merging is enabled on this repository. */
  readonly squashMergeAllowed: Scalars['Boolean']['output'];
  /** How the default commit message will be generated when squash merging a pull request. */
  readonly squashMergeCommitMessage: SquashMergeCommitMessage;
  /** How the default commit title will be generated when squash merging a pull request. */
  readonly squashMergeCommitTitle: SquashMergeCommitTitle;
  /**
   * Whether a squash merge commit can use the pull request title as default.
   * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.
   */
  readonly squashPrTitleUsedAsDefault: Scalars['Boolean']['output'];
  /** The SSH URL to clone this repository */
  readonly sshUrl: Scalars['GitSSHRemote']['output'];
  /** Returns a count of how many stargazers there are on this object */
  readonly stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  readonly stargazers: StargazerConnection;
  /**
   * Returns a list of all submodules in this repository parsed from the
   * .gitmodules file as of the default branch's HEAD commit.
   */
  readonly submodules: SubmoduleConnection;
  /** Temporary authentication token for cloning this repository. */
  readonly tempCloneToken?: Maybe<Scalars['String']['output']>;
  /** The repository from which this repository was generated, if any. */
  readonly templateRepository?: Maybe<Repository>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this repository */
  readonly url: Scalars['URI']['output'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  readonly usesCustomOpenGraphImage: Scalars['Boolean']['output'];
  /** Indicates whether the viewer has admin permissions on this repository. */
  readonly viewerCanAdminister: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  readonly viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Indicates whether the viewer can update the topics of this repository. */
  readonly viewerCanUpdateTopics: Scalars['Boolean']['output'];
  /** The last commit email for the viewer. */
  readonly viewerDefaultCommitEmail?: Maybe<Scalars['String']['output']>;
  /** The last used merge method by the viewer or the default for the repository. */
  readonly viewerDefaultMergeMethod: PullRequestMergeMethod;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  readonly viewerHasStarred: Scalars['Boolean']['output'];
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  readonly viewerPermission?: Maybe<RepositoryPermission>;
  /** A list of emails this viewer can commit with. */
  readonly viewerPossibleCommitEmails?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
  /** Indicates the repository's visibility level. */
  readonly visibility: RepositoryVisibility;
  /** Returns a single vulnerability alert from the current repository by number. */
  readonly vulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;
  /** A list of vulnerability alerts that are on this repository. */
  readonly vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>;
  /** A list of users watching the repository. */
  readonly watchers: UserConnection;
  /** Whether contributors are required to sign off on web-based commits in this repository. */
  readonly webCommitSignoffRequired: Scalars['Boolean']['output'];
};


/** A repository contains the content for a project. */
type RepositoryAssignableUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryBranchProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryCodeownersArgs = {
  refName?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryCollaboratorsArgs = {
  affiliation?: InputMaybe<CollaboratorAffiliation>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryCommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryDependencyGraphManifestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependenciesAfter?: InputMaybe<Scalars['String']['input']>;
  dependenciesFirst?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  withDependencies?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryDeployKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  environments?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DeploymentOrder>;
};


/** A repository contains the content for a project. */
type RepositoryDiscussionArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryDiscussionCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterByAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryDiscussionCategoryArgs = {
  slug: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
type RepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  states?: InputMaybe<ReadonlyArray<DiscussionState>>;
};


/** A repository contains the content for a project. */
type RepositoryEnvironmentArgs = {
  name: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
type RepositoryEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Environments>;
};


/** A repository contains the content for a project. */
type RepositoryForksArgs = {
  affiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** A repository contains the content for a project. */
type RepositoryIssueArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryIssueOrPullRequestArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<IssueState>>;
};


/** A repository contains the content for a project. */
type RepositoryLabelArgs = {
  name: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
type RepositoryLabelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LabelOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryLanguagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LanguageOrder>;
};


/** A repository contains the content for a project. */
type RepositoryMentionableUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryMergeQueueArgs = {
  branch?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryMilestoneArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryMilestonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<MilestoneOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<ReadonlyArray<MilestoneState>>;
};


/** A repository contains the content for a project. */
type RepositoryObjectArgs = {
  expression?: InputMaybe<Scalars['String']['input']>;
  oid?: InputMaybe<Scalars['GitObjectID']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryPackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryPinnedDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryPinnedIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryProjectArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<ReadonlyArray<ProjectState>>;
};


/** A repository contains the content for a project. */
type RepositoryProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryPullRequestArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<PullRequestState>>;
};


/** A repository contains the content for a project. */
type RepositoryRecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryRefArgs = {
  qualifiedName: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
type RepositoryRefsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  direction?: InputMaybe<OrderDirection>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RefOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  refPrefix: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
type RepositoryReleaseArgs = {
  tagName: Scalars['String']['input'];
};


/** A repository contains the content for a project. */
type RepositoryReleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReleaseOrder>;
};


/** A repository contains the content for a project. */
type RepositoryRepositoryTopicsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryRulesetArgs = {
  databaseId: Scalars['Int']['input'];
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryRulesetsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeParents?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryStargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};


/** A repository contains the content for a project. */
type RepositorySubmodulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository contains the content for a project. */
type RepositoryVulnerabilityAlertArgs = {
  number: Scalars['Int']['input'];
};


/** A repository contains the content for a project. */
type RepositoryVulnerabilityAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  dependencyScopes?: InputMaybe<ReadonlyArray<RepositoryVulnerabilityAlertDependencyScope>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<ReadonlyArray<RepositoryVulnerabilityAlertState>>;
};


/** A repository contains the content for a project. */
type RepositoryWatchersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The affiliation of a user to a repository */
enum RepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = 'COLLABORATOR',
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = 'ORGANIZATION_MEMBER',
  /** Repositories that are owned by the authenticated user. */
  Owner = 'OWNER'
}

/** Metadata for an audit entry with action repo.* */
type RepositoryAuditEntryData = {
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
};

/** Information extracted from a repository's `CODEOWNERS` file. */
type RepositoryCodeowners = {
  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */
  readonly errors: ReadonlyArray<RepositoryCodeownersError>;
};

/** An error in a `CODEOWNERS` file. */
type RepositoryCodeownersError = {
  /** The column number where the error occurs. */
  readonly column: Scalars['Int']['output'];
  /** A short string describing the type of error. */
  readonly kind: Scalars['String']['output'];
  /** The line number where the error occurs. */
  readonly line: Scalars['Int']['output'];
  /** A complete description of the error, combining information from other fields. */
  readonly message: Scalars['String']['output'];
  /** The path to the file when the error occurs. */
  readonly path: Scalars['String']['output'];
  /** The content of the line where the error occurs. */
  readonly source: Scalars['String']['output'];
  /** A suggestion of how to fix the error. */
  readonly suggestion?: Maybe<Scalars['String']['output']>;
};

/** The connection type for User. */
type RepositoryCollaboratorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a user who is a collaborator of a repository. */
type RepositoryCollaboratorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  readonly node: User;
  /** The permission the user has on the repository. */
  readonly permission: RepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  readonly permissionSources?: Maybe<ReadonlyArray<PermissionSource>>;
};

/** A list of repositories owned by the subject. */
type RepositoryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /** The total size in kilobytes of all repositories in the connection. */
  readonly totalDiskUsage: Scalars['Int']['output'];
};

/** A repository contact link. */
type RepositoryContactLink = {
  /** The contact link purpose. */
  readonly about: Scalars['String']['output'];
  /** The contact link name. */
  readonly name: Scalars['String']['output'];
  /** The contact link URL. */
  readonly url: Scalars['URI']['output'];
};

/** The reason a repository is listed as 'contributed'. */
enum RepositoryContributionType {
  /** Created a commit */
  Commit = 'COMMIT',
  /** Created an issue */
  Issue = 'ISSUE',
  /** Created a pull request */
  PullRequest = 'PULL_REQUEST',
  /** Reviewed a pull request */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** Created the repository */
  Repository = 'REPOSITORY'
}

/** Represents an author of discussions in repositories. */
type RepositoryDiscussionAuthor = {
  /** Discussions this user has started. */
  readonly repositoryDiscussions: DiscussionConnection;
};


/** Represents an author of discussions in repositories. */
type RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<ReadonlyArray<DiscussionState>>;
};

/** Represents an author of discussion comments in repositories. */
type RepositoryDiscussionCommentAuthor = {
  /** Discussion comments this user has authored. */
  readonly repositoryDiscussionComments: DiscussionCommentConnection;
};


/** Represents an author of discussion comments in repositories. */
type RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** An edge in a connection. */
type RepositoryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Repository>;
};

/** Parameters to be used for the repository_id condition */
type RepositoryIdConditionTarget = {
  /** One of these repo IDs must match the repo. */
  readonly repositoryIds: ReadonlyArray<Scalars['ID']['output']>;
};

/** Parameters to be used for the repository_id condition */
type RepositoryIdConditionTargetInput = {
  /** One of these repo IDs must match the repo. */
  readonly repositoryIds: ReadonlyArray<Scalars['ID']['input']>;
};

/** A subset of repository info. */
type RepositoryInfo = {
  /** Identifies the date and time when the repository was archived. */
  readonly archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The description of the repository. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The description of the repository rendered to HTML. */
  readonly descriptionHTML: Scalars['HTML']['output'];
  /** Returns how many forks there are of this repository in the whole network. */
  readonly forkCount: Scalars['Int']['output'];
  /** Indicates if the repository has the Discussions feature enabled. */
  readonly hasDiscussionsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has issues feature enabled. */
  readonly hasIssuesEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has the Projects feature enabled. */
  readonly hasProjectsEnabled: Scalars['Boolean']['output'];
  /** Indicates if the repository has wiki feature enabled. */
  readonly hasWikiEnabled: Scalars['Boolean']['output'];
  /** The repository's URL. */
  readonly homepageUrl?: Maybe<Scalars['URI']['output']>;
  /** Indicates if the repository is unmaintained. */
  readonly isArchived: Scalars['Boolean']['output'];
  /** Identifies if the repository is a fork. */
  readonly isFork: Scalars['Boolean']['output'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  readonly isInOrganization: Scalars['Boolean']['output'];
  /** Indicates if the repository has been locked or not. */
  readonly isLocked: Scalars['Boolean']['output'];
  /** Identifies if the repository is a mirror. */
  readonly isMirror: Scalars['Boolean']['output'];
  /** Identifies if the repository is private or internal. */
  readonly isPrivate: Scalars['Boolean']['output'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  readonly isTemplate: Scalars['Boolean']['output'];
  /** The license associated with the repository */
  readonly licenseInfo?: Maybe<License>;
  /** The reason the repository has been locked. */
  readonly lockReason?: Maybe<RepositoryLockReason>;
  /** The repository's original mirror URL. */
  readonly mirrorUrl?: Maybe<Scalars['URI']['output']>;
  /** The name of the repository. */
  readonly name: Scalars['String']['output'];
  /** The repository's name with owner. */
  readonly nameWithOwner: Scalars['String']['output'];
  /** The image used to represent this repository in Open Graph data. */
  readonly openGraphImageUrl: Scalars['URI']['output'];
  /** The User owner of the repository. */
  readonly owner: RepositoryOwner;
  /** Identifies the date and time when the repository was last pushed to. */
  readonly pushedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The HTTP path for this repository */
  readonly resourcePath: Scalars['URI']['output'];
  /** A description of the repository, rendered to HTML without any links in it. */
  readonly shortDescriptionHTML: Scalars['HTML']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this repository */
  readonly url: Scalars['URI']['output'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  readonly usesCustomOpenGraphImage: Scalars['Boolean']['output'];
  /** Indicates the repository's visibility level. */
  readonly visibility: RepositoryVisibility;
};


/** A subset of repository info. */
type RepositoryInfoShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** Repository interaction limit that applies to this object. */
type RepositoryInteractionAbility = {
  /** The time the currently active limit expires. */
  readonly expiresAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current limit that is enabled on this object. */
  readonly limit: RepositoryInteractionLimit;
  /** The origin of the currently active interaction limit. */
  readonly origin: RepositoryInteractionLimitOrigin;
};

/** A repository interaction limit. */
enum RepositoryInteractionLimit {
  /** Users that are not collaborators will not be able to interact with the repository. */
  CollaboratorsOnly = 'COLLABORATORS_ONLY',
  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */
  ContributorsOnly = 'CONTRIBUTORS_ONLY',
  /** Users that have recently created their account will be unable to interact with the repository. */
  ExistingUsers = 'EXISTING_USERS',
  /** No interaction limits are enabled. */
  NoLimit = 'NO_LIMIT'
}

/** The length for a repository interaction limit to be enabled for. */
enum RepositoryInteractionLimitExpiry {
  /** The interaction limit will expire after 1 day. */
  OneDay = 'ONE_DAY',
  /** The interaction limit will expire after 1 month. */
  OneMonth = 'ONE_MONTH',
  /** The interaction limit will expire after 1 week. */
  OneWeek = 'ONE_WEEK',
  /** The interaction limit will expire after 6 months. */
  SixMonths = 'SIX_MONTHS',
  /** The interaction limit will expire after 3 days. */
  ThreeDays = 'THREE_DAYS'
}

/** Indicates where an interaction limit is configured. */
enum RepositoryInteractionLimitOrigin {
  /** A limit that is configured at the organization level. */
  Organization = 'ORGANIZATION',
  /** A limit that is configured at the repository level. */
  Repository = 'REPOSITORY',
  /** A limit that is configured at the user-wide level. */
  User = 'USER'
}

/** An invitation for a user to be added to a repository. */
type RepositoryInvitation = Node & {
  /** The email address that received the invitation. */
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The user who received the invitation. */
  readonly invitee?: Maybe<User>;
  /** The user who created the invitation. */
  readonly inviter: User;
  /** The permalink for this repository invitation. */
  readonly permalink: Scalars['URI']['output'];
  /** The permission granted on this repository by this invitation. */
  readonly permission: RepositoryPermission;
  /** The Repository the user is invited to. */
  readonly repository?: Maybe<RepositoryInfo>;
};

/** A list of repository invitations. */
type RepositoryInvitationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryInvitationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryInvitation>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RepositoryInvitationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
type RepositoryInvitationOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repository invitations by. */
  readonly field: RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
enum RepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = 'CREATED_AT'
}

/** The possible reasons a given repository could be in a locked state. */
enum RepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = 'BILLING',
  /** The repository is locked due to a migration. */
  Migrating = 'MIGRATING',
  /** The repository is locked due to a move. */
  Moving = 'MOVING',
  /** The repository is locked due to a rename. */
  Rename = 'RENAME',
  /** The repository is locked due to a trade controls related reason. */
  TradeRestriction = 'TRADE_RESTRICTION'
}

/** A GitHub Enterprise Importer (GEI) repository migration. */
type RepositoryMigration = Migration & Node & {
  /** The migration flag to continue on error. */
  readonly continueOnError: Scalars['Boolean']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['String']['output']>;
  /** The reason the migration failed. */
  readonly failureReason?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  readonly migrationLogUrl?: Maybe<Scalars['URI']['output']>;
  /** The migration source. */
  readonly migrationSource: MigrationSource;
  /** The target repository name. */
  readonly repositoryName: Scalars['String']['output'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  readonly sourceUrl: Scalars['URI']['output'];
  /** The migration state. */
  readonly state: MigrationState;
  /**
   * The number of warnings encountered for this migration. To review the warnings,
   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).
   */
  readonly warningsCount: Scalars['Int']['output'];
};

/** The connection type for RepositoryMigration. */
type RepositoryMigrationConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryMigrationEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryMigration>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a repository migration. */
type RepositoryMigrationEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryMigration>;
};

/** Ordering options for repository migrations. */
type RepositoryMigrationOrder = {
  /** The ordering direction. */
  readonly direction: RepositoryMigrationOrderDirection;
  /** The field to order repository migrations by. */
  readonly field: RepositoryMigrationOrderField;
};

/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */
enum RepositoryMigrationOrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/** Properties by which repository migrations can be ordered. */
enum RepositoryMigrationOrderField {
  /** Order mannequins why when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Parameters to be used for the repository_name condition */
type RepositoryNameConditionTarget = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  readonly exclude: ReadonlyArray<Scalars['String']['output']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  readonly include: ReadonlyArray<Scalars['String']['output']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  readonly protected: Scalars['Boolean']['output'];
};

/** Parameters to be used for the repository_name condition */
type RepositoryNameConditionTargetInput = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  readonly exclude: ReadonlyArray<Scalars['String']['input']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  readonly include: ReadonlyArray<Scalars['String']['input']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  readonly protected?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents a object that belongs to a repository. */
type RepositoryNode = {
  /** The repository associated with this node. */
  readonly repository: Repository;
};

/** Ordering options for repository connections */
type RepositoryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repositories by. */
  readonly field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
enum RepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a Repository. */
type RepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  readonly id: Scalars['ID']['output'];
  /** The username used to login. */
  readonly login: Scalars['String']['output'];
  /** A list of repositories that the user owns. */
  readonly repositories: RepositoryConnection;
  /** Find Repository. */
  readonly repository?: Maybe<Repository>;
  /** The HTTP URL for the owner. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the owner. */
  readonly url: Scalars['URI']['output'];
};


/** Represents an owner of a Repository. */
type RepositoryOwnerAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an owner of a Repository. */
type RepositoryOwnerRepositoriesArgs = {
  affiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** Represents an owner of a Repository. */
type RepositoryOwnerRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};

/** The access level to a repository */
enum RepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = 'ADMIN',
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = 'MAINTAIN',
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = 'READ',
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = 'TRIAGE',
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = 'WRITE'
}

/** The privacy of a repository */
enum RepositoryPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** A repository rule. */
type RepositoryRule = Node & {
  readonly id: Scalars['ID']['output'];
  /** The parameters for this rule. */
  readonly parameters?: Maybe<RuleParameters>;
  /** The type of rule. */
  readonly type: RepositoryRuleType;
};

/** Set of conditions that determine if a ruleset will evaluate */
type RepositoryRuleConditions = {
  /** Configuration for the ref_name condition */
  readonly refName?: Maybe<RefNameConditionTarget>;
  /** Configuration for the repository_id condition */
  readonly repositoryId?: Maybe<RepositoryIdConditionTarget>;
  /** Configuration for the repository_name condition */
  readonly repositoryName?: Maybe<RepositoryNameConditionTarget>;
};

/** Specifies the conditions required for a ruleset to evaluate */
type RepositoryRuleConditionsInput = {
  /** Configuration for the ref_name condition */
  readonly refName?: InputMaybe<RefNameConditionTargetInput>;
  /** Configuration for the repository_id condition */
  readonly repositoryId?: InputMaybe<RepositoryIdConditionTargetInput>;
  /** Configuration for the repository_name condition */
  readonly repositoryName?: InputMaybe<RepositoryNameConditionTargetInput>;
};

/** The connection type for RepositoryRule. */
type RepositoryRuleConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryRuleEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryRule>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RepositoryRuleEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryRule>;
};

/** Specifies the attributes for a new or updated rule. */
type RepositoryRuleInput = {
  /** Optional ID of this rule when updating */
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  /** The parameters for the rule. */
  readonly parameters?: InputMaybe<RuleParametersInput>;
  /** The type of rule to create. */
  readonly type: RepositoryRuleType;
};

/** The rule types supported in rulesets */
enum RepositoryRuleType {
  /** Branch name pattern */
  BranchNamePattern = 'BRANCH_NAME_PATTERN',
  /** Committer email pattern */
  CommitterEmailPattern = 'COMMITTER_EMAIL_PATTERN',
  /** Commit author email pattern */
  CommitAuthorEmailPattern = 'COMMIT_AUTHOR_EMAIL_PATTERN',
  /** Commit message pattern */
  CommitMessagePattern = 'COMMIT_MESSAGE_PATTERN',
  /** Only allow users with bypass permission to create matching refs. */
  Creation = 'CREATION',
  /** Only allow users with bypass permissions to delete matching refs. */
  Deletion = 'DELETION',
  /** Prevent users with push access from force pushing to branches. */
  NonFastForward = 'NON_FAST_FORWARD',
  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
  PullRequest = 'PULL_REQUEST',
  /**
   * Choose which environments must be successfully deployed to before branches can
   * be merged into a branch that matches this rule.
   */
  RequiredDeployments = 'REQUIRED_DEPLOYMENTS',
  /** Prevent merge commits from being pushed to matching branches. */
  RequiredLinearHistory = 'REQUIRED_LINEAR_HISTORY',
  /** Commits pushed to matching branches must have verified signatures. */
  RequiredSignatures = 'REQUIRED_SIGNATURES',
  /**
   * Choose which status checks must pass before branches can be merged into a
   * branch that matches this rule. When enabled, commits must first be pushed to
   * another branch, then merged or pushed directly to a branch that matches this
   * rule after status checks have passed.
   */
  RequiredStatusChecks = 'REQUIRED_STATUS_CHECKS',
  /** Tag name pattern */
  TagNamePattern = 'TAG_NAME_PATTERN',
  /** Only allow users with bypass permission to update matching refs. */
  Update = 'UPDATE'
}

/** A repository ruleset. */
type RepositoryRuleset = Node & {
  /** The actors that can bypass this ruleset */
  readonly bypassActors?: Maybe<RepositoryRulesetBypassActorConnection>;
  /** The set of conditions that must evaluate to true for this ruleset to apply */
  readonly conditions: RepositoryRuleConditions;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The enforcement level of this ruleset */
  readonly enforcement: RuleEnforcement;
  readonly id: Scalars['ID']['output'];
  /** Name of the ruleset. */
  readonly name: Scalars['String']['output'];
  /** List of rules. */
  readonly rules?: Maybe<RepositoryRuleConnection>;
  /** Source of ruleset. */
  readonly source: RuleSource;
  /** Target of the ruleset. */
  readonly target?: Maybe<RepositoryRulesetTarget>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};


/** A repository ruleset. */
type RepositoryRulesetBypassActorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A repository ruleset. */
type RepositoryRulesetRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<RepositoryRuleType>;
};

/** A team or app that has the ability to bypass a rules defined on a ruleset */
type RepositoryRulesetBypassActor = Node & {
  /** The actor that can bypass rules. */
  readonly actor?: Maybe<BypassActor>;
  /** The mode for the bypass actor */
  readonly bypassMode?: Maybe<RepositoryRulesetBypassActorBypassMode>;
  readonly id: Scalars['ID']['output'];
  /** This actor represents the ability for an organization admin to bypass */
  readonly organizationAdmin: Scalars['Boolean']['output'];
  /** If the actor is a repository role, the repository role's ID that can bypass */
  readonly repositoryRoleDatabaseId?: Maybe<Scalars['Int']['output']>;
  /** If the actor is a repository role, the repository role's name that can bypass */
  readonly repositoryRoleName?: Maybe<Scalars['String']['output']>;
  /** Identifies the ruleset associated with the allowed actor */
  readonly repositoryRuleset?: Maybe<RepositoryRuleset>;
};

/** The bypass mode for a specific actor on a ruleset. */
enum RepositoryRulesetBypassActorBypassMode {
  /** The actor can always bypass rules */
  Always = 'ALWAYS',
  /** The actor can only bypass rules via a pull request */
  PullRequest = 'PULL_REQUEST'
}

/** The connection type for RepositoryRulesetBypassActor. */
type RepositoryRulesetBypassActorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryRulesetBypassActorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryRulesetBypassActor>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RepositoryRulesetBypassActorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryRulesetBypassActor>;
};

/**
 * Specifies the attributes for a new or updated ruleset bypass actor. Only one of
 * `actor_id`, `repository_role_database_id`, or `organization_admin` should be specified.
 */
type RepositoryRulesetBypassActorInput = {
  /** For Team and Integration bypasses, the Team or Integration ID */
  readonly actorId?: InputMaybe<Scalars['ID']['input']>;
  /** The bypass mode for this actor. */
  readonly bypassMode: RepositoryRulesetBypassActorBypassMode;
  /** For org admin bupasses, true */
  readonly organizationAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** For role bypasses, the role database ID */
  readonly repositoryRoleDatabaseId?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for RepositoryRuleset. */
type RepositoryRulesetConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryRulesetEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryRuleset>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RepositoryRulesetEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryRuleset>;
};

/** The targets supported for rulesets */
enum RepositoryRulesetTarget {
  /** Branch */
  Branch = 'BRANCH',
  /** Tag */
  Tag = 'TAG'
}

/** A repository-topic connects a repository to a topic. */
type RepositoryTopic = Node & UniformResourceLocatable & {
  readonly id: Scalars['ID']['output'];
  /** The HTTP path for this repository-topic. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The topic. */
  readonly topic: Topic;
  /** The HTTP URL for this repository-topic. */
  readonly url: Scalars['URI']['output'];
};

/** The connection type for RepositoryTopic. */
type RepositoryTopicConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryTopicEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryTopic>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RepositoryTopicEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryTopic>;
};

/** The repository's visibility level. */
enum RepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repository_visibility_change.disable event. */
type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a repository_visibility_change.enable event. */
type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  /** The HTTP path for this enterprise. */
  readonly enterpriseResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The slug of the enterprise. */
  readonly enterpriseSlug?: Maybe<Scalars['String']['output']>;
  /** The HTTP URL for this enterprise. */
  readonly enterpriseUrl?: Maybe<Scalars['URI']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */
type RepositoryVulnerabilityAlert = Node & RepositoryNode & {
  /** When was the alert auto-dismissed? */
  readonly autoDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** When was the alert created? */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The associated Dependabot update */
  readonly dependabotUpdate?: Maybe<DependabotUpdate>;
  /** The scope of an alert's dependency */
  readonly dependencyScope?: Maybe<RepositoryVulnerabilityAlertDependencyScope>;
  /** Comment explaining the reason the alert was dismissed */
  readonly dismissComment?: Maybe<Scalars['String']['output']>;
  /** The reason the alert was dismissed */
  readonly dismissReason?: Maybe<Scalars['String']['output']>;
  /** When was the alert dismissed? */
  readonly dismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user who dismissed the alert */
  readonly dismisser?: Maybe<User>;
  /** When was the alert fixed? */
  readonly fixedAt?: Maybe<Scalars['DateTime']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the alert number. */
  readonly number: Scalars['Int']['output'];
  /** The associated repository */
  readonly repository: Repository;
  /** The associated security advisory */
  readonly securityAdvisory?: Maybe<SecurityAdvisory>;
  /** The associated security vulnerability */
  readonly securityVulnerability?: Maybe<SecurityVulnerability>;
  /** Identifies the state of the alert. */
  readonly state: RepositoryVulnerabilityAlertState;
  /** The vulnerable manifest filename */
  readonly vulnerableManifestFilename: Scalars['String']['output'];
  /** The vulnerable manifest path */
  readonly vulnerableManifestPath: Scalars['String']['output'];
  /** The vulnerable requirements */
  readonly vulnerableRequirements?: Maybe<Scalars['String']['output']>;
};

/** The connection type for RepositoryVulnerabilityAlert. */
type RepositoryVulnerabilityAlertConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** The possible scopes of an alert's dependency. */
enum RepositoryVulnerabilityAlertDependencyScope {
  /** A dependency that is only used in development */
  Development = 'DEVELOPMENT',
  /** A dependency that is leveraged during application runtime */
  Runtime = 'RUNTIME'
}

/** An edge in a connection. */
type RepositoryVulnerabilityAlertEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RepositoryVulnerabilityAlert>;
};

/** The possible states of an alert */
enum RepositoryVulnerabilityAlertState {
  /** An alert that has been automatically closed by Dependabot. */
  AutoDismissed = 'AUTO_DISMISSED',
  /** An alert that has been manually closed by a user. */
  Dismissed = 'DISMISSED',
  /** An alert that has been resolved by a code change. */
  Fixed = 'FIXED',
  /** An alert that is still open. */
  Open = 'OPEN'
}

/** Autogenerated input type of RequestReviews */
type RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request to modify. */
  readonly pullRequestId: Scalars['ID']['input'];
  /** The Node IDs of the team to request. */
  readonly teamIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Add users to the set rather than replace. */
  readonly union?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node IDs of the user to request. */
  readonly userIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Autogenerated return type of RequestReviews */
type RequestReviewsPayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that is getting requests. */
  readonly pullRequest?: Maybe<PullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  readonly requestedReviewersEdge?: Maybe<UserEdge>;
};

/** The possible states that can be requested when creating a check run. */
enum RequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING'
}

/** Types that can be requested reviewers. */
type RequestedReviewer = Bot | Mannequin | Team | User;

/** The connection type for RequestedReviewer. */
type RequestedReviewerConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<RequestedReviewerEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<RequestedReviewer>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type RequestedReviewerEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<RequestedReviewer>;
};

/** Represents a type that can be required by a pull request for merging. */
type RequirableByPullRequest = {
  /** Whether this is required to pass before merging for a specific pull request. */
  readonly isRequired: Scalars['Boolean']['output'];
};


/** Represents a type that can be required by a pull request for merging. */
type RequirableByPullRequestIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * Choose which environments must be successfully deployed to before branches can
 * be merged into a branch that matches this rule.
 */
type RequiredDeploymentsParameters = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  readonly requiredDeploymentEnvironments: ReadonlyArray<Scalars['String']['output']>;
};

/**
 * Choose which environments must be successfully deployed to before branches can
 * be merged into a branch that matches this rule.
 */
type RequiredDeploymentsParametersInput = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  readonly requiredDeploymentEnvironments: ReadonlyArray<Scalars['String']['input']>;
};

/** Represents a required status check for a protected branch, but not any specific run of that check. */
type RequiredStatusCheckDescription = {
  /** The App that must provide this status in order for it to be accepted. */
  readonly app?: Maybe<App>;
  /** The name of this status. */
  readonly context: Scalars['String']['output'];
};

/** Specifies the attributes for a new or updated required status check. */
type RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  readonly appId?: InputMaybe<Scalars['ID']['input']>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  readonly context: Scalars['String']['input'];
};

/**
 * Choose which status checks must pass before branches can be merged into a branch
 * that matches this rule. When enabled, commits must first be pushed to another
 * branch, then merged or pushed directly to a branch that matches this rule after
 * status checks have passed.
 */
type RequiredStatusChecksParameters = {
  /** Status checks that are required. */
  readonly requiredStatusChecks: ReadonlyArray<StatusCheckConfiguration>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  readonly strictRequiredStatusChecksPolicy: Scalars['Boolean']['output'];
};

/**
 * Choose which status checks must pass before branches can be merged into a branch
 * that matches this rule. When enabled, commits must first be pushed to another
 * branch, then merged or pushed directly to a branch that matches this rule after
 * status checks have passed.
 */
type RequiredStatusChecksParametersInput = {
  /** Status checks that are required. */
  readonly requiredStatusChecks: ReadonlyArray<StatusCheckConfigurationInput>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  readonly strictRequiredStatusChecksPolicy: Scalars['Boolean']['input'];
};

/** Autogenerated input type of RerequestCheckSuite */
type RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  readonly checkSuiteId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of RerequestCheckSuite */
type RerequestCheckSuitePayload = {
  /** The requested check suite. */
  readonly checkSuite?: Maybe<CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ResolveReviewThread */
type ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to resolve */
  readonly threadId: Scalars['ID']['input'];
};

/** Autogenerated return type of ResolveReviewThread */
type ResolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The thread to resolve. */
  readonly thread?: Maybe<PullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
type RestrictedContribution = Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  readonly isRestricted: Scalars['Boolean']['output'];
  /** When this contribution was made. */
  readonly occurredAt: Scalars['DateTime']['output'];
  /** The HTTP path for this contribution. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this contribution. */
  readonly url: Scalars['URI']['output'];
  /** The user who made this contribution. */
  readonly user: User;
};

/** Autogenerated input type of RetireSponsorsTier */
type RetireSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the published tier to retire. */
  readonly tierId: Scalars['ID']['input'];
};

/** Autogenerated return type of RetireSponsorsTier */
type RetireSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The tier that was retired. */
  readonly sponsorsTier?: Maybe<SponsorsTier>;
};

/** Autogenerated input type of RevertPullRequest */
type RevertPullRequestInput = {
  /** The description of the revert pull request. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the revert pull request should be a draft. */
  readonly draft?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to revert. */
  readonly pullRequestId: Scalars['ID']['input'];
  /** The title of the revert pull request. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of RevertPullRequest */
type RevertPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The pull request that was reverted. */
  readonly pullRequest?: Maybe<PullRequest>;
  /** The new pull request that reverts the input pull request. */
  readonly revertPullRequest?: Maybe<PullRequest>;
};

/** A user, team, or app who has the ability to dismiss a review on a protected branch. */
type ReviewDismissalAllowance = Node & {
  /** The actor that can dismiss. */
  readonly actor?: Maybe<ReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  readonly id: Scalars['ID']['output'];
};

/** Types that can be an actor. */
type ReviewDismissalAllowanceActor = App | Team | User;

/** The connection type for ReviewDismissalAllowance. */
type ReviewDismissalAllowanceConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ReviewDismissalAllowanceEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
type ReviewDismissedEvent = Node & UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  readonly dismissalMessage?: Maybe<Scalars['String']['output']>;
  /** Identifies the optional message associated with the event, rendered to HTML. */
  readonly dismissalMessageHTML?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  readonly previousReviewState: PullRequestReviewState;
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** Identifies the commit which caused the review to become stale. */
  readonly pullRequestCommit?: Maybe<PullRequestCommit>;
  /** The HTTP path for this review dismissed event. */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the review associated with the 'review_dismissed' event. */
  readonly review?: Maybe<PullRequestReview>;
  /** The HTTP URL for this review dismissed event. */
  readonly url: Scalars['URI']['output'];
};

/** A request for a user to review a pull request. */
type ReviewRequest = Node & {
  /** Whether this request was created for a code owner */
  readonly asCodeOwner: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the pull request associated with this review request. */
  readonly pullRequest: PullRequest;
  /** The reviewer that is requested. */
  readonly requestedReviewer?: Maybe<RequestedReviewer>;
};

/** The connection type for ReviewRequest. */
type ReviewRequestConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReviewRequestEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<ReviewRequest>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type ReviewRequestEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<ReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
type ReviewRequestRemovedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  readonly requestedReviewer?: Maybe<RequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
type ReviewRequestedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** PullRequest referenced by event. */
  readonly pullRequest: PullRequest;
  /** Identifies the reviewer whose review was requested. */
  readonly requestedReviewer?: Maybe<RequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
type ReviewStatusHovercardContext = HovercardContext & {
  /** A string describing this context */
  readonly message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  readonly octicon: Scalars['String']['output'];
  /** The current status of the pull request with respect to code review. */
  readonly reviewDecision?: Maybe<PullRequestReviewDecision>;
};

/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */
type RevokeEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of the user to revoke the migrator role */
  readonly login: Scalars['String']['input'];
};

/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
type RevokeEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organizations that had the migrator role revoked for the given user. */
  readonly organizations?: Maybe<OrganizationConnection>;
};


/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
type RevokeEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of RevokeMigratorRole */
type RevokeMigratorRoleInput = {
  /** The user login or Team slug to revoke the migrator role from. */
  readonly actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  readonly actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of RevokeMigratorRole */
type RevokeMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Did the operation succeed? */
  readonly success?: Maybe<Scalars['Boolean']['output']>;
};

/** Possible roles a user may have in relation to an organization. */
enum RoleInOrganization {
  /** A user who is a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** A user with full administrative access to the organization. */
  Owner = 'OWNER',
  /** A user who is unaffiliated with the organization. */
  Unaffiliated = 'UNAFFILIATED'
}

/** The level of enforcement for a rule or ruleset. */
enum RuleEnforcement {
  /** Rules will be enforced */
  Active = 'ACTIVE',
  /** Do not evaluate or enforce rules */
  Disabled = 'DISABLED',
  /**
   * Allow admins to test rules before enforcing them. Admins can view insights on
   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
   */
  Evaluate = 'EVALUATE'
}

/** Types which can be parameters for `RepositoryRule` objects. */
type RuleParameters = BranchNamePatternParameters | CommitAuthorEmailPatternParameters | CommitMessagePatternParameters | CommitterEmailPatternParameters | PullRequestParameters | RequiredDeploymentsParameters | RequiredStatusChecksParameters | TagNamePatternParameters | UpdateParameters;

/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */
type RuleParametersInput = {
  /** Parameters used for the `branch_name_pattern` rule type */
  readonly branchNamePattern?: InputMaybe<BranchNamePatternParametersInput>;
  /** Parameters used for the `commit_author_email_pattern` rule type */
  readonly commitAuthorEmailPattern?: InputMaybe<CommitAuthorEmailPatternParametersInput>;
  /** Parameters used for the `commit_message_pattern` rule type */
  readonly commitMessagePattern?: InputMaybe<CommitMessagePatternParametersInput>;
  /** Parameters used for the `committer_email_pattern` rule type */
  readonly committerEmailPattern?: InputMaybe<CommitterEmailPatternParametersInput>;
  /** Parameters used for the `pull_request` rule type */
  readonly pullRequest?: InputMaybe<PullRequestParametersInput>;
  /** Parameters used for the `required_deployments` rule type */
  readonly requiredDeployments?: InputMaybe<RequiredDeploymentsParametersInput>;
  /** Parameters used for the `required_status_checks` rule type */
  readonly requiredStatusChecks?: InputMaybe<RequiredStatusChecksParametersInput>;
  /** Parameters used for the `tag_name_pattern` rule type */
  readonly tagNamePattern?: InputMaybe<TagNamePatternParametersInput>;
  /** Parameters used for the `update` rule type */
  readonly update?: InputMaybe<UpdateParametersInput>;
};

/** Types which can have `RepositoryRule` objects. */
type RuleSource = Organization | Repository;

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
enum SamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = 'SHA1',
  /** SHA256 */
  Sha256 = 'SHA256',
  /** SHA384 */
  Sha384 = 'SHA384',
  /** SHA512 */
  Sha512 = 'SHA512'
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
enum SamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = 'RSA_SHA1',
  /** RSA-SHA256 */
  RsaSha256 = 'RSA_SHA256',
  /** RSA-SHA384 */
  RsaSha384 = 'RSA_SHA384',
  /** RSA-SHA512 */
  RsaSha512 = 'RSA_SHA512'
}

/** A Saved Reply is text a user can use to reply quickly. */
type SavedReply = Node & {
  /** The body of the saved reply. */
  readonly body: Scalars['String']['output'];
  /** The saved reply body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The title of the saved reply. */
  readonly title: Scalars['String']['output'];
  /** The user that saved this reply. */
  readonly user?: Maybe<Actor>;
};

/** The connection type for SavedReply. */
type SavedReplyConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SavedReplyEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SavedReply>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SavedReplyEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SavedReply>;
};

/** Ordering options for saved reply connections. */
type SavedReplyOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order saved replies by. */
  readonly field: SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
enum SavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The results of a search. */
type SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User;

/**
 * A list of results that matched against a search query. Regardless of the number
 * of matches, a maximum of 1,000 results will be available across all types,
 * potentially split across many pages.
 */
type SearchResultItemConnection = {
  /**
   * The total number of pieces of code that matched the search query. Regardless
   * of the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  readonly codeCount: Scalars['Int']['output'];
  /**
   * The total number of discussions that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  readonly discussionCount: Scalars['Int']['output'];
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SearchResultItemEdge>>>;
  /**
   * The total number of issues that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  readonly issueCount: Scalars['Int']['output'];
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SearchResultItem>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /**
   * The total number of repositories that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  readonly repositoryCount: Scalars['Int']['output'];
  /**
   * The total number of users that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  readonly userCount: Scalars['Int']['output'];
  /**
   * The total number of wiki pages that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  readonly wikiCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SearchResultItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SearchResultItem>;
  /** Text matches on the result found. */
  readonly textMatches?: Maybe<ReadonlyArray<Maybe<TextMatch>>>;
};

/** Represents the individual results of a search. */
enum SearchType {
  /** Returns matching discussions in repositories. */
  Discussion = 'DISCUSSION',
  /** Returns results matching issues in repositories. */
  Issue = 'ISSUE',
  /** Returns results matching repositories. */
  Repository = 'REPOSITORY',
  /** Returns results matching users and organizations on GitHub. */
  User = 'USER'
}

/** A GitHub Security Advisory */
type SecurityAdvisory = Node & {
  /** The classification of the advisory */
  readonly classification: SecurityAdvisoryClassification;
  /** The CVSS associated with this advisory */
  readonly cvss: Cvss;
  /** CWEs associated with this Advisory */
  readonly cwes: CweConnection;
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** This is a long plaintext description of the advisory */
  readonly description: Scalars['String']['output'];
  /** The GitHub Security Advisory ID */
  readonly ghsaId: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  /** A list of identifiers for this advisory */
  readonly identifiers: ReadonlyArray<SecurityAdvisoryIdentifier>;
  /** The permalink for the advisory's dependabot alerts page */
  readonly notificationsPermalink?: Maybe<Scalars['URI']['output']>;
  /** The organization that originated the advisory */
  readonly origin: Scalars['String']['output'];
  /** The permalink for the advisory */
  readonly permalink?: Maybe<Scalars['URI']['output']>;
  /** When the advisory was published */
  readonly publishedAt: Scalars['DateTime']['output'];
  /** A list of references for this advisory */
  readonly references: ReadonlyArray<SecurityAdvisoryReference>;
  /** The severity of the advisory */
  readonly severity: SecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  readonly summary: Scalars['String']['output'];
  /** When the advisory was last updated */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** Vulnerabilities associated with this Advisory */
  readonly vulnerabilities: SecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  readonly withdrawnAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A GitHub Security Advisory */
type SecurityAdvisoryCwesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A GitHub Security Advisory */
type SecurityAdvisoryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  classifications?: InputMaybe<ReadonlyArray<SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<ReadonlyArray<SecurityAdvisorySeverity>>;
};

/** Classification of the advisory. */
enum SecurityAdvisoryClassification {
  /** Classification of general advisories. */
  General = 'GENERAL',
  /** Classification of malware advisories. */
  Malware = 'MALWARE'
}

/** The connection type for SecurityAdvisory. */
type SecurityAdvisoryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SecurityAdvisory>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** The possible ecosystems of a security vulnerability's package. */
enum SecurityAdvisoryEcosystem {
  /** GitHub Actions */
  Actions = 'ACTIONS',
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Erlang/Elixir packages hosted at hex.pm */
  Erlang = 'ERLANG',
  /** Go modules */
  Go = 'GO',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Dart packages hosted at pub.dev */
  Pub = 'PUB',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS',
  /** Rust crates */
  Rust = 'RUST',
  /** Swift packages */
  Swift = 'SWIFT'
}

/** An edge in a connection. */
type SecurityAdvisoryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
type SecurityAdvisoryIdentifier = {
  /** The identifier type, e.g. GHSA, CVE */
  readonly type: Scalars['String']['output'];
  /** The identifier */
  readonly value: Scalars['String']['output'];
};

/** An advisory identifier to filter results on. */
type SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  readonly type: SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  readonly value: Scalars['String']['input'];
};

/** Identifier formats available for advisories. */
enum SecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = 'CVE',
  /** GitHub Security Advisory ID. */
  Ghsa = 'GHSA'
}

/** Ordering options for security advisory connections */
type SecurityAdvisoryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order security advisories by. */
  readonly field: SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
enum SecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = 'PUBLISHED_AT',
  /** Order advisories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** An individual package */
type SecurityAdvisoryPackage = {
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  readonly ecosystem: SecurityAdvisoryEcosystem;
  /** The package name */
  readonly name: Scalars['String']['output'];
};

/** An individual package version */
type SecurityAdvisoryPackageVersion = {
  /** The package name or version */
  readonly identifier: Scalars['String']['output'];
};

/** A GitHub Security Advisory Reference */
type SecurityAdvisoryReference = {
  /** A publicly accessible reference */
  readonly url: Scalars['URI']['output'];
};

/** Severity of the vulnerability. */
enum SecurityAdvisorySeverity {
  /** Critical. */
  Critical = 'CRITICAL',
  /** High. */
  High = 'HIGH',
  /** Low. */
  Low = 'LOW',
  /** Moderate. */
  Moderate = 'MODERATE'
}

/** An individual vulnerability within an Advisory */
type SecurityVulnerability = {
  /** The Advisory associated with this Vulnerability */
  readonly advisory: SecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  readonly firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  readonly package: SecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  readonly severity: SecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  readonly updatedAt: Scalars['DateTime']['output'];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  readonly vulnerableVersionRange: Scalars['String']['output'];
};

/** The connection type for SecurityVulnerability. */
type SecurityVulnerabilityConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SecurityVulnerability>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SecurityVulnerabilityEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
type SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order security vulnerabilities by. */
  readonly field: SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
enum SecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
type SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  readonly digestMethod: SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  readonly idpCertificate: Scalars['String']['input'];
  /** The Issuer Entity ID for the SAML identity provider */
  readonly issuer?: InputMaybe<Scalars['String']['input']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  readonly signatureMethod: SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  readonly ssoUrl: Scalars['URI']['input'];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider */
type SetEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The identity provider for the enterprise. */
  readonly identityProvider?: Maybe<EnterpriseIdentityProvider>;
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
type SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  readonly expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  readonly limit: RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetOrganizationInteractionLimit */
type SetOrganizationInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that the interaction limit was set for. */
  readonly organization?: Maybe<Organization>;
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
type SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  readonly expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  readonly limit: RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetRepositoryInteractionLimit */
type SetRepositoryInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that the interaction limit was set for. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of SetUserInteractionLimit */
type SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  readonly expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  readonly limit: RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  readonly userId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetUserInteractionLimit */
type SetUserInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that the interaction limit was set for. */
  readonly user?: Maybe<User>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
type SmimeSignature = GitSignature & {
  /** Email used to sign this object. */
  readonly email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  readonly isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  readonly payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  readonly signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  readonly signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  readonly state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  readonly wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Social media profile associated with a user. */
type SocialAccount = {
  /** Name of the social media account as it appears on the profile. */
  readonly displayName: Scalars['String']['output'];
  /** Software or company that hosts the social media account. */
  readonly provider: SocialAccountProvider;
  /** URL of the social media account. */
  readonly url: Scalars['URI']['output'];
};

/** The connection type for SocialAccount. */
type SocialAccountConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SocialAccountEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SocialAccount>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SocialAccountEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SocialAccount>;
};

/** Software or company that hosts social media accounts. */
enum SocialAccountProvider {
  /** Social media and networking website. */
  Facebook = 'FACEBOOK',
  /** Catch-all for social media providers that do not yet have specific handling. */
  Generic = 'GENERIC',
  /** Fork of Mastodon with a greater focus on local posting. */
  Hometown = 'HOMETOWN',
  /** Social media website with a focus on photo and video sharing. */
  Instagram = 'INSTAGRAM',
  /** Professional networking website. */
  Linkedin = 'LINKEDIN',
  /** Open-source federated microblogging service. */
  Mastodon = 'MASTODON',
  /** Social news aggregation and discussion website. */
  Reddit = 'REDDIT',
  /** Live-streaming service. */
  Twitch = 'TWITCH',
  /** Microblogging website. */
  Twitter = 'TWITTER',
  /** Online video platform. */
  Youtube = 'YOUTUBE'
}

/** Entities that can sponsor others via GitHub Sponsors */
type Sponsor = Organization | User;

/** The connection type for Sponsor. */
type SponsorConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SponsorEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Sponsor>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */
type SponsorEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Sponsor>;
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
type SponsorOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsor entities by. */
  readonly field: SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
enum SponsorOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN',
  /** Order sponsors by their relevance to the viewer. */
  Relevance = 'RELEVANCE'
}

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type Sponsorable = {
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  readonly estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  readonly hasSponsorsListing: Scalars['Boolean']['output'];
  /** Whether the given account is sponsoring this user/organization. */
  readonly isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  readonly isSponsoringViewer: Scalars['Boolean']['output'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  readonly monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** List of users and organizations this entity is sponsoring. */
  readonly sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  readonly sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  readonly sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  readonly sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  readonly sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  readonly sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  readonly sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  readonly sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  readonly sponsorshipsAsSponsor: SponsorshipConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  readonly totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  readonly viewerCanSponsor: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  readonly viewerIsSponsoring: Scalars['Boolean']['output'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableIsSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorsActivitiesArgs = {
  actions?: InputMaybe<ReadonlyArray<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableSponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
type SponsorableTotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Entities that can be sponsored via GitHub Sponsors */
type SponsorableItem = Organization | User;

/** The connection type for SponsorableItem. */
type SponsorableItemConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SponsorableItemEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SponsorableItem>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SponsorableItemEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SponsorableItem>;
};

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
type SponsorableOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsorable entities by. */
  readonly field: SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
enum SponsorableOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN'
}

/** An event related to sponsorship activity. */
type SponsorsActivity = Node & {
  /** What action this activity indicates took place. */
  readonly action: SponsorsActivityAction;
  /** The sponsor's current privacy level. */
  readonly currentPrivacyLevel?: Maybe<SponsorshipPrivacy>;
  readonly id: Scalars['ID']['output'];
  /** The tier that the sponsorship used to use, for tier change events. */
  readonly previousSponsorsTier?: Maybe<SponsorsTier>;
  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */
  readonly sponsor?: Maybe<Sponsor>;
  /** The user or organization that is being sponsored, the maintainer. */
  readonly sponsorable: Sponsorable;
  /** The associated sponsorship tier. */
  readonly sponsorsTier?: Maybe<SponsorsTier>;
  /** The timestamp of this event. */
  readonly timestamp?: Maybe<Scalars['DateTime']['output']>;
  /** Was this sponsorship made alongside other sponsorships at the same time from the same sponsor? */
  readonly viaBulkSponsorship: Scalars['Boolean']['output'];
};

/** The possible actions that GitHub Sponsors activities can represent. */
enum SponsorsActivityAction {
  /** The activity was cancelling a sponsorship. */
  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',
  /** The activity was starting a sponsorship. */
  NewSponsorship = 'NEW_SPONSORSHIP',
  /** The activity was scheduling a downgrade or cancellation. */
  PendingChange = 'PENDING_CHANGE',
  /** The activity was funds being refunded to the sponsor or GitHub. */
  Refund = 'REFUND',
  /** The activity was disabling matching for a previously matched sponsorship. */
  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  TierChange = 'TIER_CHANGE'
}

/** The connection type for SponsorsActivity. */
type SponsorsActivityConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SponsorsActivityEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SponsorsActivity>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SponsorsActivityEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SponsorsActivity>;
};

/** Ordering options for GitHub Sponsors activity connections. */
type SponsorsActivityOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order activity by. */
  readonly field: SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
enum SponsorsActivityOrderField {
  /** Order activities by when they happened. */
  Timestamp = 'TIMESTAMP'
}

/** The possible time periods for which Sponsors activities can be requested. */
enum SponsorsActivityPeriod {
  /** Don't restrict the activity to any date range, include all activity. */
  All = 'ALL',
  /** The previous calendar day. */
  Day = 'DAY',
  /** The previous thirty days. */
  Month = 'MONTH',
  /** The previous seven days. */
  Week = 'WEEK'
}

/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */
enum SponsorsCountryOrRegionCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Åland */
  Ax = 'AX',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthélemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei Darussalam */
  Bn = 'BN',
  /** Bolivia */
  Bo = 'BO',
  /** Bonaire, Sint Eustatius and Saba */
  Bq = 'BQ',
  /** Brazil */
  Br = 'BR',
  /** Bahamas */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Bouvet Island */
  Bv = 'BV',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos (Keeling) Islands */
  Cc = 'CC',
  /** Congo (Kinshasa) */
  Cd = 'CD',
  /** Central African Republic */
  Cf = 'CF',
  /** Congo (Brazzaville) */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Côte d'Ivoire */
  Ci = 'CI',
  /** Cook Islands */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cape Verde */
  Cv = 'CV',
  /** Curaçao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czech Republic */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands */
  Fk = 'FK',
  /** Micronesia */
  Fm = 'FM',
  /** Faroe Islands */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** French Guiana */
  Gf = 'GF',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Guadeloupe */
  Gp = 'GP',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** South Georgia and South Sandwich Islands */
  Gs = 'GS',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Heard and McDonald Islands */
  Hm = 'HM',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** Korea, South */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Laos */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin (French part) */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands */
  Mh = 'MH',
  /** Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macau */
  Mo = 'MO',
  /** Northern Mariana Islands */
  Mp = 'MP',
  /** Martinique */
  Mq = 'MQ',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger */
  Ne = 'NE',
  /** Norfolk Island */
  Nf = 'NF',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Reunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russian Federation */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen Islands */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten (Dutch part) */
  Sx = 'SX',
  /** Swaziland */
  Sz = 'SZ',
  /** Turks and Caicos Islands */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** French Southern Lands */
  Tf = 'TF',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** Timor-Leste */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Turkey */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan */
  Tw = 'TW',
  /** Tanzania */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States Minor Outlying Islands */
  Um = 'UM',
  /** United States of America */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Vatican City */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela */
  Ve = 'VE',
  /** Virgin Islands, British */
  Vg = 'VG',
  /** Virgin Islands, U.S. */
  Vi = 'VI',
  /** Vietnam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna Islands */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW'
}

/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */
type SponsorsGoal = {
  /** A description of the goal from the maintainer. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** What the objective of this goal is. */
  readonly kind: SponsorsGoalKind;
  /** The percentage representing how complete this goal is, between 0-100. */
  readonly percentComplete: Scalars['Int']['output'];
  /**
   * What the goal amount is. Represents an amount in USD for monthly sponsorship
   * amount goals. Represents a count of unique sponsors for total sponsors count goals.
   */
  readonly targetValue: Scalars['Int']['output'];
  /** A brief summary of the kind and target value of this goal. */
  readonly title: Scalars['String']['output'];
};

/** The different kinds of goals a GitHub Sponsors member can have. */
enum SponsorsGoalKind {
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',
  /** The goal is about reaching a certain number of sponsors. */
  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT'
}

/** A GitHub Sponsors listing. */
type SponsorsListing = Node & {
  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */
  readonly activeGoal?: Maybe<SponsorsGoal>;
  /**
   * The Stripe Connect account currently in use for payouts for this Sponsors
   * listing, if any. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  readonly activeStripeConnectAccount?: Maybe<StripeConnectAccount>;
  /**
   * The name of the country or region with the maintainer's bank account or fiscal
   * host. Will only return a value when queried by the maintainer themselves, or
   * by an admin of the sponsorable organization.
   */
  readonly billingCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /**
   * The email address used by GitHub to contact the sponsorable about their GitHub
   * Sponsors profile. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  readonly contactEmailAddress?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */
  readonly dashboardResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */
  readonly dashboardUrl: Scalars['URI']['output'];
  /** The records featured on the GitHub Sponsors profile. */
  readonly featuredItems: ReadonlyArray<SponsorsListingFeaturedItem>;
  /**
   * The fiscal host used for payments, if any. Will only return a value when
   * queried by the maintainer themselves, or by an admin of the sponsorable organization.
   */
  readonly fiscalHost?: Maybe<Organization>;
  /** The full description of the listing. */
  readonly fullDescription: Scalars['String']['output'];
  /** The full description of the listing rendered to HTML. */
  readonly fullDescriptionHTML: Scalars['HTML']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether this listing is publicly visible. */
  readonly isPublic: Scalars['Boolean']['output'];
  /** The listing's full name. */
  readonly name: Scalars['String']['output'];
  /** A future date on which this listing is eligible to receive a payout. */
  readonly nextPayoutDate?: Maybe<Scalars['Date']['output']>;
  /**
   * The name of the country or region where the maintainer resides. Will only
   * return a value when queried by the maintainer themselves, or by an admin of
   * the sponsorable organization.
   */
  readonly residenceCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this Sponsors listing. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The short description of the listing. */
  readonly shortDescription: Scalars['String']['output'];
  /** The short name of the listing. */
  readonly slug: Scalars['String']['output'];
  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */
  readonly sponsorable: Sponsorable;
  /** The tiers for this GitHub Sponsors profile. */
  readonly tiers?: Maybe<SponsorsTierConnection>;
  /** The HTTP URL for this Sponsors listing. */
  readonly url: Scalars['URI']['output'];
};


/** A GitHub Sponsors listing. */
type SponsorsListingFeaturedItemsArgs = {
  featureableTypes?: InputMaybe<ReadonlyArray<SponsorsListingFeaturedItemFeatureableType>>;
};


/** A GitHub Sponsors listing. */
type SponsorsListingTiersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeUnpublished?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsTierOrder>;
};

/** A record that can be featured on a GitHub Sponsors profile. */
type SponsorsListingFeatureableItem = Repository | User;

/** A record that is promoted on a GitHub Sponsors profile. */
type SponsorsListingFeaturedItem = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /**
   * Will either be a description from the sponsorable maintainer about why they
   * featured this item, or the item's description itself, such as a user's bio
   * from their GitHub profile page.
   */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** The record that is featured on the GitHub Sponsors profile. */
  readonly featureable: SponsorsListingFeatureableItem;
  readonly id: Scalars['ID']['output'];
  /**
   * The position of this featured item on the GitHub Sponsors profile with a lower
   * position indicating higher precedence. Starts at 1.
   */
  readonly position: Scalars['Int']['output'];
  /** The GitHub Sponsors profile that features this record. */
  readonly sponsorsListing: SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */
enum SponsorsListingFeaturedItemFeatureableType {
  /** A repository owned by the user or organization with the GitHub Sponsors profile. */
  Repository = 'REPOSITORY',
  /** A user who belongs to the organization with the GitHub Sponsors profile. */
  User = 'USER'
}

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
type SponsorsTier = Node & {
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  readonly adminInfo?: Maybe<SponsorsTierAdminInfo>;
  /**
   * Get a different tier for this tier's maintainer that is at the same frequency
   * as this tier but with an equal or lesser cost. Returns the published tier with
   * the monthly price closest to this tier's without going over.
   */
  readonly closestLesserValueTier?: Maybe<SponsorsTier>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The description of the tier. */
  readonly description: Scalars['String']['output'];
  /** The tier description rendered to HTML */
  readonly descriptionHTML: Scalars['HTML']['output'];
  readonly id: Scalars['ID']['output'];
  /**
   * Whether this tier was chosen at checkout time by the sponsor rather than
   * defined ahead of time by the maintainer who manages the Sponsors listing.
   */
  readonly isCustomAmount: Scalars['Boolean']['output'];
  /** Whether this tier is only for use with one-time sponsorships. */
  readonly isOneTime: Scalars['Boolean']['output'];
  /** How much this tier costs per month in cents. */
  readonly monthlyPriceInCents: Scalars['Int']['output'];
  /** How much this tier costs per month in USD. */
  readonly monthlyPriceInDollars: Scalars['Int']['output'];
  /** The name of the tier. */
  readonly name: Scalars['String']['output'];
  /** The sponsors listing that this tier belongs to. */
  readonly sponsorsListing: SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
type SponsorsTierAdminInfo = {
  /**
   * Indicates whether this tier is still a work in progress by the sponsorable and
   * not yet published to the associated GitHub Sponsors profile. Draft tiers
   * cannot be used for new sponsorships and will not be in use on existing
   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the
   * GitHub Sponsors profile.
   */
  readonly isDraft: Scalars['Boolean']['output'];
  /**
   * Indicates whether this tier is published to the associated GitHub Sponsors
   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors
   * profile, and are available for use in sponsorships if the GitHub Sponsors
   * profile is publicly visible.
   */
  readonly isPublished: Scalars['Boolean']['output'];
  /**
   * Indicates whether this tier has been retired from the associated GitHub
   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors
   * profile and cannot be chosen for new sponsorships. Existing sponsorships may
   * still use retired tiers if the sponsor selected the tier before it was retired.
   */
  readonly isRetired: Scalars['Boolean']['output'];
  /** The sponsorships using this tier. */
  readonly sponsorships: SponsorshipConnection;
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
type SponsorsTierAdminInfoSponsorshipsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
type SponsorsTierConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SponsorsTierEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SponsorsTier>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SponsorsTierEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
type SponsorsTierOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order tiers by. */
  readonly field: SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
enum SponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'
}

/** A sponsorship relationship between a sponsor and a maintainer */
type Sponsorship = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /**
   * Whether the sponsorship is active. False implies the sponsor is a past sponsor
   * of the maintainer, while true implies they are a current sponsor.
   */
  readonly isActive: Scalars['Boolean']['output'];
  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */
  readonly isOneTimePayment: Scalars['Boolean']['output'];
  /**
   * Whether the sponsor has chosen to receive sponsorship update emails sent from
   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.
   */
  readonly isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  readonly maintainer: User;
  /** The privacy level for this sponsorship. */
  readonly privacyLevel: SponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  readonly sponsor?: Maybe<User>;
  /** The user or organization that is sponsoring, if you have permission to view them. */
  readonly sponsorEntity?: Maybe<Sponsor>;
  /** The entity that is being sponsored */
  readonly sponsorable: Sponsorable;
  /** The associated sponsorship tier */
  readonly tier?: Maybe<SponsorsTier>;
  /** Identifies the date and time when the current tier was chosen for this sponsorship. */
  readonly tierSelectedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for Sponsorship. */
type SponsorshipConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SponsorshipEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Sponsorship>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
  /**
   * The total amount in cents of all recurring sponsorships in the connection
   * whose amount you can view. Does not include one-time sponsorships.
   */
  readonly totalRecurringMonthlyPriceInCents: Scalars['Int']['output'];
  /**
   * The total amount in USD of all recurring sponsorships in the connection whose
   * amount you can view. Does not include one-time sponsorships.
   */
  readonly totalRecurringMonthlyPriceInDollars: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SponsorshipEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Sponsorship>;
};

/** An update sent to sponsors of a user or organization on GitHub Sponsors. */
type SponsorshipNewsletter = Node & {
  /** The author of the newsletter. */
  readonly author?: Maybe<User>;
  /** The contents of the newsletter, the message the sponsorable wanted to give. */
  readonly body: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Indicates if the newsletter has been made available to sponsors. */
  readonly isPublished: Scalars['Boolean']['output'];
  /** The user or organization this newsletter is from. */
  readonly sponsorable: Sponsorable;
  /** The subject of the newsletter, what it's about. */
  readonly subject: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for SponsorshipNewsletter. */
type SponsorshipNewsletterConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SponsorshipNewsletterEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SponsorshipNewsletter>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SponsorshipNewsletterEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SponsorshipNewsletter>;
};

/** Ordering options for sponsorship newsletter connections. */
type SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsorship newsletters by. */
  readonly field: SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
enum SponsorshipNewsletterOrderField {
  /** Order sponsorship newsletters by when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Ordering options for sponsorship connections. */
type SponsorshipOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order sponsorship by. */
  readonly field: SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
enum SponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The privacy of a sponsorship */
enum SponsorshipPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** The possible default commit messages for squash merges. */
enum SquashMergeCommitMessage {
  /** Default to a blank commit message. */
  Blank = 'BLANK',
  /** Default to the branch's commit messages. */
  CommitMessages = 'COMMIT_MESSAGES',
  /** Default to the pull request's body. */
  PrBody = 'PR_BODY'
}

/** The possible default commit titles for squash merges. */
enum SquashMergeCommitTitle {
  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */
  CommitOrPrTitle = 'COMMIT_OR_PR_TITLE',
  /** Default to the pull request's title. */
  PrTitle = 'PR_TITLE'
}

/** Represents an SSH signature on a Commit or Tag. */
type SshSignature = GitSignature & {
  /** Email used to sign this object. */
  readonly email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  readonly isValid: Scalars['Boolean']['output'];
  /** Hex-encoded fingerprint of the key that signed this object. */
  readonly keyFingerprint?: Maybe<Scalars['String']['output']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  readonly payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  readonly signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  readonly signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  readonly state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  readonly wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Ways in which star connections can be ordered. */
type StarOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field in which to order nodes by. */
  readonly field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
enum StarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = 'STARRED_AT'
}

/** The connection type for User. */
type StargazerConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<StargazerEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a user that's starred a repository. */
type StargazerEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  readonly node: User;
  /** Identifies when the item was starred. */
  readonly starredAt: Scalars['DateTime']['output'];
};

/** Things that can be starred. */
type Starrable = {
  readonly id: Scalars['ID']['output'];
  /** Returns a count of how many stargazers there are on this object */
  readonly stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  readonly stargazers: StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  readonly viewerHasStarred: Scalars['Boolean']['output'];
};


/** Things that can be starred. */
type StarrableStargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};

/** The connection type for Repository. */
type StarredRepositoryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<StarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  readonly isOverLimit: Scalars['Boolean']['output'];
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a starred repository. */
type StarredRepositoryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  readonly node: Repository;
  /** Identifies when the item was starred. */
  readonly starredAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of StartOrganizationMigration */
type StartOrganizationMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The migration source access token. */
  readonly sourceAccessToken: Scalars['String']['input'];
  /** The URL of the organization to migrate. */
  readonly sourceOrgUrl: Scalars['URI']['input'];
  /** The ID of the enterprise the target organization belongs to. */
  readonly targetEnterpriseId: Scalars['ID']['input'];
  /** The name of the target organization. */
  readonly targetOrgName: Scalars['String']['input'];
};

/** Autogenerated return type of StartOrganizationMigration */
type StartOrganizationMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new organization migration. */
  readonly orgMigration?: Maybe<OrganizationMigration>;
};

/** Autogenerated input type of StartRepositoryMigration */
type StartRepositoryMigrationInput = {
  /** The migration source access token. */
  readonly accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether to continue the migration on error. Defaults to `false`. We strongly
   * recommend setting this to `true` for the smoothest migration experience. *This
   * default will change to `true` on September 4, 2023.*
   */
  readonly continueOnError?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded git archive. */
  readonly gitArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  readonly githubPat?: InputMaybe<Scalars['String']['input']>;
  /** Whether to lock the source repository. */
  readonly lockSource?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded metadata archive. */
  readonly metadataArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that will own the imported repository. */
  readonly ownerId: Scalars['ID']['input'];
  /** The name of the imported repository. */
  readonly repositoryName: Scalars['String']['input'];
  /** Whether to skip migrating releases for the repository. */
  readonly skipReleases?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the migration source. */
  readonly sourceId: Scalars['ID']['input'];
  /** The URL of the source repository. */
  readonly sourceRepositoryUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The visibility of the imported repository. */
  readonly targetRepoVisibility?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of StartRepositoryMigration */
type StartRepositoryMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The new repository migration. */
  readonly repositoryMigration?: Maybe<RepositoryMigration>;
};

/** Represents a commit status. */
type Status = Node & {
  /** A list of status contexts and check runs for this commit. */
  readonly combinedContexts: StatusCheckRollupContextConnection;
  /** The commit this status is attached to. */
  readonly commit?: Maybe<Commit>;
  /** Looks up an individual status context by context name. */
  readonly context?: Maybe<StatusContext>;
  /** The individual status contexts for this commit. */
  readonly contexts: ReadonlyArray<StatusContext>;
  readonly id: Scalars['ID']['output'];
  /** The combined commit status. */
  readonly state: StatusState;
};


/** Represents a commit status. */
type StatusCombinedContextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents a commit status. */
type StatusContextArgs = {
  name: Scalars['String']['input'];
};

/** Required status check */
type StatusCheckConfiguration = {
  /** The status check context name that must be present on the commit. */
  readonly context: Scalars['String']['output'];
  /** The optional integration ID that this status check must originate from. */
  readonly integrationId?: Maybe<Scalars['Int']['output']>;
};

/** Required status check */
type StatusCheckConfigurationInput = {
  /** The status check context name that must be present on the commit. */
  readonly context: Scalars['String']['input'];
  /** The optional integration ID that this status check must originate from. */
  readonly integrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents the rollup for both the check runs and status for a commit. */
type StatusCheckRollup = Node & {
  /** The commit the status and check runs are attached to. */
  readonly commit?: Maybe<Commit>;
  /** A list of status contexts and check runs for this commit. */
  readonly contexts: StatusCheckRollupContextConnection;
  readonly id: Scalars['ID']['output'];
  /** The combined status for the commit. */
  readonly state: StatusState;
};


/** Represents the rollup for both the check runs and status for a commit. */
type StatusCheckRollupContextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Types that can be inside a StatusCheckRollup context. */
type StatusCheckRollupContext = CheckRun | StatusContext;

/** The connection type for StatusCheckRollupContext. */
type StatusCheckRollupContextConnection = {
  /** The number of check runs in this rollup. */
  readonly checkRunCount: Scalars['Int']['output'];
  /** Counts of check runs by state. */
  readonly checkRunCountsByState?: Maybe<ReadonlyArray<CheckRunStateCount>>;
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<StatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<StatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The number of status contexts in this rollup. */
  readonly statusContextCount: Scalars['Int']['output'];
  /** Counts of status contexts by state. */
  readonly statusContextCountsByState?: Maybe<ReadonlyArray<StatusContextStateCount>>;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type StatusCheckRollupContextEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<StatusCheckRollupContext>;
};

/** Represents an individual commit status context */
type StatusContext = Node & RequirableByPullRequest & {
  /** The avatar of the OAuth application or the user that created the status */
  readonly avatarUrl?: Maybe<Scalars['URI']['output']>;
  /** This commit this status context is attached to. */
  readonly commit?: Maybe<Commit>;
  /** The name of this status context. */
  readonly context: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The actor who created this status context. */
  readonly creator?: Maybe<Actor>;
  /** The description for this status context. */
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Whether this is required to pass before merging for a specific pull request. */
  readonly isRequired: Scalars['Boolean']['output'];
  /** The state of this status context. */
  readonly state: StatusState;
  /** The URL for this status context. */
  readonly targetUrl?: Maybe<Scalars['URI']['output']>;
};


/** Represents an individual commit status context */
type StatusContextAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** Represents an individual commit status context */
type StatusContextIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents a count of the state of a status context. */
type StatusContextStateCount = {
  /** The number of statuses with this state. */
  readonly count: Scalars['Int']['output'];
  /** The state of a status context. */
  readonly state: StatusState;
};

/** The possible commit status states. */
enum StatusState {
  /** Status is errored. */
  Error = 'ERROR',
  /** Status is expected. */
  Expected = 'EXPECTED',
  /** Status is failing. */
  Failure = 'FAILURE',
  /** Status is pending. */
  Pending = 'PENDING',
  /** Status is successful. */
  Success = 'SUCCESS'
}

/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */
type StripeConnectAccount = {
  /** The account number used to identify this Stripe Connect account. */
  readonly accountId: Scalars['String']['output'];
  /**
   * The name of the country or region of an external account, such as a bank
   * account, tied to the Stripe Connect account. Will only return a value when
   * queried by the maintainer of the associated GitHub Sponsors profile
   * themselves, or by an admin of the sponsorable organization.
   */
  readonly billingCountryOrRegion?: Maybe<Scalars['String']['output']>;
  /**
   * The name of the country or region of the Stripe Connect account. Will only
   * return a value when queried by the maintainer of the associated GitHub
   * Sponsors profile themselves, or by an admin of the sponsorable organization.
   */
  readonly countryOrRegion?: Maybe<Scalars['String']['output']>;
  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */
  readonly isActive: Scalars['Boolean']['output'];
  /** The GitHub Sponsors profile associated with this Stripe Connect account. */
  readonly sponsorsListing: SponsorsListing;
  /** The URL to access this Stripe Connect account on Stripe's website. */
  readonly stripeDashboardUrl: Scalars['URI']['output'];
};

/** Autogenerated input type of SubmitPullRequestReview */
type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The event to send to the Pull Request Review. */
  readonly event: PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  readonly pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Pull Request Review ID to submit. */
  readonly pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of SubmitPullRequestReview */
type SubmitPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The submitted pull request review. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
type Submodule = {
  /** The branch of the upstream submodule for tracking updates */
  readonly branch?: Maybe<Scalars['String']['output']>;
  /** The git URL of the submodule repository */
  readonly gitUrl: Scalars['URI']['output'];
  /** The name of the submodule in .gitmodules */
  readonly name: Scalars['String']['output'];
  /** The name of the submodule in .gitmodules (Base64-encoded) */
  readonly nameRaw: Scalars['Base64String']['output'];
  /** The path in the superproject that this submodule is located in */
  readonly path: Scalars['String']['output'];
  /** The path in the superproject that this submodule is located in (Base64-encoded) */
  readonly pathRaw: Scalars['Base64String']['output'];
  /** The commit revision of the subproject repository being tracked by the submodule */
  readonly subprojectCommitOid?: Maybe<Scalars['GitObjectID']['output']>;
};

/** The connection type for Submodule. */
type SubmoduleConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SubmoduleEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Submodule>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type SubmoduleEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Submodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
type Subscribable = {
  readonly id: Scalars['ID']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
};

/** Entities that can be subscribed to for web and email notifications. */
type SubscribableThread = {
  readonly id: Scalars['ID']['output'];
  /** Identifies the viewer's thread subscription form action. */
  readonly viewerThreadSubscriptionFormAction?: Maybe<ThreadSubscriptionFormAction>;
  /** Identifies the viewer's thread subscription status. */
  readonly viewerThreadSubscriptionStatus?: Maybe<ThreadSubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
type SubscribedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Object referenced by event. */
  readonly subscribable: Subscribable;
};

/** The possible states of a subscription. */
enum SubscriptionState {
  /** The User is never notified. */
  Ignored = 'IGNORED',
  /** The User is notified of all conversations. */
  Subscribed = 'SUBSCRIBED',
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = 'UNSUBSCRIBED'
}

/** A suggestion to review a pull request based on a user's commit history and review comments. */
type SuggestedReviewer = {
  /** Is this suggestion based on past commits? */
  readonly isAuthor: Scalars['Boolean']['output'];
  /** Is this suggestion based on past review comments? */
  readonly isCommenter: Scalars['Boolean']['output'];
  /** Identifies the user suggested to review the pull request. */
  readonly reviewer: User;
};

/** Represents a Git tag. */
type Tag = GitObject & Node & {
  /** An abbreviated version of the Git object ID */
  readonly abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  readonly commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  readonly commitUrl: Scalars['URI']['output'];
  readonly id: Scalars['ID']['output'];
  /** The Git tag message. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The Git tag name. */
  readonly name: Scalars['String']['output'];
  /** The Git object ID */
  readonly oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  readonly repository: Repository;
  /** Details about the tag author. */
  readonly tagger?: Maybe<GitActor>;
  /** The Git object the tag points to. */
  readonly target: GitObject;
};

/** Parameters to be used for the tag_name_pattern rule */
type TagNamePatternParameters = {
  /** How this rule will appear to users. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate: Scalars['Boolean']['output'];
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['output'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['output'];
};

/** Parameters to be used for the tag_name_pattern rule */
type TagNamePatternParametersInput = {
  /** How this rule will appear to users. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  readonly negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  readonly operator: Scalars['String']['input'];
  /** The pattern to match with. */
  readonly pattern: Scalars['String']['input'];
};

/** A team of users in an organization. */
type Team = MemberStatusable & Node & Subscribable & {
  /** A list of teams that are ancestors of this team. */
  readonly ancestors: TeamConnection;
  /** A URL pointing to the team's avatar. */
  readonly avatarUrl?: Maybe<Scalars['URI']['output']>;
  /** List of child teams belonging to this team */
  readonly childTeams: TeamConnection;
  /** The slug corresponding to the organization and team. */
  readonly combinedSlug: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The description of the team. */
  readonly description?: Maybe<Scalars['String']['output']>;
  /** Find a team discussion by its number. */
  readonly discussion?: Maybe<TeamDiscussion>;
  /** A list of team discussions. */
  readonly discussions: TeamDiscussionConnection;
  /** The HTTP path for team discussions */
  readonly discussionsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for team discussions */
  readonly discussionsUrl: Scalars['URI']['output'];
  /** The HTTP path for editing this team */
  readonly editTeamResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for editing this team */
  readonly editTeamUrl: Scalars['URI']['output'];
  readonly id: Scalars['ID']['output'];
  /** A list of pending invitations for users to this team */
  readonly invitations?: Maybe<OrganizationInvitationConnection>;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  readonly memberStatuses: UserStatusConnection;
  /** A list of users who are members of this team. */
  readonly members: TeamMemberConnection;
  /** The HTTP path for the team' members */
  readonly membersResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for the team' members */
  readonly membersUrl: Scalars['URI']['output'];
  /** The name of the team. */
  readonly name: Scalars['String']['output'];
  /** The HTTP path creating a new team */
  readonly newTeamResourcePath: Scalars['URI']['output'];
  /** The HTTP URL creating a new team */
  readonly newTeamUrl: Scalars['URI']['output'];
  /** The notification setting that the team has set. */
  readonly notificationSetting: TeamNotificationSetting;
  /** The organization that owns this team. */
  readonly organization: Organization;
  /** The parent team of the team. */
  readonly parentTeam?: Maybe<Team>;
  /** The level of privacy the team has. */
  readonly privacy: TeamPrivacy;
  /** Finds and returns the project according to the provided project number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** List of projects this team has collaborator access to. */
  readonly projectsV2: ProjectV2Connection;
  /** A list of repositories this team has access to. */
  readonly repositories: TeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  readonly repositoriesResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this team's repositories */
  readonly repositoriesUrl: Scalars['URI']['output'];
  /** The HTTP path for this team */
  readonly resourcePath: Scalars['URI']['output'];
  /** What algorithm is used for review assignment for this team */
  readonly reviewRequestDelegationAlgorithm?: Maybe<TeamReviewAssignmentAlgorithm>;
  /** True if review assignment is enabled for this team */
  readonly reviewRequestDelegationEnabled: Scalars['Boolean']['output'];
  /** How many team members are required for review assignment for this team */
  readonly reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']['output']>;
  /** When assigning team members via delegation, whether the entire team should be notified as well. */
  readonly reviewRequestDelegationNotifyTeam: Scalars['Boolean']['output'];
  /** The slug corresponding to the team. */
  readonly slug: Scalars['String']['output'];
  /** The HTTP path for this team's teams */
  readonly teamsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this team's teams */
  readonly teamsUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this team */
  readonly url: Scalars['URI']['output'];
  /** Team is adminable by the viewer. */
  readonly viewerCanAdminister: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
};


/** A team of users in an organization. */
type TeamAncestorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
type TeamAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
type TeamChildTeamsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  immediateOnly?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamOrder>;
  userLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};


/** A team of users in an organization. */
type TeamDiscussionArgs = {
  number: Scalars['Int']['input'];
};


/** A team of users in an organization. */
type TeamDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isPinned?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamDiscussionOrder>;
};


/** A team of users in an organization. */
type TeamInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A team of users in an organization. */
type TeamMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserStatusOrder>;
};


/** A team of users in an organization. */
type TeamMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  membership?: InputMaybe<TeamMembershipType>;
  orderBy?: InputMaybe<TeamMemberOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<TeamMemberRole>;
};


/** A team of users in an organization. */
type TeamProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** A team of users in an organization. */
type TeamProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<ProjectV2Filters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A team of users in an organization. */
type TeamRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamRepositoryOrder>;
  query?: InputMaybe<Scalars['String']['input']>;
};

/** Audit log entry for a team.add_member event. */
type TeamAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  readonly isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a team.add_repository event. */
type TeamAddRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  readonly isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Metadata for an audit entry with action team.* */
type TeamAuditEntryData = {
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a team.change_parent_team event. */
type TeamChangeParentTeamAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  readonly isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The new parent team. */
  readonly parentTeam?: Maybe<Team>;
  /** The name of the new parent team */
  readonly parentTeamName?: Maybe<Scalars['String']['output']>;
  /** The name of the former parent team */
  readonly parentTeamNameWas?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the parent team */
  readonly parentTeamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the parent team */
  readonly parentTeamUrl?: Maybe<Scalars['URI']['output']>;
  /** The former parent team. */
  readonly parentTeamWas?: Maybe<Team>;
  /** The HTTP path for the previous parent team */
  readonly parentTeamWasResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the previous parent team */
  readonly parentTeamWasUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The connection type for Team. */
type TeamConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<TeamEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Team>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** A team discussion. */
type TeamDiscussion = Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /**
   * Author's association with the discussion's team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /**
   * Identifies the discussion body hash.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly bodyVersion: Scalars['String']['output'];
  /**
   * A list of comments on this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly comments: TeamDiscussionCommentConnection;
  /**
   * The HTTP path for discussion comments
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly commentsResourcePath: Scalars['URI']['output'];
  /**
   * The HTTP URL for discussion comments
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly commentsUrl: Scalars['URI']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /**
   * Whether or not the discussion is pinned.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly isPinned: Scalars['Boolean']['output'];
  /**
   * Whether or not the discussion is only visible to team members and org admins.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly isPrivate: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the discussion within its team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly number: Scalars['Int']['output'];
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /**
   * The HTTP path for this discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly resourcePath: Scalars['URI']['output'];
  /**
   * The team that defines the context of this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly team: Team;
  /**
   * The title of the discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly title: Scalars['String']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /**
   * The HTTP URL for this discussion
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /**
   * Whether or not the current viewer can pin this discussion.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly viewerCanPin: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  readonly viewerCanSubscribe: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  readonly viewerSubscription?: Maybe<SubscriptionState>;
};


/** A team discussion. */
type TeamDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fromComment?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TeamDiscussionCommentOrder>;
};


/** A team discussion. */
type TeamDiscussionReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A team discussion. */
type TeamDiscussionUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment on a team discussion. */
type TeamDiscussionComment = Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment & {
  /** The actor who authored the comment. */
  readonly author?: Maybe<Actor>;
  /**
   * Author's association with the comment's team.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  readonly body: Scalars['String']['output'];
  /** The body rendered to HTML. */
  readonly bodyHTML: Scalars['HTML']['output'];
  /** The body rendered to text. */
  readonly bodyText: Scalars['String']['output'];
  /**
   * The current version of the body content.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly bodyVersion: Scalars['String']['output'];
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Check if this comment was created via an email reply. */
  readonly createdViaEmail: Scalars['Boolean']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /**
   * The discussion this comment is about.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly discussion: TeamDiscussion;
  /** The actor who edited the comment. */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Check if this comment was edited and includes an edit with the creation data */
  readonly includesCreatedEdit: Scalars['Boolean']['output'];
  /** The moment the editor made the last edit */
  readonly lastEditedAt?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Identifies the comment number.
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly number: Scalars['Int']['output'];
  /** Identifies when the comment was published at. */
  readonly publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A list of reactions grouped by content left on the subject. */
  readonly reactionGroups?: Maybe<ReadonlyArray<ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  readonly reactions: ReactionConnection;
  /**
   * The HTTP path for this comment
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly resourcePath: Scalars['URI']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /**
   * The HTTP URL for this comment
   * @deprecated The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC.
   */
  readonly url: Scalars['URI']['output'];
  /** A list of edits to this content. */
  readonly userContentEdits?: Maybe<UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  readonly viewerCanDelete: Scalars['Boolean']['output'];
  /** Can user react to this subject */
  readonly viewerCanReact: Scalars['Boolean']['output'];
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  readonly viewerDidAuthor: Scalars['Boolean']['output'];
};


/** A comment on a team discussion. */
type TeamDiscussionCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<ReactionContent>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReactionOrder>;
};


/** A comment on a team discussion. */
type TeamDiscussionCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for TeamDiscussionComment. */
type TeamDiscussionCommentConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<TeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<TeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type TeamDiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<TeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
type TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field by which to order nodes. */
  readonly field: TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
enum TeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = 'NUMBER'
}

/** The connection type for TeamDiscussion. */
type TeamDiscussionConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<TeamDiscussionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<TeamDiscussion>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type TeamDiscussionEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<TeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
type TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field by which to order nodes. */
  readonly field: TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
enum TeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = 'CREATED_AT'
}

/** An edge in a connection. */
type TeamEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Team>;
};

/** The connection type for User. */
type TeamMemberConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<TeamMemberEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a user who is a member of a team. */
type TeamMemberEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The HTTP path to the organization's member access page. */
  readonly memberAccessResourcePath: Scalars['URI']['output'];
  /** The HTTP URL to the organization's member access page. */
  readonly memberAccessUrl: Scalars['URI']['output'];
  readonly node: User;
  /** The role the member has on the team. */
  readonly role: TeamMemberRole;
};

/** Ordering options for team member connections */
type TeamMemberOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order team members by. */
  readonly field: TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
enum TeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order team members by login */
  Login = 'LOGIN'
}

/** The possible team member roles; either 'maintainer' or 'member'. */
enum TeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = 'MAINTAINER',
  /** A team member has no administrative permissions on the team. */
  Member = 'MEMBER'
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
enum TeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = 'ALL',
  /** Includes only child team members for the team. */
  ChildTeam = 'CHILD_TEAM',
  /** Includes only immediate members of the team. */
  Immediate = 'IMMEDIATE'
}

/** The possible team notification values. */
enum TeamNotificationSetting {
  /** No one will receive notifications. */
  NotificationsDisabled = 'NOTIFICATIONS_DISABLED',
  /** Everyone will receive notifications when the team is @mentioned. */
  NotificationsEnabled = 'NOTIFICATIONS_ENABLED'
}

/** Ways in which team connections can be ordered. */
type TeamOrder = {
  /** The direction in which to order nodes. */
  readonly direction: OrderDirection;
  /** The field in which to order nodes by. */
  readonly field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
enum TeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = 'NAME'
}

/** The possible team privacy values. */
enum TeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = 'SECRET',
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = 'VISIBLE'
}

/** Audit log entry for a team.remove_member event. */
type TeamRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  readonly isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** Audit log entry for a team.remove_repository event. */
type TeamRemoveRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {
  /** The action name */
  readonly action: Scalars['String']['output'];
  /** The user who initiated the action */
  readonly actor?: Maybe<AuditEntryActor>;
  /** The IP address of the actor */
  readonly actorIp?: Maybe<Scalars['String']['output']>;
  /** A readable representation of the actor's location */
  readonly actorLocation?: Maybe<ActorLocation>;
  /** The username of the user who initiated the action */
  readonly actorLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the actor. */
  readonly actorResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the actor. */
  readonly actorUrl?: Maybe<Scalars['URI']['output']>;
  /** The time the action was initiated */
  readonly createdAt: Scalars['PreciseDateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether the team was mapped to an LDAP Group. */
  readonly isLdapMapped?: Maybe<Scalars['Boolean']['output']>;
  /** The corresponding operation type for the action */
  readonly operationType?: Maybe<OperationType>;
  /** The Organization associated with the Audit Entry. */
  readonly organization?: Maybe<Organization>;
  /** The name of the Organization. */
  readonly organizationName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the organization */
  readonly organizationResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the organization */
  readonly organizationUrl?: Maybe<Scalars['URI']['output']>;
  /** The repository associated with the action */
  readonly repository?: Maybe<Repository>;
  /** The name of the repository */
  readonly repositoryName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the repository */
  readonly repositoryResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the repository */
  readonly repositoryUrl?: Maybe<Scalars['URI']['output']>;
  /** The team associated with the action */
  readonly team?: Maybe<Team>;
  /** The name of the team */
  readonly teamName?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for this team */
  readonly teamResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for this team */
  readonly teamUrl?: Maybe<Scalars['URI']['output']>;
  /** The user affected by the action */
  readonly user?: Maybe<User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  readonly userLogin?: Maybe<Scalars['String']['output']>;
  /** The HTTP path for the user. */
  readonly userResourcePath?: Maybe<Scalars['URI']['output']>;
  /** The HTTP URL for the user. */
  readonly userUrl?: Maybe<Scalars['URI']['output']>;
};

/** The connection type for Repository. */
type TeamRepositoryConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<TeamRepositoryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Repository>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** Represents a team repository. */
type TeamRepositoryEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  readonly node: Repository;
  /** The permission level the team has on the repository */
  readonly permission: RepositoryPermission;
};

/** Ordering options for team repository connections */
type TeamRepositoryOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order repositories by. */
  readonly field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
enum TeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by permission */
  Permission = 'PERMISSION',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible team review assignment algorithms */
enum TeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = 'LOAD_BALANCE',
  /** Alternate reviews between each team member */
  RoundRobin = 'ROUND_ROBIN'
}

/** The role of a user on a team. */
enum TeamRole {
  /** User has admin rights on the team. */
  Admin = 'ADMIN',
  /** User is a member of the team. */
  Member = 'MEMBER'
}

/** A text match within a search result. */
type TextMatch = {
  /** The specific text fragment within the property matched on. */
  readonly fragment: Scalars['String']['output'];
  /** Highlights within the matched fragment. */
  readonly highlights: ReadonlyArray<TextMatchHighlight>;
  /** The property matched on. */
  readonly property: Scalars['String']['output'];
};

/** Represents a single highlight in a search result match. */
type TextMatchHighlight = {
  /** The indice in the fragment where the matched text begins. */
  readonly beginIndice: Scalars['Int']['output'];
  /** The indice in the fragment where the matched text ends. */
  readonly endIndice: Scalars['Int']['output'];
  /** The text matched. */
  readonly text: Scalars['String']['output'];
};

/** The possible states of a thread subscription form action */
enum ThreadSubscriptionFormAction {
  /** The User cannot subscribe or unsubscribe to the thread */
  None = 'NONE',
  /** The User can subscribe to the thread */
  Subscribe = 'SUBSCRIBE',
  /** The User can unsubscribe to the thread */
  Unsubscribe = 'UNSUBSCRIBE'
}

/** The possible states of a subscription. */
enum ThreadSubscriptionState {
  /** The subscription status is currently disabled. */
  Disabled = 'DISABLED',
  /** The User is never notified because they are ignoring the list */
  IgnoringList = 'IGNORING_LIST',
  /** The User is never notified because they are ignoring the thread */
  IgnoringThread = 'IGNORING_THREAD',
  /** The User is not recieving notifications from this thread */
  None = 'NONE',
  /** The User is notified becuase they are watching the list */
  SubscribedToList = 'SUBSCRIBED_TO_LIST',
  /** The User is notified because they are subscribed to the thread */
  SubscribedToThread = 'SUBSCRIBED_TO_THREAD',
  /** The User is notified because they chose custom settings for this thread. */
  SubscribedToThreadEvents = 'SUBSCRIBED_TO_THREAD_EVENTS',
  /** The User is notified because they chose custom settings for this thread. */
  SubscribedToThreadType = 'SUBSCRIBED_TO_THREAD_TYPE',
  /** The subscription status is currently unavailable. */
  Unavailable = 'UNAVAILABLE'
}

/** A topic aggregates entities that are related to a subject. */
type Topic = Node & Starrable & {
  readonly id: Scalars['ID']['output'];
  /** The topic's name. */
  readonly name: Scalars['String']['output'];
  /**
   * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
   */
  readonly relatedTopics: ReadonlyArray<Topic>;
  /** A list of repositories. */
  readonly repositories: RepositoryConnection;
  /** Returns a count of how many stargazers there are on this object */
  readonly stargazerCount: Scalars['Int']['output'];
  /** A list of users who have starred this starrable. */
  readonly stargazers: StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  readonly viewerHasStarred: Scalars['Boolean']['output'];
};


/** A topic aggregates entities that are related to a subject. */
type TopicRelatedTopicsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


/** A topic aggregates entities that are related to a subject. */
type TopicRepositoriesArgs = {
  affiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
  sponsorableOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A topic aggregates entities that are related to a subject. */
type TopicStargazersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
};

/** Metadata for an audit entry with a topic. */
type TopicAuditEntryData = {
  /** The name of the topic added to the repository */
  readonly topic?: Maybe<Topic>;
  /** The name of the topic added to the repository */
  readonly topicName?: Maybe<Scalars['String']['output']>;
};

/** Reason that the suggested topic is declined. */
enum TopicSuggestionDeclineReason {
  /** The suggested topic is not relevant to the repository. */
  NotRelevant = 'NOT_RELEVANT',
  /** The viewer does not like the suggested topic. */
  PersonalPreference = 'PERSONAL_PREFERENCE',
  /** The suggested topic is too general for the repository. */
  TooGeneral = 'TOO_GENERAL',
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  TooSpecific = 'TOO_SPECIFIC'
}

/** The possible states of a tracked issue. */
enum TrackedIssueStates {
  /** The tracked issue is closed */
  Closed = 'CLOSED',
  /** The tracked issue is open */
  Open = 'OPEN'
}

/** Autogenerated input type of TransferEnterpriseOrganization */
type TransferEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise where the organization should be transferred. */
  readonly destinationEnterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to transfer. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferEnterpriseOrganization */
type TransferEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization for which a transfer was initiated. */
  readonly organization?: Maybe<Organization>;
};

/** Autogenerated input type of TransferIssue */
type TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to create labels if they don't exist in the target repository (matched by name) */
  readonly createLabelsIfMissing?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the issue to be transferred */
  readonly issueId: Scalars['ID']['input'];
  /** The Node ID of the repository the issue should be transferred to */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferIssue */
type TransferIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was transferred */
  readonly issue?: Maybe<Issue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
type TransferredEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The repository this came from */
  readonly fromRepository?: Maybe<Repository>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  readonly issue: Issue;
};

/** Represents a Git tree. */
type Tree = GitObject & Node & {
  /** An abbreviated version of the Git object ID */
  readonly abbreviatedOid: Scalars['String']['output'];
  /** The HTTP path for this Git object */
  readonly commitResourcePath: Scalars['URI']['output'];
  /** The HTTP URL for this Git object */
  readonly commitUrl: Scalars['URI']['output'];
  /** A list of tree entries. */
  readonly entries?: Maybe<ReadonlyArray<TreeEntry>>;
  readonly id: Scalars['ID']['output'];
  /** The Git object ID */
  readonly oid: Scalars['GitObjectID']['output'];
  /** The Repository the Git object belongs to */
  readonly repository: Repository;
};

/** Represents a Git tree entry. */
type TreeEntry = {
  /** The extension of the file */
  readonly extension?: Maybe<Scalars['String']['output']>;
  /** Whether or not this tree entry is generated */
  readonly isGenerated: Scalars['Boolean']['output'];
  /** The programming language this file is written in. */
  readonly language?: Maybe<Language>;
  /** Number of lines in the file. */
  readonly lineCount?: Maybe<Scalars['Int']['output']>;
  /** Entry file mode. */
  readonly mode: Scalars['Int']['output'];
  /** Entry file name. */
  readonly name: Scalars['String']['output'];
  /** Entry file name. (Base64-encoded) */
  readonly nameRaw: Scalars['Base64String']['output'];
  /** Entry file object. */
  readonly object?: Maybe<GitObject>;
  /** Entry file Git object ID. */
  readonly oid: Scalars['GitObjectID']['output'];
  /** The full path of the file. */
  readonly path?: Maybe<Scalars['String']['output']>;
  /** The full path of the file. (Base64-encoded) */
  readonly pathRaw?: Maybe<Scalars['Base64String']['output']>;
  /** The Repository the tree entry belongs to */
  readonly repository: Repository;
  /** Entry byte size */
  readonly size: Scalars['Int']['output'];
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  readonly submodule?: Maybe<Submodule>;
  /** Entry file type. */
  readonly type: Scalars['String']['output'];
};

/** Autogenerated input type of UnarchiveProjectV2Item */
type UnarchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to unarchive. */
  readonly itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnarchiveProjectV2Item */
type UnarchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item unarchived from the project. */
  readonly item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of UnarchiveRepository */
type UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to unarchive. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnarchiveRepository */
type UnarchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was unarchived. */
  readonly repository?: Maybe<Repository>;
};

/** Represents an 'unassigned' event on any assignable object. */
type UnassignedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the assignable associated with the event. */
  readonly assignable: Assignable;
  /** Identifies the user or mannequin that was unassigned. */
  readonly assignee?: Maybe<Assignee>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  readonly user?: Maybe<User>;
};

/** Autogenerated input type of UnfollowOrganization */
type UnfollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to unfollow. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowOrganization */
type UnfollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The organization that was unfollowed. */
  readonly organization?: Maybe<Organization>;
};

/** Autogenerated input type of UnfollowUser */
type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to unfollow. */
  readonly userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowUser */
type UnfollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The user that was unfollowed. */
  readonly user?: Maybe<User>;
};

/** Represents a type that can be retrieved by a URL. */
type UniformResourceLocatable = {
  /** The HTML path to this resource. */
  readonly resourcePath: Scalars['URI']['output'];
  /** The URL to this resource. */
  readonly url: Scalars['URI']['output'];
};

/** Represents an unknown signature on a Commit or Tag. */
type UnknownSignature = GitSignature & {
  /** Email used to sign this object. */
  readonly email: Scalars['String']['output'];
  /** True if the signature is valid and verified by GitHub. */
  readonly isValid: Scalars['Boolean']['output'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  readonly payload: Scalars['String']['output'];
  /** ASCII-armored signature header from object. */
  readonly signature: Scalars['String']['output'];
  /** GitHub user corresponding to the email signing this commit. */
  readonly signer?: Maybe<User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  readonly state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  readonly wasSignedByGitHub: Scalars['Boolean']['output'];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
type UnlabeledEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the label associated with the 'unlabeled' event. */
  readonly label: Label;
  /** Identifies the `Labelable` associated with the event. */
  readonly labelable: Labelable;
};

/** Autogenerated input type of UnlinkProjectV2FromRepository */
type UnlinkProjectV2FromRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the repository. */
  readonly projectId: Scalars['ID']['input'];
  /** The ID of the repository to unlink from the project. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkProjectV2FromRepository */
type UnlinkProjectV2FromRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository the project is no longer linked to. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of UnlinkProjectV2FromTeam */
type UnlinkProjectV2FromTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the team. */
  readonly projectId: Scalars['ID']['input'];
  /** The ID of the team to unlink from the project. */
  readonly teamId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkProjectV2FromTeam */
type UnlinkProjectV2FromTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team the project is unlinked from */
  readonly team?: Maybe<Team>;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
type UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project linked to the Repository. */
  readonly projectId: Scalars['ID']['input'];
  /** The ID of the Repository linked to the Project. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
type UnlinkRepositoryFromProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The linked Project. */
  readonly project?: Maybe<Project>;
  /** The linked Repository. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of UnlockLockable */
type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the item to be unlocked. */
  readonly lockableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlockLockable */
type UnlockLockablePayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The item that was unlocked. */
  readonly unlockedRecord?: Maybe<Lockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
type UnlockedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Object that was unlocked. */
  readonly lockable: Lockable;
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
type UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */
type UnmarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The discussion that includes the comment. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of UnmarkFileAsViewed */
type UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as unviewed */
  readonly path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkFileAsViewed */
type UnmarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
type UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  readonly canonicalId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  readonly duplicateId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
type UnmarkIssueAsDuplicatePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue or pull request that was marked as a duplicate. */
  readonly duplicate?: Maybe<IssueOrPullRequest>;
};

/** Autogenerated input type of UnmarkProjectV2AsTemplate */
type UnmarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to unmark as a template. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnmarkProjectV2AsTemplate */
type UnmarkProjectV2AsTemplatePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The project. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
type UnmarkedAsDuplicateEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  readonly canonical?: Maybe<IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  readonly duplicate?: Maybe<IssueOrPullRequest>;
  readonly id: Scalars['ID']['output'];
  /** Canonical and duplicate belong to different repositories. */
  readonly isCrossRepository: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UnminimizeComment */
type UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  readonly subjectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnminimizeComment */
type UnminimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The comment that was unminimized. */
  readonly unminimizedComment?: Maybe<Minimizable>;
};

/** Autogenerated input type of UnpinIssue */
type UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be unpinned */
  readonly issueId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnpinIssue */
type UnpinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue that was unpinned */
  readonly issue?: Maybe<Issue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
type UnpinnedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Identifies the issue associated with the event. */
  readonly issue: Issue;
};

/** Autogenerated input type of UnresolveReviewThread */
type UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to unresolve */
  readonly threadId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnresolveReviewThread */
type UnresolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The thread to resolve. */
  readonly thread?: Maybe<PullRequestReviewThread>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
type UnsubscribedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** Object referenced by event. */
  readonly subscribable: Subscribable;
};

/** Entities that can be updated. */
type Updatable = {
  /** Check if the current viewer can update this object. */
  readonly viewerCanUpdate: Scalars['Boolean']['output'];
};

/** Comments that can be updated. */
type UpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
type UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  readonly allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  readonly allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  readonly blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** The global relay id of the branch protection rule to be updated. */
  readonly branchProtectionRuleId: Scalars['ID']['input'];
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  readonly bypassForcePushActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  readonly bypassPullRequestActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  readonly dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins overwrite branch protection. */
  readonly isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  readonly lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  readonly lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  readonly pattern?: InputMaybe<Scalars['String']['input']>;
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  readonly pushActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  readonly requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  readonly requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  readonly requiredDeploymentEnvironments?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  readonly requiredStatusCheckContexts?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** The list of required status checks */
  readonly requiredStatusChecks?: InputMaybe<ReadonlyArray<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  readonly requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  readonly requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  readonly requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  readonly requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  readonly requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  readonly requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  readonly requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  readonly requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  readonly restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  readonly restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  readonly reviewDismissalActorIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule */
type UpdateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  readonly branchProtectionRule?: Maybe<BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateCheckRun */
type UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  readonly actions?: InputMaybe<ReadonlyArray<CheckRunAction>>;
  /** The node of the check. */
  readonly checkRunId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  readonly completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  readonly conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  readonly detailsUrl?: InputMaybe<Scalars['URI']['input']>;
  /** A reference for the run on the integrator's system. */
  readonly externalId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the check. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** Descriptive details about the run. */
  readonly output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  readonly startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  readonly status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun */
type UpdateCheckRunPayload = {
  /** The updated check run. */
  readonly checkRun?: Maybe<CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
type UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  readonly autoTriggerPreferences: ReadonlyArray<CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateCheckSuitePreferences */
type UpdateCheckSuitePreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateDiscussionComment */
type UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to update. */
  readonly commentId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateDiscussionComment */
type UpdateDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The modified discussion comment. */
  readonly comment?: Maybe<DiscussionComment>;
};

/** Autogenerated input type of UpdateDiscussion */
type UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  readonly categoryId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to update. */
  readonly discussionId: Scalars['ID']['input'];
  /** The new discussion title. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateDiscussion */
type UpdateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The modified discussion. */
  readonly discussion?: Maybe<Discussion>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
type UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The login of a administrator whose role is being changed. */
  readonly login: Scalars['String']['input'];
  /** The new role for the Enterprise administrator. */
  readonly role: EnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
type UpdateEnterpriseAdministratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of changing the administrator's role. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the allow private repository forking policy on the enterprise. */
  readonly policyValue?: InputMaybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The value for the allow private repository forking setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated allow private repository forking setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the base repository permission setting on the enterprise. */
  readonly settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated base repository permission setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the base repository permission setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can change repository visibility setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can change repository visibility setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** Allow members to create internal repositories. Defaults to current value. */
  readonly membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create private repositories. Defaults to current value. */
  readonly membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create public repositories. Defaults to current value. */
  readonly membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  readonly membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  readonly settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can create repositories setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete issues setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can delete issues setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete repositories setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can delete repositories setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can invite collaborators setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can make purchases setting on the enterprise. */
  readonly settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can make purchases setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can update protected branches setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can update protected branches setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated members can view dependency insights setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
type UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the organization projects setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
type UpdateEnterpriseOrganizationProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated organization projects setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */
type UpdateEnterpriseOwnerOrganizationRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the owner belongs to. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization for membership change. */
  readonly organizationId: Scalars['ID']['input'];
  /** The role to assume in the organization. */
  readonly organizationRole: RoleInOrganization;
};

/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */
type UpdateEnterpriseOwnerOrganizationRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of changing the owner's organization role. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
type UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The description of the enterprise. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID to update. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The location of the enterprise. */
  readonly location?: InputMaybe<Scalars['String']['input']>;
  /** The name of the enterprise. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the enterprise's website. */
  readonly websiteUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateEnterpriseProfile */
type UpdateEnterpriseProfilePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated enterprise. */
  readonly enterprise?: Maybe<Enterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
type UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the repository projects setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
type UpdateEnterpriseRepositoryProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated repository projects setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
type UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the team discussions setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
type UpdateEnterpriseTeamDiscussionsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated team discussions setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  readonly enterpriseId: Scalars['ID']['input'];
  /** The value for the two factor authentication required setting on the enterprise. */
  readonly settingValue: EnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The enterprise with the updated two factor authentication required setting. */
  readonly enterprise?: Maybe<Enterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateEnvironment */
type UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the environment. */
  readonly environmentId: Scalars['ID']['input'];
  /** The ids of users or teams that can approve deployments to this environment */
  readonly reviewers?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The wait timer in minutes. */
  readonly waitTimer?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateEnvironment */
type UpdateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated environment. */
  readonly environment?: Maybe<Environment>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
type UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  readonly ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list enabled setting. */
  readonly settingValue: IpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting */
type UpdateIpAllowListEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list owner on which the setting was updated. */
  readonly owner?: Maybe<IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
type UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  readonly allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to update. */
  readonly ipAllowListEntryId: Scalars['ID']['input'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  readonly isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIpAllowListEntry */
type UpdateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list entry that was updated. */
  readonly ipAllowListEntry?: Maybe<IpAllowListEntry>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner. */
  readonly ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  readonly settingValue: IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */
type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The IP allow list owner on which the setting was updated. */
  readonly owner?: Maybe<IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIssueComment */
type UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IssueComment to modify. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateIssueComment */
type UpdateIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  readonly issueComment?: Maybe<IssueComment>;
};

/** Autogenerated input type of UpdateIssue */
type UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  readonly assigneeIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Issue to modify. */
  readonly id: Scalars['ID']['input'];
  /** An array of Node IDs of labels for this issue. */
  readonly labelIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  readonly milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  readonly projectIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The desired issue state. */
  readonly state?: InputMaybe<IssueState>;
  /** The title for the issue. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateIssue */
type UpdateIssuePayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The issue. */
  readonly issue?: Maybe<Issue>;
};

/** Autogenerated input type of UpdateLabel */
type UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  readonly color?: InputMaybe<Scalars['String']['input']>;
  /** A brief description of the label, such as its purpose. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be updated. */
  readonly id: Scalars['ID']['input'];
  /** The updated name of the label. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateLabel */
type UpdateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated label. */
  readonly label?: Maybe<Label>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
type UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  readonly ownerId: Scalars['ID']['input'];
  /** The value for the restrict notifications setting. */
  readonly settingValue: NotificationRestrictionSettingValue;
};

/** Autogenerated return type of UpdateNotificationRestrictionSetting */
type UpdateNotificationRestrictionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The owner on which the setting was updated. */
  readonly owner?: Maybe<VerifiableDomainOwner>;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable forking of private repositories in the organization? */
  readonly forkingEnabled: Scalars['Boolean']['input'];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  readonly organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The organization with the updated allow private repository forking setting. */
  readonly organization?: Maybe<Organization>;
};

/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */
type UpdateOrganizationWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization on which to set the web commit signoff setting. */
  readonly organizationId: Scalars['ID']['input'];
  /** Enable signoff on web-based commits for repositories in the organization? */
  readonly webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting */
type UpdateOrganizationWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The organization with the updated web commit signoff setting. */
  readonly organization?: Maybe<Organization>;
};

/** Only allow users with bypass permission to update matching refs. */
type UpdateParameters = {
  /** Branch can pull changes from its upstream repository */
  readonly updateAllowsFetchAndMerge: Scalars['Boolean']['output'];
};

/** Only allow users with bypass permission to update matching refs. */
type UpdateParametersInput = {
  /** Branch can pull changes from its upstream repository */
  readonly updateAllowsFetchAndMerge: Scalars['Boolean']['input'];
};

/** Autogenerated input type of UpdateProjectCard */
type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the ProjectCard should be archived */
  readonly isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The note of ProjectCard. */
  readonly note?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to update. */
  readonly projectCardId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectCard */
type UpdateProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated ProjectCard. */
  readonly projectCard?: Maybe<ProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project column. */
  readonly name: Scalars['String']['input'];
  /** The ProjectColumn ID to update. */
  readonly projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectColumn */
type UpdateProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated project column. */
  readonly projectColumn?: Maybe<ProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
type UpdateProjectInput = {
  /** The description of project. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  readonly projectId: Scalars['ID']['input'];
  /** Whether the project is public or not. */
  readonly public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the project is open or closed. */
  readonly state?: InputMaybe<ProjectState>;
};

/** Autogenerated return type of UpdateProject */
type UpdateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated project. */
  readonly project?: Maybe<Project>;
};

/** Autogenerated input type of UpdateProjectV2Collaborators */
type UpdateProjectV2CollaboratorsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The collaborators to update. */
  readonly collaborators: ReadonlyArray<ProjectV2Collaborator>;
  /** The ID of the project to update the collaborators for. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectV2Collaborators */
type UpdateProjectV2CollaboratorsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The collaborators granted a role */
  readonly collaborators?: Maybe<ProjectV2ActorConnection>;
};


/** Autogenerated return type of UpdateProjectV2Collaborators */
type UpdateProjectV2CollaboratorsPayloadCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateProjectV2DraftIssue */
type UpdateProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  readonly assigneeIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft issue to update. */
  readonly draftIssueId: Scalars['ID']['input'];
  /** The title of the draft issue. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateProjectV2DraftIssue */
type UpdateProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The draft issue updated in the project. */
  readonly draftIssue?: Maybe<DraftIssue>;
};

/** Autogenerated input type of UpdateProjectV2 */
type UpdateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Set the project to closed or open. */
  readonly closed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the Project to update. */
  readonly projectId: Scalars['ID']['input'];
  /** Set the project to public or private. */
  readonly public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Set the readme description of the project. */
  readonly readme?: InputMaybe<Scalars['String']['input']>;
  /** Set the short description of the project. */
  readonly shortDescription?: InputMaybe<Scalars['String']['input']>;
  /** Set the title of the project. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateProjectV2ItemFieldValue */
type UpdateProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be updated. */
  readonly fieldId: Scalars['ID']['input'];
  /** The ID of the item to be updated. */
  readonly itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  readonly projectId: Scalars['ID']['input'];
  /** The value which will be set on the field. */
  readonly value: ProjectV2FieldValue;
};

/** Autogenerated return type of UpdateProjectV2ItemFieldValue */
type UpdateProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated item. */
  readonly projectV2Item?: Maybe<ProjectV2Item>;
};

/** Autogenerated input type of UpdateProjectV2ItemPosition */
type UpdateProjectV2ItemPositionInput = {
  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */
  readonly afterId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be moved. */
  readonly itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  readonly projectId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProjectV2ItemPosition */
type UpdateProjectV2ItemPositionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The items in the new order */
  readonly items?: Maybe<ProjectV2ItemConnection>;
};


/** Autogenerated return type of UpdateProjectV2ItemPosition */
type UpdateProjectV2ItemPositionPayloadItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateProjectV2 */
type UpdateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated Project. */
  readonly projectV2?: Maybe<ProjectV2>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
type UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The head ref oid for the upstream branch. */
  readonly expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars['ID']['input'];
  /** The update branch method to use. If omitted, defaults to 'MERGE' */
  readonly updateMethod?: InputMaybe<PullRequestBranchUpdateMethod>;
};

/** Autogenerated return type of UpdatePullRequestBranch */
type UpdatePullRequestBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UpdatePullRequest */
type UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  readonly assigneeIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  readonly baseRefName?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this pull request. */
  readonly labelIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** Indicates whether maintainers can modify the pull request. */
  readonly maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the milestone for this pull request. */
  readonly milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this pull request. */
  readonly projectIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The Node ID of the pull request. */
  readonly pullRequestId: Scalars['ID']['input'];
  /** The target state of the pull request. */
  readonly state?: InputMaybe<PullRequestUpdateState>;
  /** The title of the pull request. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdatePullRequest */
type UpdatePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request. */
  readonly pullRequest?: Maybe<PullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the comment to modify. */
  readonly pullRequestReviewCommentId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
type UpdatePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  readonly pullRequestReviewComment?: Maybe<PullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  readonly body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to modify. */
  readonly pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePullRequestReview */
type UpdatePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated pull request review. */
  readonly pullRequestReview?: Maybe<PullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
type UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  readonly force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  readonly oid: Scalars['GitObjectID']['input'];
  /** The Node ID of the Ref to be updated. */
  readonly refId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateRef */
type UpdateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated Ref. */
  readonly ref?: Maybe<Ref>;
};

/** Autogenerated input type of UpdateRefs */
type UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of ref updates. */
  readonly refUpdates: ReadonlyArray<RefUpdate>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateRefs */
type UpdateRefsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateRepository */
type UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  readonly description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the discussions feature enabled. */
  readonly hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  readonly hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  readonly hasProjectsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  readonly hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  readonly homepageUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The new name of the repository. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  readonly repositoryId: Scalars['ID']['input'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  readonly template?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateRepository */
type UpdateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateRepositoryRuleset */
type UpdateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  readonly bypassActors?: InputMaybe<ReadonlyArray<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The list of conditions for this ruleset */
  readonly conditions?: InputMaybe<RepositoryRuleConditionsInput>;
  /** The enforcement level for this ruleset */
  readonly enforcement?: InputMaybe<RuleEnforcement>;
  /** The name of the ruleset. */
  readonly name?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be updated. */
  readonly repositoryRulesetId: Scalars['ID']['input'];
  /** The list of rules for this ruleset */
  readonly rules?: InputMaybe<ReadonlyArray<RepositoryRuleInput>>;
  /** The target of the ruleset. */
  readonly target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated return type of UpdateRepositoryRuleset */
type UpdateRepositoryRulesetPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The newly created Ruleset. */
  readonly ruleset?: Maybe<RepositoryRuleset>;
};

/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */
type UpdateRepositoryWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  readonly repositoryId: Scalars['ID']['input'];
  /** Indicates if the repository should require signoff on web-based commits. */
  readonly webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting */
type UpdateRepositoryWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The updated repository. */
  readonly repository?: Maybe<Repository>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
type UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  readonly privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  readonly receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  readonly sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  readonly sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  readonly sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  readonly sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateSponsorshipPreferences */
type UpdateSponsorshipPreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The sponsorship that was updated. */
  readonly sponsorship?: Maybe<Sponsorship>;
};

/** Autogenerated input type of UpdateSubscription */
type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The new state of the subscription. */
  readonly state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  readonly subscribableId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateSubscription */
type UpdateSubscriptionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The input subscribable entity. */
  readonly subscribable?: Maybe<Subscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
type UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  readonly body: Scalars['String']['input'];
  /** The current version of the body content. */
  readonly bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to modify. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
type UpdateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated comment. */
  readonly teamDiscussionComment?: Maybe<TeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
type UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  readonly body?: InputMaybe<Scalars['String']['input']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  readonly bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to modify. */
  readonly id: Scalars['ID']['input'];
  /** If provided, sets the pinned state of the updated discussion. */
  readonly pinned?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated title of the discussion. */
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTeamDiscussion */
type UpdateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The updated discussion. */
  readonly teamDiscussion?: Maybe<TeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
type UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  readonly algorithm?: InputMaybe<TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Turn on or off review assignment */
  readonly enabled: Scalars['Boolean']['input'];
  /** An array of team member IDs to exclude */
  readonly excludedTeamMemberIds?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  /** The Node ID of the team to update review assignments of */
  readonly id: Scalars['ID']['input'];
  /** Notify the entire team of the PR if it is delegated */
  readonly notifyTeam?: InputMaybe<Scalars['Boolean']['input']>;
  /** The number of team members to assign */
  readonly teamMemberCount?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment */
type UpdateTeamReviewAssignmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The team that was modified */
  readonly team?: Maybe<Team>;
};

/** Autogenerated input type of UpdateTeamsRepository */
type UpdateTeamsRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permission that should be granted to the teams. */
  readonly permission: RepositoryPermission;
  /** Repository ID being granted access to. */
  readonly repositoryId: Scalars['ID']['input'];
  /** A list of teams being granted access. Limit: 10 */
  readonly teamIds: ReadonlyArray<Scalars['ID']['input']>;
};

/** Autogenerated return type of UpdateTeamsRepository */
type UpdateTeamsRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The repository that was updated. */
  readonly repository?: Maybe<Repository>;
  /** The teams granted permission on the repository. */
  readonly teams?: Maybe<ReadonlyArray<Team>>;
};

/** Autogenerated input type of UpdateTopics */
type UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  readonly repositoryId: Scalars['ID']['input'];
  /** An array of topic names. */
  readonly topicNames: ReadonlyArray<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTopics */
type UpdateTopicsPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Names of the provided topics that are not valid. */
  readonly invalidTopicNames?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  /** The updated repository. */
  readonly repository?: Maybe<Repository>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type User = Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  readonly anyPinnableItems: Scalars['Boolean']['output'];
  /** A URL pointing to the user's public avatar. */
  readonly avatarUrl: Scalars['URI']['output'];
  /** The user's public profile bio. */
  readonly bio?: Maybe<Scalars['String']['output']>;
  /** The user's public profile bio as HTML. */
  readonly bioHTML: Scalars['HTML']['output'];
  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */
  readonly canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean']['output'];
  /** A list of commit comments made by this user. */
  readonly commitComments: CommitCommentConnection;
  /** The user's public profile company. */
  readonly company?: Maybe<Scalars['String']['output']>;
  /** The user's public profile company as HTML. */
  readonly companyHTML: Scalars['HTML']['output'];
  /** The collection of contributions this user has made to different repositories. */
  readonly contributionsCollection: ContributionsCollection;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The user's publicly visible profile email. */
  readonly email: Scalars['String']['output'];
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  readonly estimatedNextSponsorsPayoutInCents: Scalars['Int']['output'];
  /** A list of users the given user is followed by. */
  readonly followers: FollowerConnection;
  /** A list of users the given user is following. */
  readonly following: FollowingConnection;
  /** Find gist by repo name. */
  readonly gist?: Maybe<Gist>;
  /** A list of gist comments made by this user. */
  readonly gistComments: GistCommentConnection;
  /** A list of the Gists the user has created. */
  readonly gists: GistConnection;
  /** True if this user/organization has a GitHub Sponsors listing. */
  readonly hasSponsorsListing: Scalars['Boolean']['output'];
  /** The hovercard information for this user in a given context */
  readonly hovercard: Hovercard;
  readonly id: Scalars['ID']['output'];
  /** The interaction ability settings for this user. */
  readonly interactionAbility?: Maybe<RepositoryInteractionAbility>;
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  readonly isBountyHunter: Scalars['Boolean']['output'];
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  readonly isCampusExpert: Scalars['Boolean']['output'];
  /** Whether or not this user is a GitHub Developer Program member. */
  readonly isDeveloperProgramMember: Scalars['Boolean']['output'];
  /** Whether or not this user is a GitHub employee. */
  readonly isEmployee: Scalars['Boolean']['output'];
  /** Whether or not this user is following the viewer. Inverse of viewerIsFollowing */
  readonly isFollowingViewer: Scalars['Boolean']['output'];
  /** Whether or not this user is a member of the GitHub Stars Program. */
  readonly isGitHubStar: Scalars['Boolean']['output'];
  /** Whether or not the user has marked themselves as for hire. */
  readonly isHireable: Scalars['Boolean']['output'];
  /** Whether or not this user is a site administrator. */
  readonly isSiteAdmin: Scalars['Boolean']['output'];
  /** Whether the given account is sponsoring this user/organization. */
  readonly isSponsoredBy: Scalars['Boolean']['output'];
  /** True if the viewer is sponsored by this user/organization. */
  readonly isSponsoringViewer: Scalars['Boolean']['output'];
  /** Whether or not this user is the viewing user. */
  readonly isViewer: Scalars['Boolean']['output'];
  /** A list of issue comments made by this user. */
  readonly issueComments: IssueCommentConnection;
  /** A list of issues associated with this user. */
  readonly issues: IssueConnection;
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  readonly itemShowcase: ProfileItemShowcase;
  /** The user's public profile location. */
  readonly location?: Maybe<Scalars['String']['output']>;
  /** The username used to login. */
  readonly login: Scalars['String']['output'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  readonly monthlyEstimatedSponsorsIncomeInCents: Scalars['Int']['output'];
  /** The user's public profile name. */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** Find an organization by its login that the user belongs to. */
  readonly organization?: Maybe<Organization>;
  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
  readonly organizationVerifiedDomainEmails: ReadonlyArray<Scalars['String']['output']>;
  /** A list of organizations the user belongs to. */
  readonly organizations: OrganizationConnection;
  /** A list of packages under the owner. */
  readonly packages: PackageConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  readonly pinnableItems: PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  readonly pinnedItems: PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  readonly pinnedItemsRemaining: Scalars['Int']['output'];
  /** Find project by number. */
  readonly project?: Maybe<Project>;
  /** Find a project by number. */
  readonly projectV2?: Maybe<ProjectV2>;
  /** A list of projects under the owner. */
  readonly projects: ProjectConnection;
  /** The HTTP path listing user's projects */
  readonly projectsResourcePath: Scalars['URI']['output'];
  /** The HTTP URL listing user's projects */
  readonly projectsUrl: Scalars['URI']['output'];
  /** A list of projects under the owner. */
  readonly projectsV2: ProjectV2Connection;
  /** The user's profile pronouns */
  readonly pronouns?: Maybe<Scalars['String']['output']>;
  /** A list of public keys associated with this user. */
  readonly publicKeys: PublicKeyConnection;
  /** A list of pull requests associated with this user. */
  readonly pullRequests: PullRequestConnection;
  /** Recent projects that this user has modified in the context of the owner. */
  readonly recentProjects: ProjectV2Connection;
  /** A list of repositories that the user owns. */
  readonly repositories: RepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  readonly repositoriesContributedTo: RepositoryConnection;
  /** Find Repository. */
  readonly repository?: Maybe<Repository>;
  /** Discussion comments this user has authored. */
  readonly repositoryDiscussionComments: DiscussionCommentConnection;
  /** Discussions this user has started. */
  readonly repositoryDiscussions: DiscussionConnection;
  /** The HTTP path for this user */
  readonly resourcePath: Scalars['URI']['output'];
  /** Replies this user has saved */
  readonly savedReplies?: Maybe<SavedReplyConnection>;
  /** The user's social media accounts, ordered as they appear on the user's profile. */
  readonly socialAccounts: SocialAccountConnection;
  /** List of users and organizations this entity is sponsoring. */
  readonly sponsoring: SponsorConnection;
  /** List of sponsors for this user or organization. */
  readonly sponsors: SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  readonly sponsorsActivities: SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  readonly sponsorsListing?: Maybe<SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  readonly sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  readonly sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  readonly sponsorshipNewsletters: SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  readonly sponsorshipsAsMaintainer: SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  readonly sponsorshipsAsSponsor: SponsorshipConnection;
  /** Repositories the user has starred. */
  readonly starredRepositories: StarredRepositoryConnection;
  /** The user's description of what they're currently doing. */
  readonly status?: Maybe<UserStatus>;
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  readonly topRepositories: RepositoryConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  readonly totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']['output']>;
  /** The user's Twitter username. */
  readonly twitterUsername?: Maybe<Scalars['String']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this user */
  readonly url: Scalars['URI']['output'];
  /** Can the viewer pin repositories and gists to the profile? */
  readonly viewerCanChangePinnedItems: Scalars['Boolean']['output'];
  /** Can the current viewer create new projects on this owner. */
  readonly viewerCanCreateProjects: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to follow the user. */
  readonly viewerCanFollow: Scalars['Boolean']['output'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  readonly viewerCanSponsor: Scalars['Boolean']['output'];
  /** Whether or not this user is followed by the viewer. Inverse of isFollowingViewer. */
  readonly viewerIsFollowing: Scalars['Boolean']['output'];
  /** True if the viewer is sponsoring this user/organization. */
  readonly viewerIsSponsoring: Scalars['Boolean']['output'];
  /** A list of repositories the given user is watching. */
  readonly watching: RepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  readonly websiteUrl?: Maybe<Scalars['URI']['output']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserAnyPinnableItemsArgs = {
  type?: InputMaybe<PinnableItemType>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserCommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserContributionsCollectionArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  organizationID?: InputMaybe<Scalars['ID']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserFollowersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserFollowingArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserGistArgs = {
  name: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserGistCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserGistsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<GistOrder>;
  privacy?: InputMaybe<GistPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserHovercardArgs = {
  primarySubjectId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserIsSponsoredByArgs = {
  accountLogin: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserIssueCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueCommentOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserIssuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterBy?: InputMaybe<IssueFilters>;
  first?: InputMaybe<Scalars['Int']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<IssueState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserOrganizationArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserOrganizationVerifiedDomainEmailsArgs = {
  login: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<OrganizationOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserPackagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  orderBy?: InputMaybe<PackageOrder>;
  packageType?: InputMaybe<PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<ReadonlyArray<PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  types?: InputMaybe<ReadonlyArray<PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserProjectArgs = {
  number: Scalars['Int']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserProjectV2Args = {
  number: Scalars['Int']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  states?: InputMaybe<ReadonlyArray<ProjectState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserProjectsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProjectV2Order>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserPublicKeysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headRefName?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<IssueOrder>;
  states?: InputMaybe<ReadonlyArray<PullRequestState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserRecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserRepositoriesArgs = {
  affiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  isFork?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserRepositoriesContributedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  contributionTypes?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryContributionType>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssues?: InputMaybe<Scalars['Boolean']['input']>;
  includeUserRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  answered?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  states?: InputMaybe<ReadonlyArray<DiscussionState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SavedReplyOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSocialAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsoringArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorsActivitiesArgs = {
  actions?: InputMaybe<ReadonlyArray<SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorsActivityOrder>;
  period?: InputMaybe<SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']['input']>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includePrivate?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserSponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  maintainerLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  orderBy?: InputMaybe<SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserStarredRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<StarOrder>;
  ownedByViewer?: InputMaybe<Scalars['Boolean']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserTopRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy: RepositoryOrder;
  since?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserTotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']['input']>;
  sponsorableLogins?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
type UserWatchingArgs = {
  affiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RepositoryOrder>;
  ownerAffiliations?: InputMaybe<ReadonlyArray<InputMaybe<RepositoryAffiliation>>>;
  privacy?: InputMaybe<RepositoryPrivacy>;
};

/** The possible durations that a user can be blocked for. */
enum UserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = 'ONE_DAY',
  /** The user was blocked for 30 days */
  OneMonth = 'ONE_MONTH',
  /** The user was blocked for 7 days */
  OneWeek = 'ONE_WEEK',
  /** The user was blocked permanently */
  Permanent = 'PERMANENT',
  /** The user was blocked for 3 days */
  ThreeDays = 'THREE_DAYS'
}

/** Represents a 'user_blocked' event on a given user. */
type UserBlockedEvent = Node & {
  /** Identifies the actor who performed the event. */
  readonly actor?: Maybe<Actor>;
  /** Number of days that the user was blocked for. */
  readonly blockDuration: UserBlockDuration;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  /** The user who was blocked. */
  readonly subject?: Maybe<User>;
};

/** The connection type for User. */
type UserConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<UserEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<User>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edit on user content */
type UserContentEdit = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the date and time when the object was deleted. */
  readonly deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The actor who deleted this content */
  readonly deletedBy?: Maybe<Actor>;
  /** A summary of the changes for this edit */
  readonly diff?: Maybe<Scalars['String']['output']>;
  /** When this content was edited */
  readonly editedAt: Scalars['DateTime']['output'];
  /** The actor who edited this content */
  readonly editor?: Maybe<Actor>;
  readonly id: Scalars['ID']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
};

/** A list of edits to content. */
type UserContentEditConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<UserContentEditEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<UserContentEdit>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type UserContentEditEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<UserContentEdit>;
};

/** Represents a user. */
type UserEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<User>;
};

/** Email attributes from External Identity */
type UserEmailMetadata = {
  /** Boolean to identify primary emails */
  readonly primary?: Maybe<Scalars['Boolean']['output']>;
  /** Type of email */
  readonly type?: Maybe<Scalars['String']['output']>;
  /** Email id */
  readonly value: Scalars['String']['output'];
};

/** The user's description of what they're currently doing. */
type UserStatus = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** An emoji summarizing the user's status. */
  readonly emoji?: Maybe<Scalars['String']['output']>;
  /** The status emoji as HTML. */
  readonly emojiHTML?: Maybe<Scalars['HTML']['output']>;
  /** If set, the status will not be shown after this date. */
  readonly expiresAt?: Maybe<Scalars['DateTime']['output']>;
  readonly id: Scalars['ID']['output'];
  /** Whether this status indicates the user is not fully available on GitHub. */
  readonly indicatesLimitedAvailability: Scalars['Boolean']['output'];
  /** A brief message describing what the user is doing. */
  readonly message?: Maybe<Scalars['String']['output']>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  readonly organization?: Maybe<Organization>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The user who has this status. */
  readonly user: User;
};

/** The connection type for UserStatus. */
type UserStatusConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<UserStatusEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<UserStatus>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type UserStatusEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<UserStatus>;
};

/** Ordering options for user status connections. */
type UserStatusOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order user statuses by. */
  readonly field: UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
enum UserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** A domain that can be verified or approved for an organization or an enterprise. */
type VerifiableDomain = Node & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The DNS host name that should be used for verification. */
  readonly dnsHostName?: Maybe<Scalars['URI']['output']>;
  /** The unicode encoded domain. */
  readonly domain: Scalars['URI']['output'];
  /** Whether a TXT record for verification with the expected host name was found. */
  readonly hasFoundHostName: Scalars['Boolean']['output'];
  /** Whether a TXT record for verification with the expected verification token was found. */
  readonly hasFoundVerificationToken: Scalars['Boolean']['output'];
  readonly id: Scalars['ID']['output'];
  /** Whether or not the domain is approved. */
  readonly isApproved: Scalars['Boolean']['output'];
  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */
  readonly isRequiredForPolicyEnforcement: Scalars['Boolean']['output'];
  /** Whether or not the domain is verified. */
  readonly isVerified: Scalars['Boolean']['output'];
  /** The owner of the domain. */
  readonly owner: VerifiableDomainOwner;
  /** The punycode encoded domain. */
  readonly punycodeEncodedDomain: Scalars['URI']['output'];
  /** The time that the current verification token will expire. */
  readonly tokenExpirationTime?: Maybe<Scalars['DateTime']['output']>;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The current verification token for the domain. */
  readonly verificationToken?: Maybe<Scalars['String']['output']>;
};

/** The connection type for VerifiableDomain. */
type VerifiableDomainConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<VerifiableDomainEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<VerifiableDomain>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type VerifiableDomainEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<VerifiableDomain>;
};

/** Ordering options for verifiable domain connections. */
type VerifiableDomainOrder = {
  /** The ordering direction. */
  readonly direction: OrderDirection;
  /** The field to order verifiable domains by. */
  readonly field: VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
enum VerifiableDomainOrderField {
  /** Order verifiable domains by their creation date. */
  CreatedAt = 'CREATED_AT',
  /** Order verifiable domains by the domain name. */
  Domain = 'DOMAIN'
}

/** Types that can own a verifiable domain. */
type VerifiableDomainOwner = Enterprise | Organization;

/** Autogenerated input type of VerifyVerifiableDomain */
type VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to verify. */
  readonly id: Scalars['ID']['input'];
};

/** Autogenerated return type of VerifyVerifiableDomain */
type VerifyVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  readonly clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The verifiable domain that was verified. */
  readonly domain?: Maybe<VerifiableDomain>;
};

/** A hovercard context with a message describing how the viewer is related. */
type ViewerHovercardContext = HovercardContext & {
  /** A string describing this context */
  readonly message: Scalars['String']['output'];
  /** An octicon to accompany this context */
  readonly octicon: Scalars['String']['output'];
  /** Identifies the user who is related to this context. */
  readonly viewer: User;
};

/** A subject that may be upvoted. */
type Votable = {
  /** Number of upvotes that this subject has received. */
  readonly upvoteCount: Scalars['Int']['output'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  readonly viewerCanUpvote: Scalars['Boolean']['output'];
  /** Whether or not the current user has already upvoted this subject. */
  readonly viewerHasUpvoted: Scalars['Boolean']['output'];
};

/** A workflow contains meta information about an Actions workflow file. */
type Workflow = Node & UniformResourceLocatable & {
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['ID']['output'];
  /** The name of the workflow. */
  readonly name: Scalars['String']['output'];
  /** The HTTP path for this workflow */
  readonly resourcePath: Scalars['URI']['output'];
  /** The runs of the workflow. */
  readonly runs: WorkflowRunConnection;
  /** The state of the workflow. */
  readonly state: WorkflowState;
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this workflow */
  readonly url: Scalars['URI']['output'];
};


/** A workflow contains meta information about an Actions workflow file. */
type WorkflowRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<WorkflowRunOrder>;
};

/** A workflow run. */
type WorkflowRun = Node & UniformResourceLocatable & {
  /** The check suite this workflow run belongs to. */
  readonly checkSuite: CheckSuite;
  /** Identifies the date and time when the object was created. */
  readonly createdAt: Scalars['DateTime']['output'];
  /** Identifies the primary key from the database. */
  readonly databaseId?: Maybe<Scalars['Int']['output']>;
  /** The log of deployment reviews */
  readonly deploymentReviews: DeploymentReviewConnection;
  /** The event that triggered the workflow run */
  readonly event: Scalars['String']['output'];
  /** The workflow file */
  readonly file?: Maybe<WorkflowRunFile>;
  readonly id: Scalars['ID']['output'];
  /** The pending deployment requests of all check runs in this workflow run */
  readonly pendingDeploymentRequests: DeploymentRequestConnection;
  /** The HTTP path for this workflow run */
  readonly resourcePath: Scalars['URI']['output'];
  /** A number that uniquely identifies this workflow run in its parent workflow. */
  readonly runNumber: Scalars['Int']['output'];
  /** Identifies the date and time when the object was last updated. */
  readonly updatedAt: Scalars['DateTime']['output'];
  /** The HTTP URL for this workflow run */
  readonly url: Scalars['URI']['output'];
  /** The workflow executed in this workflow run. */
  readonly workflow: Workflow;
};


/** A workflow run. */
type WorkflowRunDeploymentReviewsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A workflow run. */
type WorkflowRunPendingDeploymentRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for WorkflowRun. */
type WorkflowRunConnection = {
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<WorkflowRunEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<WorkflowRun>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  readonly totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
type WorkflowRunEdge = {
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<WorkflowRun>;
};

/** An executed workflow file for a workflow run. */
type WorkflowRunFile = Node & UniformResourceLocatable & {
  readonly id: Scalars['ID']['output'];
  /** The path of the workflow file relative to its repository. */
  readonly path: Scalars['String']['output'];
  /** The direct link to the file in the repository which stores the workflow file. */
  readonly repositoryFileUrl: Scalars['URI']['output'];
  /** The repository name and owner which stores the workflow file. */
  readonly repositoryName: Scalars['URI']['output'];
  /** The HTTP path for this workflow run file */
  readonly resourcePath: Scalars['URI']['output'];
  /** The parent workflow run execution for this file. */
  readonly run: WorkflowRun;
  /** The HTTP URL for this workflow run file */
  readonly url: Scalars['URI']['output'];
  /** If the viewer has permissions to push to the repository which stores the workflow. */
  readonly viewerCanPushRepository: Scalars['Boolean']['output'];
  /** If the viewer has permissions to read the repository which stores the workflow. */
  readonly viewerCanReadRepository: Scalars['Boolean']['output'];
};

/** Ways in which lists of workflow runs can be ordered upon return. */
type WorkflowRunOrder = {
  /** The direction in which to order workflow runs by the specified field. */
  readonly direction: OrderDirection;
  /** The field by which to order workflows. */
  readonly field: WorkflowRunOrderField;
};

/** Properties by which workflow run connections can be ordered. */
enum WorkflowRunOrderField {
  /** Order workflow runs by most recently created */
  CreatedAt = 'CREATED_AT'
}

/** The possible states for a workflow. */
enum WorkflowState {
  /** The workflow is active. */
  Active = 'ACTIVE',
  /** The workflow was deleted from the git repository. */
  Deleted = 'DELETED',
  /** The workflow was disabled by default on a fork. */
  DisabledFork = 'DISABLED_FORK',
  /** The workflow was disabled for inactivity in the repository. */
  DisabledInactivity = 'DISABLED_INACTIVITY',
  /** The workflow was disabled manually. */
  DisabledManually = 'DISABLED_MANUALLY'
}

type GetLatestCommitChecksQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  expression: Scalars['String']['input'];
}>;


type GetLatestCommitChecksQuery = { readonly repository?: { readonly object?: { readonly __typename: 'Blob' } | { readonly __typename: 'Commit', readonly statusCheckRollup?: { readonly contexts: { readonly nodes?: ReadonlyArray<{ readonly __typename: 'CheckRun', readonly conclusion?: CheckConclusionState | null, readonly permalink: string, readonly status: CheckStatusState, readonly name: string } | { readonly __typename: 'StatusContext' } | null> | null } } | null } | { readonly __typename: 'Tag' } | { readonly __typename: 'Tree' } | null } | null };


/**
 * @param resolver a function that accepts a captured request and may return a mocked response.
 * @see https://mswjs.io/docs/basics/response-resolver
 * @example
 * mockGetLatestCommitChecksQuery((req, res, ctx) => {
 *   const { owner, repo, expression } = req.variables;
 *   return res(
 *     ctx.data({ repository })
 *   )
 * })
 */
export const mockGetLatestCommitChecksQuery = (resolver: ResponseResolver<GraphQLRequest<GetLatestCommitChecksQueryVariables>, GraphQLContext<GetLatestCommitChecksQuery>, any>) =>
  graphql.query<GetLatestCommitChecksQuery, GetLatestCommitChecksQueryVariables>(
    'GetLatestCommitChecks',
    resolver
  )
